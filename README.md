# Hamit MÄ±zrak

## ğŸ” Hamit MÄ±zrak Repo Ä°statistikleri

![ZiyaretÃ§i SayÄ±sÄ±](https://visitor-badge.laobi.icu/badge?page_id=hamitmizrak.https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2)
![Stars](https://img.shields.io/github/stars/hamitmizrak/https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2?style=social)
![Forks](https://img.shields.io/github/forks/hamitmizrak/https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2?style=social)
![Son Commit](https://img.shields.io/github/last-commit/hamitmizrak/https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2)
![License](https://img.shields.io/github/license/hamitmizrak/https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2)

## ğŸ† Hamit MÄ±zrak Profil Ã–dÃ¼lleri

![Trophy](https://github-profile-trophy.vercel.app/?username=hamitmizrak&theme=gruvbox)

## ğŸ“Š Hamit MÄ±zrak GitHub KullanÄ±cÄ± Ä°statistikleri

![GitHub Stats](https://github-readme-stats.vercel.app/api?username=hamitmizrak&show_icons=true&theme=tokyonight)
<br>
![Top Languages](https://github-readme-stats.vercel.app/api/top-langs/?username=hamitmizrak&layout=compact)
<br>
[![Pinned Repo](https://github-readme-stats.vercel.app/api/pin/?username=hamitmizrak&repo=https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2)](https://github.com/hamitmizrak/https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2)

## ğŸ“ˆ Hamit MÄ±zrak Aktivite GrafiÄŸi

![Activity Graph](https://github-readme-activity-graph.vercel.app/graph?username=hamitmizrak&theme=react-dark)

## â±ï¸ Hamit MÄ±zrak Kod Yazma ZamanÄ± (WakaTime)

<!-- WakaTime hesabÄ±n varsa -->

[![WakaTime](https://github-readme-stats.vercel.app/api/wakatime?username=hamitmizrak)](https://wakatime.com/@hamitmizrak)

# Ecodation Full Stack Frontend -2

[GitHub Address](https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2.git)

---

# Java Ecodation Full Stack-2 Spring Boot
**Spring Boot**
---

[GitHub](https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2.git )

## Project GitHub clone 
```sh
git clone https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2.git 
```
---

## Version
```sh
git -v
java --version
javac --version
mvn -v
docker version
docker -v
docker-compose version
```
---


## Git Init
```sh 
git init
git add .
git commit -m "spring boot init"
git remote add origin URL
git push -u origin master

git clone https://github.com/hamitmizrak/Ecodation_2025_FullStack_SpringReact_2.git 
```
---

## Git Codes
```sh
git status
git logs

```


### Ã–rnek Kodu AÃ§Ä±klamasÄ±:
```java
private ApiResult apiResult;
@PostConstruct
public void springData() {
    apiResult = new ApiResult();
}
```
## Spring Framework Nedir ?
```sh 

```
---

Spring Framework, Java platformu Ã¼zerinde kurulu, aÃ§Ä±k kaynaklÄ± ve popÃ¼ler bir uygulama geliÅŸtirme Ã§erÃ§evesidir. Spring, Ã¶zellikle kurumsal uygulamalarÄ±n geliÅŸtirilmesini basitleÅŸtirmeyi hedefler. Bu Ã§erÃ§eve, uygulamalarda baÄŸÄ±mlÄ±lÄ±k yÃ¶netimini ve uygulama mantÄ±ÄŸÄ±nÄ±n modÃ¼ler bir ÅŸekilde geliÅŸtirilmesini saÄŸlar. Spring Framework, IoC (Inversion of Control - Denetim Ters Ã‡evirme) ve DI (Dependency Injection - BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu) gibi Ã§ekirdek Ã¶zellikler Ã¼zerine kuruludur. Bu Ã¶zellikler, geliÅŸtiricilerin yazÄ±lÄ±m bileÅŸenlerini daha rahat bir ÅŸekilde yÃ¶netmelerine ve baÄŸÄ±mlÄ±lÄ±klarÄ± daha esnek bir ÅŸekilde tanÄ±mlamalarÄ±na olanak tanÄ±r.

### Spring Framework'Ã¼n Ã–zellikleri

Spring Framework birÃ§ok modÃ¼lden oluÅŸur ve her modÃ¼l, belirli bir iÅŸlevselliÄŸi saÄŸlamaya yÃ¶nelik tasarlanmÄ±ÅŸtÄ±r. Bu modÃ¼ller, geliÅŸtiricilere uygulamanÄ±n Ã§eÅŸitli katmanlarÄ±nÄ± ele almada yardÄ±mcÄ± olur. BaÅŸlÄ±ca Ã¶zellikleri ve modÃ¼lleri ÅŸunlardÄ±r:

1. **IoC (Inversion of Control) ve DI (Dependency Injection)**: Springâ€™in en temel Ã¶zelliklerinden biri IoC prensibidir. IoC, nesnelerin baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ±n kendilerinin oluÅŸturulmasÄ± yerine dÄ±ÅŸarÄ±dan yÃ¶netilmesi anlamÄ±na gelir. DI, baÄŸÄ±mlÄ±lÄ±klarÄ±n nesneye dÄ±ÅŸarÄ±dan verilmesi sÃ¼recidir. Bu sayede baÄŸÄ±mlÄ±lÄ±klar kolayca yÃ¶netilir ve test edilebilirlik artar.

2. **Aspect-Oriented Programming (AOP)**: AOP, Ã§apraz kesen endiÅŸeleri ele almak iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, loglama, gÃ¼venlik gibi iÅŸlevler, AOP ile modÃ¼ler hale getirilebilir. AOP, belirli gÃ¶revleri (Ã¶rneÄŸin gÃ¼venlik veya loglama) uygulama mantÄ±ÄŸÄ±ndan ayÄ±rarak, bu gÃ¶revlerin uygulamaya enjekte edilmesine olanak tanÄ±r. Springâ€™in AOP desteÄŸi, kullanÄ±cÄ±larÄ±n Ã¶zelleÅŸtirilebilir yÃ¶ntemleri kullanarak uygulamalarÄ± daha yÃ¶netilebilir hale getirmelerini saÄŸlar.

3. **Transaction Management (Ä°ÅŸlem YÃ¶netimi)**: Spring, veri tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸlamak iÃ§in iÅŸlem yÃ¶netimi saÄŸlar. Bu, Ã¶zellikle veri tabanlarÄ± ve diÄŸer kaynaklarla yapÄ±lan iÅŸlemlerde oldukÃ§a Ã¶nemlidir. Springâ€™in iÅŸlem yÃ¶netimi, programcÄ±larÄ±n iÅŸlem yÃ¶netimini kodlara fazla mÃ¼dahale etmeden ele almalarÄ±na imkan tanÄ±r.

4. **Spring MVC (Model-View-Controller)**: Web tabanlÄ± uygulamalarÄ±n geliÅŸtirilmesi iÃ§in kullanÄ±lan bir modÃ¼ldÃ¼r. MVC mimarisi Ã¼zerine kuruludur ve geliÅŸtiricilere hem basit hem de karmaÅŸÄ±k web uygulamalarÄ± geliÅŸtirme imkanÄ± tanÄ±r. Spring MVC, isteklere yanÄ±t veren denetleyiciler, model-veri yÃ¶netimi ve gÃ¶rÃ¼nÃ¼m ÅŸablonlarÄ±yla gÃ¼Ã§lÃ¼ bir yapÄ± sunar.

5. **Spring Data**: VeritabanÄ± iÅŸlemlerini basitleÅŸtiren bir modÃ¼ldÃ¼r. ORM (Object-Relational Mapping) araÃ§larÄ±yla entegrasyonu saÄŸlar (Ã¶rneÄŸin Hibernate ile). Spring Data, veritabanÄ± iÅŸlemlerinde temel CRUD (Create, Read, Update, Delete) iÅŸlemlerini kolaylaÅŸtÄ±rÄ±r ve veri eriÅŸim katmanÄ±nda tekrarlayan kodlarÄ± minimize eder.

6. **Spring Boot**: Spring Frameworkâ€™Ã¼n daha hÄ±zlÄ± ve kolay kullanÄ±mÄ±nÄ± saÄŸlamak iÃ§in geliÅŸtirilmiÅŸ bir modÃ¼ldÃ¼r. Spring Boot, sÄ±fÄ±rdan bir uygulama baÅŸlatmayÄ± ve ayarlamayÄ± Ã§ok kolay hale getirir. Otomatik yapÄ±landÄ±rma Ã¶zelliÄŸi sayesinde, birÃ§ok ayar dosyasÄ±nÄ± manuel olarak oluÅŸturmanÄ±za gerek kalmaz. Spring Boot aynÄ± zamanda baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilen bir jar dosyasÄ± oluÅŸturma yeteneÄŸi sunar ve bu sayede uygulama daÄŸÄ±tÄ±mÄ± oldukÃ§a kolaylaÅŸÄ±r.

7. **Spring Security**: Uygulamalarda gÃ¼venliÄŸi saÄŸlamak iÃ§in kullanÄ±lan bir modÃ¼ldÃ¼r. Kimlik doÄŸrulama ve yetkilendirme iÅŸlemlerini kolayca yÃ¶netmeyi saÄŸlar. Spring Security, web tabanlÄ± uygulamalarda oturum yÃ¶netimi, kimlik doÄŸrulama, kullanÄ±cÄ± rolleri, eriÅŸim kontrolÃ¼ gibi gÃ¼venlik Ã¶zelliklerini saÄŸlar.

8. **Spring Cloud**: Mikroservis mimarisi iÃ§in Ã¶zel olarak tasarlanmÄ±ÅŸ bir modÃ¼ldÃ¼r. Mikroservisler arasÄ±ndaki iletiÅŸim, yapÄ±landÄ±rma yÃ¶netimi, yÃ¼k dengeleme, hata toleransÄ± gibi konularda Ã§Ã¶zÃ¼m sunar. Spring Cloud, mikroservis tabanlÄ± uygulamalar iÃ§in konfigÃ¼rasyon yÃ¶netimi, servis keÅŸfi, devre kesici (circuit breaker) gibi Ã¶zellikler sunar.

9. **Spring Batch**: Batch (toplu) iÅŸlemleri yÃ¶netmek iÃ§in kullanÄ±lan bir modÃ¼ldÃ¼r. Ã–zellikle bÃ¼yÃ¼k veri iÅŸleme gÃ¶revlerinde ve arka planda Ã§alÄ±ÅŸan toplu iÅŸlerin yÃ¶netiminde kullanÄ±lÄ±r. Spring Batch, toplu iÅŸlemleri zamanlayarak ve iÅŸ akÄ±ÅŸlarÄ±nÄ± dÃ¼zenleyerek veri iÅŸleme sÃ¼reÃ§lerini daha verimli hale getirir.

10. **Spring Integration**: Kurumsal entegrasyon desenlerini (EIP) destekleyen bir modÃ¼ldÃ¼r. Sistemler arasÄ± mesajlaÅŸma, veri senkronizasyonu gibi iÅŸlemleri kolaylaÅŸtÄ±rÄ±r. Spring Integration, uygulamalarÄ±n baÅŸka sistemlerle entegre Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlamak iÃ§in gÃ¼Ã§lÃ¼ bir yapÄ± sunar.

### Spring Frameworkâ€™Ã¼n FaydalarÄ±

- **Test Edilebilirlik**: Spring, DI ve IoC kullanarak nesneler arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¶netir. Bu sayede nesneler baÄŸÄ±msÄ±z olarak test edilebilir hale gelir.
- **ModÃ¼lerlik ve Esneklik**: Springâ€™in modÃ¼ler yapÄ±sÄ±, sadece ihtiyaÃ§ duyulan modÃ¼llerin kullanÄ±lmasÄ±na imkan tanÄ±r.
- **AÃ§Ä±k Kaynak ve Topluluk DesteÄŸi**: Spring, aÃ§Ä±k kaynak kodlu bir Ã§erÃ§eve olduÄŸundan sÃ¼rekli gÃ¼ncellenir ve geniÅŸ bir topluluÄŸa sahiptir.
- **Performans ve Verimlilik**: Spring Framework, iÅŸlem yÃ¶netimi ve veri eriÅŸim katmanÄ± gibi birÃ§ok alanÄ± optimize eder, bu da daha yÃ¼ksek performans saÄŸlar.
- **Kurumsal DÃ¼zeyde Uygulama DesteÄŸi**: Spring, bÃ¼yÃ¼k Ã¶lÃ§ekli kurumsal uygulamalarÄ±n geliÅŸtirilmesinde yaygÄ±n olarak kullanÄ±lÄ±r. Ã–zellikle Spring Cloud ve Spring Batch gibi modÃ¼ller, bÃ¼yÃ¼k veri iÅŸlemlerinde ve mikroservis mimarilerinde iÅŸ yÃ¼kÃ¼nÃ¼ azaltÄ±r.

### Ã–rnek KullanÄ±m Senaryosu

Bir e-ticaret uygulamasÄ± geliÅŸtirdiÄŸinizi dÃ¼ÅŸÃ¼nelim. Bu uygulamada Spring Frameworkâ€™Ã¼n sunduÄŸu Ã¶zellikler ÅŸu ÅŸekillerde kullanÄ±labilir:

1. **Dependency Injection**: Uygulamadaki bileÅŸenler arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±klar, DI sayesinde daha kolay yÃ¶netilir. Ã–rneÄŸin, bir Ã¼rÃ¼n servisi (ProductService) ve bir veri eriÅŸim katmanÄ± (ProductRepository) arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±k DI ile saÄŸlanabilir.

2. **Spring MVC**: Web tabanlÄ± bir yapÄ± olduÄŸu iÃ§in, Spring MVC kullanarak kullanÄ±cÄ±larÄ±n Ã¼rÃ¼nleri listeleyebileceÄŸi, sepete ekleyebileceÄŸi ve satÄ±n alabileceÄŸi bir arayÃ¼z oluÅŸturulabilir.

3. **Spring Data**: ÃœrÃ¼n, mÃ¼ÅŸteri ve sipariÅŸ verileri bir veritabanÄ±nda saklanabilir. Spring Data, bu veriler Ã¼zerinde CRUD iÅŸlemlerini basitleÅŸtirir.

4. **Spring Security**: KullanÄ±cÄ± kimlik doÄŸrulama ve yetkilendirme iÅŸlemleri iÃ§in kullanÄ±labilir. Ã–rneÄŸin, yalnÄ±zca yetkili kullanÄ±cÄ±larÄ±n sipariÅŸ verebilmesini saÄŸlamak iÃ§in Spring Security ile gÃ¼venlik katmanÄ± eklenebilir.

5. **Spring Cloud**: Mikroservis mimarisi tercih ediliyorsa, her hizmeti baÄŸÄ±msÄ±z servisler olarak geliÅŸtirmek iÃ§in Spring Cloud modÃ¼lleri kullanÄ±labilir. Ã–rneÄŸin, Ã¼rÃ¼n ve sipariÅŸ servisi ayrÄ± ayrÄ± mikroservisler olarak geliÅŸtirilebilir.

6. **Spring Batch**: Belirli zamanlarda Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ± gereken veri iÅŸleme gÃ¶revleri varsa (Ã¶rneÄŸin, gÃ¼nlÃ¼k satÄ±ÅŸ raporu oluÅŸturmak gibi), Spring Batch ile bu iÅŸlemler otomatik olarak zamanlanabilir.

### Spring Frameworkâ€™Ã¼n Mimari BileÅŸenleri

Spring Frameworkâ€™Ã¼n Ã§ekirdeÄŸinde IoC kapsayÄ±cÄ±sÄ± (container) bulunur. Bu kapsayÄ±cÄ±, uygulamadaki nesnelerin yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netir. IoC kapsayÄ±cÄ±sÄ±, XML tabanlÄ± konfigÃ¼rasyonlar, anotasyonlar veya Java tabanlÄ± konfigÃ¼rasyonlar ile yapÄ±landÄ±rÄ±labilir. Springâ€™in IoC kapsayÄ±cÄ±sÄ±, uygulama iÃ§inde kullanÄ±lan nesneleri otomatik olarak enjekte eder ve bu nesneler arasÄ±ndaki baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¶netir.

### SonuÃ§

Spring Framework, Java tabanlÄ± uygulamalar geliÅŸtirmek iÃ§in gÃ¼Ã§lÃ¼ ve esnek bir Ã§erÃ§evedir. Ã‡ekirdek modÃ¼lleri ve kapsamlÄ± modÃ¼ler yapÄ±sÄ±yla, hem kÃ¼Ã§Ã¼k Ã¶lÃ§ekli hem de bÃ¼yÃ¼k Ã¶lÃ§ekli kurumsal uygulamalarda kullanÄ±labilir. IoC ve DI gibi modern yazÄ±lÄ±m geliÅŸtirme ilkelerini benimsemesi, uygulamalarÄ±n daha kolay yÃ¶netilebilir, geniÅŸletilebilir ve test edilebilir olmasÄ±nÄ± saÄŸlar. Spring, geniÅŸ topluluk desteÄŸi ve gÃ¼Ã§lÃ¼ ekosistemi ile, yazÄ±lÄ±m geliÅŸtirme sÃ¼recini hÄ±zlandÄ±rÄ±r ve geliÅŸtiricilere esnek bir yapÄ± sunar.

Daha fazla bilgiye ihtiyacÄ±nÄ±z varsa veya herhangi bir modÃ¼l hakkÄ±nda ayrÄ±ntÄ±lÄ± bir aÃ§Ä±klama isterseniz, yardÄ±mcÄ± olmaktan memnuniyet duyarÄ±m.

## Spring Bean KavramÄ±
```sh 

```
---

## ğŸ”§ `@Bean` Anotasyonu Ã–zellikleri

Spring Frameworkâ€™te `@Bean` anotasyonu, bir metodun dÃ¶nÃ¼ÅŸ deÄŸerinin Spring IoC Containerâ€™a bir bean olarak kaydedileceÄŸini belirtir. `@Bean`, aÅŸaÄŸÄ±daki Ã¶zellikleri alabilir:

| Ã–zellik         | AÃ§Ä±klama                                                                              |
| --------------- | ------------------------------------------------------------------------------------- |
| `name`          | Beanâ€™in ismini Ã¶zelleÅŸtirmek iÃ§in kullanÄ±lÄ±r. Aksi halde metodun ismi bean ismi olur. |
| `initMethod`    | Bean oluÅŸturulduktan hemen sonra Ã§alÄ±ÅŸtÄ±rÄ±lacak metodu tanÄ±mlar.                      |
| `destroyMethod` | Uygulama kapanÄ±rken bean yok edilmeden Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacak metodu tanÄ±mlar.           |
| `autowire`      | (Eski) Otomatik baÄŸÄ±mlÄ±lÄ±k Ã§Ã¶zÃ¼mleme stratejisini belirtir (genellikle kullanÄ±lmaz).  |

---

## âœ… Ã–rnek KullanÄ±m â€“ Ã–zellikleriyle Birlikte

AÅŸaÄŸÄ±da `@Bean` anotasyonu tÃ¼m Ã¶zellikleriyle kullanÄ±lmÄ±ÅŸ bir Ã¶rnek:

```java
@Bean(
    name = "customModelMapper",
    initMethod = "customInit",
    destroyMethod = "customDestroy"
)
public ModelMapper modelMapperMethod() {
    return new ModelMapper();
}
```

Ve aynÄ± sÄ±nÄ±f iÃ§inde aÅŸaÄŸÄ±daki destekleyici metotlar bulunabilir:

```java
public void customInit() {
    System.out.println("ModelMapper init edildi.");
}

public void customDestroy() {
    System.out.println("ModelMapper yok edilirken Ã§alÄ±ÅŸtÄ±.");
}
```

> ğŸ’¡ `name` yerine `@Bean("customModelMapper")` ÅŸeklinde de kullanÄ±labilir.

---

## ğŸ” Bean YaÅŸam DÃ¶ngÃ¼sÃ¼ne Etkisi

* `initMethod`: Bean oluÅŸturulup container'a eklendikten hemen sonra Ã§alÄ±ÅŸÄ±r.
* `destroyMethod`: Bean yok edilmeden hemen Ã¶nce Ã§alÄ±ÅŸÄ±r (Ã¶zellikle `@Scope("singleton")` ise Ã¶nemlidir).
* Spring Boot uygulamasÄ±nda Ã§oÄŸu zaman bunlara gerek kalmaz ama Ã¶zel durumlarda Ã§ok iÅŸe yarar (Ã¶rneÄŸin kaynak aÃ§ma/kapama iÅŸlemleri gibi).

---

## Ã–rneÄŸin: ModelMapperBean

```java
@Configuration
public class ModelMapperBean {

    @Bean(name = "modelMapper", initMethod = "onInit", destroyMethod = "onDestroy")
    public ModelMapper modelMapperMethod() {
        return new ModelMapper();
    }

    public void onInit() {
        System.out.println("ModelMapper initialized.");
    }

    public void onDestroy() {
        System.out.println("ModelMapper destroyed.");
    }
}
```


package com.hamitmizrak.bean;

import org.modelmapper.ModelMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ModelMapperBean {

    /**
     * ModelMapper nesnesini Spring Context'e bean olarak tanÄ±mlar.
     * Bean ismi: "modelMapper"
     * initMethod: Bean oluÅŸturulduktan hemen sonra Ã§alÄ±ÅŸÄ±r
     * destroyMethod: Uygulama kapanÄ±rken Ã§alÄ±ÅŸÄ±r
     */
    @Bean(name = "modelMapper", initMethod = "onInit", destroyMethod = "onDestroy")
    public ModelMapper modelMapperMethod() {
        return new ModelMapper();
    }

    /**
     * Bean oluÅŸturulduÄŸunda Ã§alÄ±ÅŸacak metod
     */
    public void onInit() {
        System.out.println("âœ… ModelMapper bean initialized.");
    }

    /**
     * Bean yok edilmeden Ã¶nce Ã§alÄ±ÅŸacak metod
     */
    public void onDestroy() {
        System.out.println("ğŸ§¹ ModelMapper bean destroyed.");
    }
}



## Spring Data Nedir ?
```sh 

```
---
Spring Data, Spring Frameworkâ€™Ã¼n bir parÃ§asÄ± olup, veritabanÄ± iÅŸlemlerini kolaylaÅŸtÄ±rmak ve veri eriÅŸim katmanÄ±nda tutarlÄ±lÄ±ÄŸÄ± saÄŸlamak iÃ§in tasarlanmÄ±ÅŸ bir modÃ¼ldÃ¼r. Spring Data, farklÄ± veri depolarÄ± ile (Ã¶rneÄŸin, iliÅŸkisel veritabanlarÄ±, NoSQL veritabanlarÄ±, anahtar-deÄŸer depolarÄ±, grafik veritabanlarÄ±) kolayca etkileÅŸim kurulmasÄ±nÄ± saÄŸlar ve bu veritabanlarÄ± ile veri iÅŸlemlerini standartlaÅŸtÄ±rÄ±r.

Spring Dataâ€™nÄ±n temel amacÄ±, veri eriÅŸim katmanÄ±nda tekrarlayan kodlarÄ± azaltmak ve veri iÅŸlemlerini daha kolay hale getirmektir. Spring Data, Ã¶zellikle CRUD (Create, Read, Update, Delete) iÅŸlemlerini daha az kod yazarak gerÃ§ekleÅŸtirmeye olanak tanÄ±r ve veri eriÅŸim katmanÄ±nÄ±n daha modÃ¼ler ve yÃ¶netilebilir hale gelmesini saÄŸlar.

### Spring Dataâ€™nÄ±n FaydalarÄ± ve AmacÄ±

1. **Tekrarlayan KodlarÄ± AzaltÄ±r**: VeritabanÄ± iÅŸlemleri iÃ§in her defasÄ±nda aynÄ± CRUD kodlarÄ±nÄ± yazmak yerine, Spring Data bu iÅŸlemleri otomatik olarak oluÅŸturur ve kod tekrarÄ±nÄ± en aza indirir.

2. **Ã‡eÅŸitli Veri DepolarÄ±yla Uyumlu**: Spring Data, iliÅŸkisel ve NoSQL veritabanlarÄ± ile Ã§alÄ±ÅŸabilen bir yapÄ±ya sahiptir. Bu, uygulamalarÄ±n Ã§ok farklÄ± veri depolarÄ±na kolayca entegre olmasÄ±nÄ± saÄŸlar.

3. **VeritabanÄ± Ä°ÅŸlemlerini BasitleÅŸtirir**: Spring Data, depo (repository) arayÃ¼zleri aracÄ±lÄ±ÄŸÄ±yla veri iÅŸlemlerini sadeleÅŸtirir. Veri iÅŸlemlerini daha okunabilir ve anlaÅŸÄ±lÄ±r hale getiren metotlarla veri depolarÄ±na eriÅŸim saÄŸlar.

4. **Dinamik Sorgular OluÅŸturur**: Spring Data, arayÃ¼z tanÄ±mlamalarÄ± aracÄ±lÄ±ÄŸÄ±yla belirli kurallara dayalÄ± olarak otomatik sorgular oluÅŸturur. Ã–rneÄŸin, metot adlarÄ±na gÃ¶re sorgular oluÅŸturulabilir (Query Creation by Method Name).

5. **Transparan Veri EriÅŸimi**: Spring Data, veri iÅŸlemleri sÄ±rasÄ±nda hangi veritabanÄ± teknolojisinin kullanÄ±ldÄ±ÄŸÄ±nÄ± kullanÄ±cÄ±dan gizler ve bu sayede, veri eriÅŸim iÅŸlemleri daha kolay ve standart hale gelir.

### Spring Data ModÃ¼lleri

Spring Data, farklÄ± veri tÃ¼rlerini ve veri yÃ¶netimi senaryolarÄ±nÄ± ele almak iÃ§in Ã§eÅŸitli alt modÃ¼ller iÃ§erir. Bu modÃ¼ller, farklÄ± veri depolarÄ± ile Ã§alÄ±ÅŸmayÄ± kolaylaÅŸtÄ±rÄ±r.

1. **Spring Data JPA**: Spring Dataâ€™nÄ±n en popÃ¼ler modÃ¼llerinden biridir. Java Persistence API (JPA) Ã¼zerinde Ã§alÄ±ÅŸan bir modÃ¼ldÃ¼r ve iliÅŸkisel veritabanlarÄ±nda ORM (Object-Relational Mapping) iÅŸlemlerini kolaylaÅŸtÄ±rÄ±r. Hibernate gibi JPA saÄŸlayÄ±cÄ±larÄ±yla entegre Ã§alÄ±ÅŸÄ±r.

2. **Spring Data MongoDB**: NoSQL veritabanÄ± olan MongoDB ile Ã§alÄ±ÅŸmayÄ± saÄŸlar. MongoDBâ€™nin Ã¶zelliklerine Ã¶zel olarak geliÅŸtirilmiÅŸ sÄ±nÄ±flar ve iÅŸlemler iÃ§erir.

3. **Spring Data Redis**: Redis anahtar-deÄŸer veri deposuyla entegre Ã§alÄ±ÅŸÄ±r. Redis, Ã¶zellikle hÄ±zlÄ± veri eriÅŸimi gereken durumlarda popÃ¼lerdir ve Spring Data Redis, Redis ile hÄ±zlÄ± ve kolay etkileÅŸimi saÄŸlar.

4. **Spring Data Cassandra**: BÃ¼yÃ¼k veri uygulamalarÄ± iÃ§in kullanÄ±lan Cassandra veritabanÄ±yla entegre Ã§alÄ±ÅŸÄ±r. Cassandra, yÃ¼ksek Ã¶lÃ§eklenebilirlik ve yÃ¼ksek eriÅŸilebilirlik sunan bir NoSQL veritabanÄ±dÄ±r.

5. **Spring Data Elasticsearch**: Elasticsearch arama ve analiz motoruyla Ã§alÄ±ÅŸmak iÃ§in geliÅŸtirilmiÅŸtir. Bu modÃ¼l, hÄ±zlÄ± arama ve analiz gereksinimleri olan uygulamalarda kullanÄ±lÄ±r.

6. **Spring Data JDBC**: JPA kullanmak istemeyen veya daha doÄŸrudan SQL iÅŸlemleri yapmak isteyenler iÃ§in basit bir JDBC tabanlÄ± veri eriÅŸim modÃ¼lÃ¼dÃ¼r.

7. **Spring Data R2DBC**: Reactive Programming (tepkisel programlama) modelini destekleyen bir SQL veritabanÄ± modÃ¼lÃ¼dÃ¼r. R2DBC, veri iÅŸlemlerinin asenkron olarak gerÃ§ekleÅŸtirilmesini saÄŸlar.

### Spring Data Repository (Depo) KavramÄ±

Spring Data, veri eriÅŸim iÅŸlemlerini Repository adÄ± verilen arayÃ¼zler Ã¼zerinden gerÃ§ekleÅŸtirir. Bu arayÃ¼zler, veri depolarÄ±yla etkileÅŸimi saÄŸlar ve CRUD iÅŸlemlerini otomatik hale getirir. Spring Data, depo arayÃ¼zleri Ã¼zerinden veri eriÅŸim iÅŸlemlerini yapÄ±landÄ±rmanÄ±zÄ± saÄŸlar ve karmaÅŸÄ±k veri iÅŸlemleri iÃ§in de ek iÅŸlevler sunar.

Spring Data Repositoryâ€™leri Ã¼Ã§ ana kategoriye ayrÄ±labilir:

1. **CrudRepository**: Temel CRUD iÅŸlemlerini destekleyen bir arayÃ¼zdÃ¼r. `save`, `findById`, `findAll`, `deleteById` gibi metotlarla veri iÅŸlemlerini saÄŸlar.

2. **JpaRepository**: CrudRepositoryâ€™den tÃ¼retilmiÅŸ ve ek JPA Ã¶zellikleri sunan bir arayÃ¼zdÃ¼r. SayfalandÄ±rma (pagination) ve sÄ±ralama (sorting) gibi ek Ã¶zellikler iÃ§erir.

3. **PagingAndSortingRepository**: Verilerin sayfalara bÃ¶lÃ¼nerek gÃ¶rÃ¼ntÃ¼lenmesi ve sÄ±ralanmasÄ± gibi iÅŸlemleri destekleyen bir arayÃ¼zdÃ¼r.

### Spring Data Repository MetotlarÄ±

Spring Data, Repository arayÃ¼zlerine Ã¶zel isimlendirme kurallarÄ± sayesinde sorgularÄ± dinamik olarak oluÅŸturabilir. Ã–rneÄŸin, `findByFirstName(String firstName)` metodu, `firstName` alanÄ±na gÃ¶re arama yapar. Metot adÄ±yla sorgu oluÅŸturma iÅŸlemi oldukÃ§a geniÅŸtir ve farklÄ± iÅŸlemleri destekler:

- `findBy` ile baÅŸlayan metotlar: Veriyi koÅŸula gÃ¶re arama yapar.
- `countBy` ile baÅŸlayan metotlar: Verinin sayÄ±sÄ±nÄ± hesaplar.
- `deleteBy` ile baÅŸlayan metotlar: Belirli bir koÅŸula gÃ¶re veriyi siler.

Ã–rneÄŸin, bir mÃ¼ÅŸteri deposu (CustomerRepository) iÃ§in ÅŸu metotlar kullanÄ±labilir:

```java
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    List<Customer> findByLastName(String lastName);
    Customer findByEmail(String email);
    List<Customer> findByFirstNameAndLastName(String firstName, String lastName);
}
```

Bu metotlar sayesinde SQL sorgusu yazmaya gerek kalmadan veri iÅŸlemleri yapÄ±labilir.

## Spring Data (deliveredQuery, named query, JPQL, native SQL)
```sh 

```
---

Bu dosyalardaki yapÄ±yÄ± kullanarak `deliveredQuery`, `named query`, `JPQL`, ve `native SQL` Ã¶rnekleri oluÅŸturabiliriz. Ä°lgili Ã¶rnekleri dosyalarÄ±nÄ±zdaki mevcut sÄ±nÄ±flar Ã¼zerinden oluÅŸturacaÄŸÄ±m.

### 1. Delivered Query
`Spring Data JPA` ile, metod isimlendirme kurallarÄ±na uyarak doÄŸrudan yÃ¶ntemler tanÄ±mlanabilir. Ã–rneÄŸin `IAddressRepository` arayÃ¼zÃ¼nde bir adresin ÅŸehre gÃ¶re aranmasÄ±nÄ± saÄŸlayan bir `delivered query` tanÄ±mlayalÄ±m.

```java
public interface IAddressRepository extends JpaRepository<AddressEntity, Long> {
    
    // Åehre gÃ¶re adresleri bulur
    List<AddressEntity> findByCity(String city);
}
```

Bu metod, otomatik olarak `city` alanÄ±na gÃ¶re bir sorgu oluÅŸturur.

### 2. Named Query
`@NamedQuery` ile tanÄ±mlanmÄ±ÅŸ bir JPQL sorgusunu `AddressEntity` sÄ±nÄ±fÄ±nda tanÄ±mlayabiliriz. Ã–rneÄŸin, bir `named query` kullanarak `city` ve `postalCode` alanlarÄ±na gÃ¶re arama yapalÄ±m.

`AddressEntity.java` dosyasÄ±na ekleyeceÄŸimiz `@NamedQuery` Ã¶rneÄŸi:

```java
@Entity
@NamedQuery(
    name = "AddressEntity.findByCityAndPostalCode",
    query = "SELECT a FROM AddressEntity a WHERE a.city = :city AND a.postalCode = :postalCode"
)
public class AddressEntity {
    // Mevcut alanlar ve diÄŸer kodlar
}
```

Bu named query'i kullanmak iÃ§in `IAddressRepository` arayÃ¼zÃ¼ne bir metod ekleyebiliriz:

```java
public interface IAddressRepository extends JpaRepository<AddressEntity, Long> {

    @Query(name = "AddressEntity.findByCityAndPostalCode")
    List<AddressEntity> findByCityAndPostalCode(@Param("city") String city, @Param("postalCode") String postalCode);
}
```

### 3. JPQL Query
`JPQL` (Java Persistence Query Language) ile `@Query` anotasyonu kullanarak belirli kriterlere gÃ¶re sorgular tanÄ±mlayabiliriz. Ã–rneÄŸin, tÃ¼m `city` alanÄ± `null` olmayan adresleri getirecek bir JPQL sorgusu:

```java
public interface IAddressRepository extends JpaRepository<AddressEntity, Long> {

    @Query("SELECT a FROM AddressEntity a WHERE a.city IS NOT NULL")
    List<AddressEntity> findAllWithNonNullCity();
}
```

Bu yÃ¶ntem, tÃ¼m `city` deÄŸeri dolu olan adresleri getirir.

### 4. Native SQL Query
`native SQL` kullanarak doÄŸrudan SQL sorgusu Ã§alÄ±ÅŸtÄ±rmak iÃ§in `@Query` anotasyonunu `nativeQuery` Ã¶zelliÄŸi ile kullanabiliriz. Ã–rneÄŸin, `city` alanÄ±na gÃ¶re adresleri getiren bir native SQL sorgusu:

```java
public interface IAddressRepository extends JpaRepository<AddressEntity, Long> {

    @Query(value = "SELECT * FROM address_entity WHERE city = :city", nativeQuery = true)
    List<AddressEntity> findByCityNative(@Param("city") String city);
}
```

Bu sorgu doÄŸrudan SQL kullanÄ±r ve `address_entity` tablosunda `city` deÄŸerine gÃ¶re filtreleme yapar.

Bu Ã¶rneklerde:
- `deliveredQuery` otomatik olarak `findBy` ile yapÄ±lÄ±r.
- `@NamedQuery` kullanarak sorgularÄ± doÄŸrudan sÄ±nÄ±fÄ±n Ã¼zerine tanÄ±mlayabiliriz.
- `JPQL` ile `@Query` anotasyonunda HQL benzeri sorgular yazabiliriz.
- `native SQL` ile direkt SQL komutlarÄ± Ã§alÄ±ÅŸtÄ±rabiliriz.

Her bir yÃ¶ntem, sorgu ihtiyaÃ§larÄ±nÄ±za gÃ¶re kullanabileceÄŸiniz esnek Ã§Ã¶zÃ¼mler saÄŸlar.


## Spring Boot (Delivered Query, Named Queries, JPQL ve Native SQL Nedir)
```sh 

```
---


### Delivered Query, Named Queries, JPQL ve Native SQL Nedir?

Bu kavramlar, Spring Data JPA ve JPA (Java Persistence API) Ã§erÃ§evesinde kullanÄ±lan Ã§eÅŸitli sorgulama yÃ¶ntemleridir. Her birinin belirli Ã¶zellikleri ve kullanÄ±m alanlarÄ± vardÄ±r. AÅŸaÄŸÄ±da, her birini ayrÄ±ntÄ±lÄ± olarak aÃ§Ä±klayarak, aralarÄ±ndaki farklarÄ± ortaya koyacaÄŸÄ±z.

---

### 1. Delivered Query (TÃ¼retilmiÅŸ Sorgular)

**Delivered Query** veya **TÃ¼retilmiÅŸ Sorgular**, Spring Data JPAâ€™nÄ±n saÄŸladÄ±ÄŸÄ± bir Ã¶zelliktir. Spring Data, repository arayÃ¼zÃ¼nde tanÄ±mlanan metod isimlerinden otomatik olarak sorgu oluÅŸturur. Bu Ã¶zellik, SQL veya JPQL sorgusu yazma ihtiyacÄ±nÄ± ortadan kaldÄ±rÄ±r ve metod isimlendirme kurallarÄ±na gÃ¶re sorgularÄ± otomatik olarak tÃ¼retir.

#### Delivered Query NasÄ±l Ã‡alÄ±ÅŸÄ±r?

Spring Data JPA, repository metod adlarÄ±nÄ± analiz ederek, metod adÄ±ndaki anahtar kelimeleri kullanarak bir sorgu oluÅŸturur. Ã–rneÄŸin, metod adÄ± `findByCity` ise, Spring Data, `city` alanÄ±na gÃ¶re bir sorgu tÃ¼retir.

#### Ã–rnekler

```java
public interface AddressRepository extends JpaRepository<AddressEntity, Long> {
    List<AddressEntity> findByCity(String city);
}
```

Bu metod adÄ±, Spring Data tarafÄ±ndan ÅŸu SQL sorgusuna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r:

```sql
SELECT * FROM address_entity WHERE city = ?;
```

Spring Data ayrÄ±ca `And`, `Or`, `GreaterThan`, `LessThan` gibi Ã§eÅŸitli anahtar kelimelerle daha karmaÅŸÄ±k sorgular tÃ¼retebilir:

```java
List<AddressEntity> findByCityAndZipCode(String city, String zipCode);
```

Bu metod, `city` ve `zipCode` alanlarÄ±na gÃ¶re bir sorgu oluÅŸturur ve ÅŸu sorguya eÅŸdeÄŸerdir:

```sql
SELECT * FROM address_entity WHERE city = ? AND zip_code = ?;
```

#### AvantajlarÄ±
- **Kolay KullanÄ±m**: Metod isimlendirmesi ile sorgu oluÅŸturmayÄ± saÄŸlar.
- **BakÄ±mÄ± Kolay**: Kodlar anlaÅŸÄ±lÄ±r ve bakÄ±mÄ± kolaydÄ±r.
- **Otomatik Optimizasyon**: Spring Data, tÃ¼retilen sorgularÄ± optimize eder.

#### DezavantajlarÄ±
- **KarmaÅŸÄ±k Sorgular Ä°Ã§in KÄ±sÄ±tlÄ±**: KarmaÅŸÄ±k sorgular tÃ¼retmek zor olabilir.
- **Performans KontrolÃ¼**: Otomatik olarak tÃ¼retilen sorgularÄ±n performansÄ±nÄ± kontrol etmek zor olabilir.

---

### 2. Named Queries

**Named Query (AdlandÄ±rÄ±lmÄ±ÅŸ Sorgu)**, JPA'nÄ±n saÄŸladÄ±ÄŸÄ±, bir entity sÄ±nÄ±fÄ±na baÄŸlÄ± olarak tanÄ±mlanan Ã¶nceden tanÄ±mlÄ± SQL veya JPQL sorgularÄ±dÄ±r. Named Queries, `@NamedQuery` anotasyonu kullanÄ±larak entity sÄ±nÄ±fÄ± Ã¼zerinde tanÄ±mlanÄ±r ve sorgu Ã§alÄ±ÅŸtÄ±rÄ±lmak istendiÄŸinde bu adÄ± kullanarak Ã§aÄŸrÄ±lÄ±r.

#### Named Query TanÄ±mlama

`@NamedQuery` anotasyonu, entity sÄ±nÄ±fÄ± Ã¼zerinde sorguyu tanÄ±mlar. Ã–rneÄŸin:

```java
@Entity
@NamedQuery(
    name = "AddressEntity.findByCity",
    query = "SELECT a FROM AddressEntity a WHERE a.city = :city"
)
public class AddressEntity {
    // Alanlar ve metodlar...
}
```

Bu Named Query, `AddressEntity` sÄ±nÄ±fÄ±na baÄŸlÄ±dÄ±r ve `city` parametresine gÃ¶re sorgu yapar.

#### Named Query KullanÄ±mÄ±

Named Query'yi repository iÃ§inde `@Query` anotasyonunu kullanarak Ã§aÄŸÄ±rabilirsiniz:

```java
public interface AddressRepository extends JpaRepository<AddressEntity, Long> {
    
    @Query(name = "AddressEntity.findByCity")
    List<AddressEntity> findAddressesByCity(@Param("city") String city);
}
```

#### AvantajlarÄ±
- **Kod TekrarÄ±nÄ± AzaltÄ±r**: AynÄ± sorguyu birden fazla yerde kullanma olanaÄŸÄ± saÄŸlar.
- **Daha Okunabilir Kodlar**: KarmaÅŸÄ±k sorgular iÃ§in daha anlaÅŸÄ±lÄ±r kod saÄŸlar.
- **Ã–nceden TanÄ±mlanmÄ±ÅŸ Sorgular**: Sorgular Ã¶nceden tanÄ±mlandÄ±ÄŸÄ± iÃ§in yÃ¶netimi kolaydÄ±r.

#### DezavantajlarÄ±
- **Performans YÃ¶netimi**: TÃ¼m Named Queriesâ€™in bellekte saklanmasÄ±, performans etkisine neden olabilir.
- **DeÄŸiÅŸtirilebilirlik**: Sorguyu deÄŸiÅŸtirmek istediÄŸinizde, entity sÄ±nÄ±fÄ±nda deÄŸiÅŸiklik yapmanÄ±z gerekebilir.

---

### 3. JPQL (Java Persistence Query Language)

**JPQL (Java Persistence Query Language)**, JPA'nÄ±n saÄŸladÄ±ÄŸÄ±, SQL'e benzeyen ama tamamen entity sÄ±nÄ±flarÄ±na yÃ¶nelik bir sorgulama dilidir. SQLâ€™den farklÄ± olarak JPQL, doÄŸrudan veri tabanÄ± tablolarÄ±na deÄŸil, Java sÄ±nÄ±flarÄ±na ve alanlarÄ±na odaklanÄ±r.

#### JPQL KullanÄ±mÄ±

JPQL, repository metodlarÄ± Ã¼zerinde `@Query` anotasyonu ile tanÄ±mlanabilir. JPQL'de entity sÄ±nÄ±fÄ± ve alan adlarÄ± kullanÄ±lÄ±r:

```java
@Query("SELECT a FROM AddressEntity a WHERE a.city = :city")
List<AddressEntity> findByCity(@Param("city") String city);
```

Bu JPQL sorgusu, `city` alanÄ±na gÃ¶re `AddressEntity` nesnelerini dÃ¶ndÃ¼rÃ¼r.

#### JPQL OperatÃ¶rleri
JPQL, SQL gibi `SELECT`, `WHERE`, `JOIN`, `GROUP BY` ve `ORDER BY` gibi komutlarÄ± destekler. JPQL ile ayrÄ±ca `IN`, `LIKE`, `BETWEEN`, `IS NULL` gibi operatÃ¶rler de kullanÄ±labilir.

#### AvantajlarÄ±
- **Entity OdaklÄ±**: JPQL, entity sÄ±nÄ±flarÄ±na ve alanlara odaklandÄ±ÄŸÄ±ndan nesneye yÃ¶nelik bir yaklaÅŸÄ±m sunar.
- **Platform BaÄŸÄ±msÄ±z**: Veri tabanÄ± baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r ve her veri tabanÄ±na uyum saÄŸlar.

#### DezavantajlarÄ±
- **SQLâ€™den Daha Az Esnek**: JPQL, SQL kadar esnek deÄŸildir ve bazÄ± veri tabanÄ± Ã¶zel fonksiyonlarÄ±nÄ± desteklemeyebilir.
- **Performans SorunlarÄ±**: KarmaÅŸÄ±k JPQL sorgularÄ± performans sorunlarÄ±na neden olabilir.

---

### 4. Native SQL

**Native SQL**, JPA'da doÄŸrudan SQL sorgularÄ± yazma yÃ¶ntemidir. Native SQL sorgularÄ± veri tabanÄ±na Ã¶zgÃ¼dÃ¼r ve SQL'in tÃ¼m Ã¶zelliklerinden faydalanabilir. Native sorgular, `@Query` anotasyonu iÃ§inde `nativeQuery = true` parametresi ile kullanÄ±lÄ±r.

#### Native SQL KullanÄ±mÄ±

AÅŸaÄŸÄ±da, doÄŸrudan SQL sorgusu kullanan bir Ã¶rnek verilmiÅŸtir:

```java
@Query(value = "SELECT * FROM address_entity WHERE city = ?1", nativeQuery = true)
List<AddressEntity> findByCityNative(String city);
```

Bu sorgu, doÄŸrudan `address_entity` tablosundan `city` alanÄ±na gÃ¶re veri Ã§eker.

#### AvantajlarÄ±
- **Tam SQL DesteÄŸi**: Veri tabanÄ± Ã¶zel fonksiyonlarÄ± ve Ã¶zellikleri kullanÄ±labilir.
- **Performans**: Ã–zelleÅŸtirilmiÅŸ ve optimize edilmiÅŸ sorgularla yÃ¼ksek performans saÄŸlar.
- **SQLâ€™in GÃ¼cÃ¼**: SQL'in tÃ¼m Ã¶zelliklerinden faydalanarak daha karmaÅŸÄ±k iÅŸlemler yapÄ±labilir.

#### DezavantajlarÄ±
- **Platform BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**: Native SQL sorgularÄ±, veri tabanÄ±na baÄŸÄ±mlÄ±dÄ±r ve taÅŸÄ±nabilirlik sorunu oluÅŸturabilir.
- **Kod AnlaÅŸÄ±lÄ±r Olmayabilir**: SQL kodu, Java kodu ile iÃ§ iÃ§e geÃ§tiÄŸinde, kodun okunabilirliÄŸi azalabilir.

---

### Delivered Query, Named Query, JPQL ve Native SQL ArasÄ±ndaki Farklar

| Ã–zellik           | Delivered Query                       | Named Query                          | JPQL                                  | Native SQL                           |
|-------------------|--------------------------------------|--------------------------------------|---------------------------------------|--------------------------------------|
| **TanÄ±m**         | Spring Data tarafÄ±ndan metod isimlerine gÃ¶re tÃ¼retilen sorgular | Entity sÄ±nÄ±fÄ±nda Ã¶nceden tanÄ±mlanan sorgular | Entity sÄ±nÄ±flarÄ±na yÃ¶nelik SQL benzeri sorgu dili | DoÄŸrudan veri tabanÄ± SQL sorgusu |
| **KullanÄ±m**      | Repository metod adÄ± Ã¼zerinden       | `@NamedQuery` ile entity sÄ±nÄ±fÄ±nda   | `@Query` anotasyonu ile repository'de | `@Query` ile `nativeQuery=true`      |
| **Veri TabanÄ± BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±** | BaÄŸÄ±msÄ±z                             | BaÄŸÄ±msÄ±z                             | BaÄŸÄ±msÄ±z                              | Veri tabanÄ± baÄŸÄ±mlÄ±                  |
| **Esneklik**      | DÃ¼ÅŸÃ¼k                                | Orta                                 | YÃ¼ksek                                | Ã‡ok yÃ¼ksek                           |
| **Kod AnlaÅŸÄ±lÄ±r mÄ±?** | Evet                              | Evet                                 | Orta                                  | HayÄ±r                                |
| **Performans**    | Orta                                 | Orta                                 | Orta                                  | YÃ¼ksek                               |
| **Uygulama AlanÄ±**| Basit ve hÄ±zlÄ± sorgular              | Tekrar eden karmaÅŸÄ±k sorgular        | Orta seviye sorgular                  | KarmaÅŸÄ±k ve Ã¶zelleÅŸtirilmiÅŸ sorgular |

---

### Ã–zet

- **Delivered Query**: Spring Data metod adlarÄ±na gÃ¶re otomatik tÃ¼retilen sorgular, basit ve hÄ±zlÄ± iÅŸlemler iÃ§in idealdir.
- **Named Query**: Entity sÄ±nÄ±flarÄ±nda Ã¶nceden tanÄ±mlanan, tekrarlanan sorgular iÃ§in kullanÄ±lan yapÄ±lar.
- **JPQL**: Java sÄ±nÄ±flarÄ±na yÃ¶nelik SQL benzeri bir sorgu dilidir. SQL'den farkÄ±, tablo isimleri yerine Java entity sÄ±nÄ±flarÄ±nÄ±n kullanÄ±lmasÄ±dÄ±r. Platform baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r ve SQL gibi `SELECT`, `WHERE`, `JOIN` gibi ifadeleri destekler. Daha nesneye yÃ¶nelik bir sorgulama saÄŸladÄ±ÄŸÄ±ndan, JPAâ€™nÄ±n sunduÄŸu standart Ã¶zellikler Ã§erÃ§evesinde kompleks iÅŸlemler yapÄ±labilir.
- **Native SQL**: DoÄŸrudan SQL sorgularÄ±nÄ± kullanmamÄ±za olanak tanÄ±r. Bu sayede SQLâ€™in tÃ¼m Ã¶zelliklerinden faydalanabiliriz. Native SQL, veri tabanÄ±na Ã¶zgÃ¼ sorgular yazmayÄ± mÃ¼mkÃ¼n kÄ±lar, ancak platform baÄŸÄ±mlÄ±lÄ±ÄŸÄ± oluÅŸturabilir. KarmaÅŸÄ±k ve optimize edilmesi gereken iÅŸlemler iÃ§in tercih edilir.

---

### Hangi Durumda Hangisini KullanmalÄ±?

1. **Basit Sorgular Ä°Ã§in**: `Delivered Query` tercih edilmelidir. Metod isimlerine gÃ¶re tÃ¼retilen bu sorgular, hÄ±zlÄ±ca basit iÅŸlemler yapmak iÃ§in idealdir.

2. **Tekrarlayan veya Statik Sorgular Ä°Ã§in**: `Named Query` en uygun seÃ§enektir. Sorguyu bir kere tanÄ±mlayÄ±p farklÄ± yerlerde kullanmak iÃ§in idealdir.

3. **Orta Derecede KarmaÅŸÄ±k Sorgular Ä°Ã§in**: `JPQL` daha iyi bir seÃ§imdir. Entity odaklÄ± ve veri tabanÄ± baÄŸÄ±msÄ±z Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in taÅŸÄ±nabilirliÄŸi yÃ¼ksektir.

4. **KarmaÅŸÄ±k veya Optimize EdilmiÅŸ Sorgular Ä°Ã§in**: `Native SQL` en iyi seÃ§enektir. Veri tabanÄ± Ã¶zelliklerinden tam anlamÄ±yla faydalanmak gerektiÄŸinde ve yÃ¼ksek performans gereken durumlarda native SQL tercih edilmelidir.

---

### Ã–rnek Senaryo UygulamalarÄ±

AÅŸaÄŸÄ±da, her bir sorgulama yÃ¶ntemi iÃ§in Ã¶rnek bir senaryo yer almaktadÄ±r:

#### Delivered Query Ã–rneÄŸi

Bir kullanÄ±cÄ± adÄ±yla (username) kullanÄ±cÄ±larÄ± listelemek iÃ§in basit bir sorguya ihtiyaÃ§ duyduÄŸunuzu dÃ¼ÅŸÃ¼nÃ¼n. Bu durumda, metod ismine gÃ¶re delivered query kullanabilirsiniz:

```java
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByUsername(String username);
}
```

#### Named Query Ã–rneÄŸi

Bir mÃ¼ÅŸteri sÄ±nÄ±fÄ±nda (`CustomerEntity`) Ã§ok sÄ±k kullanÄ±lan bir sorgu olduÄŸunu ve mÃ¼ÅŸteri ÅŸehirlerine gÃ¶re arama yapÄ±ldÄ±ÄŸÄ±nÄ± varsayalÄ±m. Bu sorguyu `CustomerEntity` iÃ§inde bir Named Query olarak tanÄ±mlayabiliriz:

```java
@Entity
@NamedQuery(
    name = "CustomerEntity.findByCity",
    query = "SELECT c FROM CustomerEntity c WHERE c.city = :city"
)
public class CustomerEntity {
    // Alanlar...
}
```

Daha sonra `CustomerRepository` iÃ§inde bu sorguyu ÅŸu ÅŸekilde kullanabiliriz:

```java
public interface CustomerRepository extends JpaRepository<CustomerEntity, Long> {
    @Query(name = "CustomerEntity.findByCity")
    List<CustomerEntity> findByCity(@Param("city") String city);
}
```

#### JPQL Ã–rneÄŸi

Bir `Product` entityâ€™sinde fiyat aralÄ±ÄŸÄ±na gÃ¶re Ã¼rÃ¼nleri listelemek istediÄŸinizi dÃ¼ÅŸÃ¼nelim. Bu durumda JPQL kullanarak sorguyu repositoryâ€™de yazabilirsiniz:

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Query("SELECT p FROM Product p WHERE p.price BETWEEN :minPrice AND :maxPrice")
    List<Product> findProductsInPriceRange(@Param("minPrice") double minPrice, @Param("maxPrice") double maxPrice);
}
```

Bu sorgu, belirtilen fiyat aralÄ±ÄŸÄ±ndaki Ã¼rÃ¼nleri listeleyecektir.

#### Native SQL Ã–rneÄŸi

DoÄŸrudan SQL kullanarak optimize edilmiÅŸ bir sorgu yazmanÄ±z gerektiÄŸinde Native SQL tercih edilir. Ã–rneÄŸin, bir `Employee` tablosunda en yÃ¼ksek maaÅŸÄ± alan Ã§alÄ±ÅŸanÄ± listelemek iÃ§in ÅŸu ÅŸekilde bir Native SQL sorgusu kullanÄ±labilir:

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    @Query(value = "SELECT * FROM employee WHERE salary = (SELECT MAX(salary) FROM employee)", nativeQuery = true)
    List<Employee> findTopEarningEmployees();
}
```

---

### SonuÃ§ ve Ã–neriler

Her bir sorgu tÃ¼rÃ¼ farklÄ± senaryolarda kullanÄ±ma uygundur. UygulamanÄ±zÄ±n ihtiyaÃ§larÄ±na gÃ¶re doÄŸru sorgu tÃ¼rÃ¼nÃ¼ seÃ§mek performans ve sÃ¼rdÃ¼rÃ¼lebilirlik aÃ§Ä±sÄ±ndan bÃ¼yÃ¼k Ã¶nem taÅŸÄ±r:

- **Basit ve HÄ±zlÄ± Sorgular Ä°Ã§in**: `Delivered Query` tercih edin.
- **Tekrar Eden Sorgular Ä°Ã§in**: `Named Query` ile Ã¶nceden tanÄ±mlanan sorgularÄ± kullanÄ±n.
- **Platform BaÄŸÄ±msÄ±z, Nesneye YÃ¶nelik Sorgular Ä°Ã§in**: `JPQL` kullanarak veri tabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ±nÄ± koruyun.
- **Optimize EdilmiÅŸ ve KarmaÅŸÄ±k Sorgular Ä°Ã§in**: `Native SQL` kullanarak veri tabanÄ±nÄ±n gÃ¼cÃ¼nden tam olarak faydalanÄ±n.

Bu dÃ¶rt sorgu tÃ¼rÃ¼ sayesinde Spring Data JPA, her tÃ¼rlÃ¼ veri tabanÄ± sorgulama ihtiyacÄ±na esnek ve gÃ¼Ã§lÃ¼ Ã§Ã¶zÃ¼mler sunar.


## Spring Boot (Custom Queries (Ã–zelleÅŸtirilmiÅŸ Sorgular))
```sh 

```
---

### Custom Queries (Ã–zelleÅŸtirilmiÅŸ Sorgular)

Spring Data, bazÄ± karmaÅŸÄ±k sorgular iÃ§in Ã¶zel sorgular tanÄ±mlama imkanÄ± da sunar. Bunun iÃ§in iki ana yÃ¶ntem vardÄ±r:

1. **@Query Anotasyonu**: Ã–zel sorgular tanÄ±mlamak iÃ§in kullanÄ±lan anotasyondur. Native SQL veya JPQL (Java Persistence Query Language) ile sorgular yazÄ±labilir.

   ```java
   @Query("SELECT c FROM Customer c WHERE c.firstName = ?1 AND c.lastName = ?2")
   List<Customer> findByFirstAndLastName(String firstName, String lastName);
   ```

2. **Named Queries**: Entity sÄ±nÄ±flarÄ±nda tanÄ±mlanan, sabit isimli sorgulardÄ±r. Bu sorgular, genellikle Entity sÄ±nÄ±fÄ±nÄ±n baÅŸÄ±nda tanÄ±mlanÄ±r ve isimlerine gÃ¶re Ã§aÄŸrÄ±labilir.


Spring Boot ve JPA ile Ã§alÄ±ÅŸÄ±rken veritabanÄ±na veri sorgulamak veya veri Ã¼zerinde iÅŸlemler gerÃ§ekleÅŸtirmek iÃ§in iki ana sorgu tÃ¼rÃ¼ kullanÄ±lÄ±r: **Native SQL** ve **JPQL (Java Persistence Query Language)**. Bu iki sorgu tÃ¼rÃ¼, JPA ile veri Ã§ekme veya gÃ¼ncelleme iÅŸlemlerinde esneklik saÄŸlar, ancak kullanÄ±m alanlarÄ± ve amaÃ§larÄ± farklÄ±dÄ±r. AÅŸaÄŸÄ±da her iki yÃ¶ntemin ayrÄ±ntÄ±lÄ± bir aÃ§Ä±klamasÄ± bulunmaktadÄ±r.

### 1. JPQL (Java Persistence Query Language)

JPQL, JPA ile birlikte kullanÄ±lan, nesne odaklÄ± bir sorgulama dilidir. JPQL, doÄŸrudan SQL sorgularÄ±na dayanmaz, bunun yerine **entity nesneleri Ã¼zerinden Ã§alÄ±ÅŸÄ±r**. Bu, veri tabanÄ±ndaki tablolarla deÄŸil, JPA entity sÄ±nÄ±flarÄ±yla etkileÅŸim kurar. JPQL, entity nesneleri ve onlarÄ±n iliÅŸkileri ile nesne yÃ¶nelimli veri Ã§ekme iÅŸlemleri iÃ§in tasarlanmÄ±ÅŸtÄ±r.

#### JPQLâ€™in Ã–zellikleri

- **Nesne OdaklÄ±dÄ±r**: JPQL sorgularÄ±, veritabanÄ± tablolarÄ± yerine Java sÄ±nÄ±flarÄ±na gÃ¶re yazÄ±lÄ±r. Bu nedenle SQLâ€™den farklÄ±dÄ±r; veri tabanÄ±ndaki fiziksel tablo adlarÄ± yerine Java sÄ±nÄ±f adlarÄ± ve alan adlarÄ± kullanÄ±lÄ±r.
- **VeritabanÄ± BaÄŸÄ±msÄ±zdÄ±r**: JPQL sorgularÄ±, JPA tarafÄ±ndan desteklenen herhangi bir veritabanÄ±nda Ã§alÄ±ÅŸacak ÅŸekilde soyutlanmÄ±ÅŸtÄ±r. JPQL, veritabanÄ± baÄŸÄ±msÄ±z bir yapÄ± sunduÄŸundan, farklÄ± veritabanlarÄ± arasÄ±nda geÃ§iÅŸ yaparken kodda deÄŸiÅŸiklik yapma gereksinimi azaltÄ±r.
- **Kolay ve GÃ¼Ã§lÃ¼**: JPQL, SQLâ€™e benzer bir sÃ¶z dizimine sahiptir, ancak nesneye yÃ¶nelik olarak optimize edilmiÅŸtir. SQL sorgularÄ±na gÃ¶re daha sade ve anlaÅŸÄ±lÄ±rdÄ±r, Ã¶zellikle karmaÅŸÄ±k veri Ã§ekme iÅŸlemlerinde iliÅŸki yÃ¶netimini daha kolay hale getirir.

#### JPQL KullanÄ±mÄ±

JPQL sorgularÄ± **@Query** anotasyonu ile yazÄ±lÄ±r veya bir `EntityManager` Ã¼zerinden Ã§alÄ±ÅŸtÄ±rÄ±labilir. JPQL'de temel olarak `SELECT`, `UPDATE`, `DELETE` ve `INSERT` komutlarÄ± bulunur.

##### Ã–rnek 1: JPQL ile Veri Ã‡ekme

VarsayalÄ±m bir **User** entity sÄ±nÄ±fÄ±mÄ±z var ve bu entity Ã¼zerinden kullanÄ±cÄ±larÄ± yaÅŸlarÄ±na gÃ¶re Ã§ekmek istiyoruz.

```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    private int age;
    // Getter ve Setter'lar
}
```

JPQL sorgusu ile kullanÄ±cÄ±larÄ± yaÅŸlarÄ±na gÃ¶re Ã§ekmek:

```java
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findUsersOlderThan(@Param("age") int age);
```

Burada **User** entityâ€™si ve **age** alanÄ± doÄŸrudan kullanÄ±lmÄ±ÅŸtÄ±r. JPQL sorgusunda tablo adÄ± veya sÃ¼tun adlarÄ± yerine entity sÄ±nÄ±fÄ±nÄ±n adÄ± ve Ã¶zellikleri kullanÄ±lÄ±r.

##### Ã–rnek 2: JPQL ile GÃ¼ncelleme

JPQL aynÄ± zamanda gÃ¼ncelleme iÅŸlemleri iÃ§in de kullanÄ±labilir.

```java
@Modifying
@Query("UPDATE User u SET u.age = :newAge WHERE u.id = :id")
int updateUserAge(@Param("id") Long id, @Param("newAge") int newAge);
```

Bu Ã¶rnekte, belirli bir kullanÄ±cÄ± IDâ€™sine sahip olan kaydÄ±n yaÅŸÄ±nÄ± gÃ¼ncellemekteyiz.

#### JPQLâ€™in AvantajlarÄ±

- **VeritabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ±**: JPQL sorgularÄ±, herhangi bir SQL varyantÄ±na baÄŸlÄ± kalmadan Ã§alÄ±ÅŸabilir.
- **Nesne odaklÄ±lÄ±k**: VeritabanÄ± tablolarÄ±na deÄŸil, entity nesnelerine dayanÄ±r.
- **Sade yapÄ±**: JPQL, entity iliÅŸkilerini daha sade ve anlaÅŸÄ±lÄ±r bir ÅŸekilde yÃ¶netir, bu da daha temiz kod saÄŸlar.

#### JPQLâ€™in DezavantajlarÄ±

- **KarmaÅŸÄ±k sorgularda sÄ±nÄ±rlamalar**: JPQL, bazÄ± durumlarda Ã§ok karmaÅŸÄ±k ve Ã¶zel veritabanÄ± iÅŸlemleri iÃ§in yeterli olmayabilir.
- **Performans sÄ±nÄ±rlamalarÄ±**: BazÄ± Ã¶zel performans gereksinimleri iÃ§in JPQL yeterli olmayabilir, Ã§Ã¼nkÃ¼ veritabanÄ±na Ã¶zgÃ¼ optimizasyonlardan yoksundur.

---

### 2. Native SQL

**Native SQL** sorgularÄ±, doÄŸrudan SQL sÃ¶z dizimini kullanarak yazÄ±lÄ±r. Bu sorgular, JPA'nÄ±n soyutlama katmanÄ±ndan geÃ§mez, doÄŸrudan veritabanÄ±na gÃ¶nderilir. Native SQL, veritabanÄ±na Ã¶zgÃ¼ komutlarÄ± veya optimizasyonlarÄ± kullanmanÄ±za olanak tanÄ±r, bu da karmaÅŸÄ±k iÅŸlemlerde performans avantajÄ± saÄŸlar.

#### Native SQLâ€™in Ã–zellikleri

- **VeritabanÄ± OdaklÄ±dÄ±r**: SQL sorgularÄ± doÄŸrudan veritabanÄ± tablolarÄ± Ã¼zerinde Ã§alÄ±ÅŸÄ±r, bu da karmaÅŸÄ±k iÅŸlemler veya veritabanÄ±na Ã¶zel komutlar gerektiÄŸinde daha etkilidir.
- **Performans AvantajÄ± SaÄŸlar**: Ã–zellikle bÃ¼yÃ¼k veri setleri Ã¼zerinde, veritabanÄ±na Ã¶zgÃ¼ optimizasyonlardan yararlanarak daha hÄ±zlÄ± sonuÃ§lar elde edilebilir.
- **SQL SÃ¶z Dizimi KullanÄ±lÄ±r**: JPQLâ€™in aksine, Native SQL sorgularÄ± doÄŸrudan SQL komutlarÄ± ile yazÄ±lÄ±r, bu da SQL bilen geliÅŸtiriciler iÃ§in daha tanÄ±dÄ±k olabilir.

#### Native SQL KullanÄ±mÄ±

**@Query** anotasyonunun iÃ§ine **nativeQuery = true** parametresi eklenerek Native SQL sorgusu tanÄ±mlanabilir.

##### Ã–rnek 1: Native SQL ile Veri Ã‡ekme

Yine **User** entityâ€™sini ele alalÄ±m ve kullanÄ±cÄ±larÄ± yaÅŸlarÄ±na gÃ¶re Ã§ekmek iÃ§in Native SQL sorgusu yazalÄ±m:

```java
@Query(value = "SELECT * FROM users WHERE age > :age", nativeQuery = true)
List<User> findUsersOlderThan(@Param("age") int age);
```

Burada doÄŸrudan **users** tablosu Ã¼zerinden SQL komutu ile iÅŸlem yapÄ±lmaktadÄ±r. VeritabanÄ± tablosu adÄ± ve sÃ¼tun adlarÄ± doÄŸrudan SQL sÃ¶z dizimi ile belirtilmiÅŸtir.

##### Ã–rnek 2: Native SQL ile GÃ¼ncelleme

Native SQL ile bir gÃ¼ncelleme iÅŸlemi yapalÄ±m:

```java
@Modifying
@Query(value = "UPDATE users SET age = :newAge WHERE id = :id", nativeQuery = true)
int updateUserAge(@Param("id") Long id, @Param("newAge") int newAge);
```

Bu sorguda, doÄŸrudan veritabanÄ± tablosu ve sÃ¼tun adlarÄ± kullanÄ±larak SQL sorgusu Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r.

#### Native SQLâ€™in AvantajlarÄ±

- **VeritabanÄ±na Ã–zgÃ¼ Ä°ÅŸlemler**: Native SQL ile, JPQLâ€™in sÄ±nÄ±rlarÄ±nÄ±n Ã¶tesinde karmaÅŸÄ±k sorgular veya veritabanÄ±na Ã¶zel iÅŸlemler gerÃ§ekleÅŸtirebilirsiniz.
- **Performans Optimizasyonu**: VeritabanÄ±na Ã¶zgÃ¼ optimizasyonlarÄ± kullanarak daha hÄ±zlÄ± sorgular oluÅŸturabilirsiniz.
- **Daha Fazla Esneklik**: Native SQL, JPQL'in sÄ±nÄ±rlamalarÄ± olan karmaÅŸÄ±k sorgularÄ±n Ã¼stesinden gelir ve daha esnek bir yapÄ± sunar.

#### Native SQLâ€™in DezavantajlarÄ±

- **VeritabanÄ± BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**: Native SQL sorgularÄ±, belirli bir veritabanÄ±na Ã¶zgÃ¼ olduÄŸunda, farklÄ± bir veritabanÄ±na geÃ§ildiÄŸinde Ã§alÄ±ÅŸmayabilir.
- **Kod KarmaÅŸÄ±klÄ±ÄŸÄ±**: SQL sorgularÄ±nÄ± doÄŸrudan kullanmak, JPQLâ€™e gÃ¶re kodu daha karmaÅŸÄ±k hale getirebilir.
- **Nesne OdaklÄ± DeÄŸil**: Native SQL doÄŸrudan tablo adlarÄ± ve sÃ¼tunlarla Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in nesne odaklÄ± mimari ile tamamen uyumlu olmayabilir.

---

### JPQL ve Native SQL ArasÄ±ndaki Farklar

| Ã–zellik                  | JPQL                                  | Native SQL                             |
|--------------------------|---------------------------------------|----------------------------------------|
| SÃ¶z Dizimi               | Nesne odaklÄ±, entity sÄ±nÄ±flarÄ±na gÃ¶re | VeritabanÄ± odaklÄ±, tablo ve sÃ¼tun isimlerine gÃ¶re |
| VeritabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±  | Evet                                  | HayÄ±r                                  |
| Performans               | Orta                                  | YÃ¼ksek (veritabanÄ±na Ã¶zel optimizasyon)|
| KarmaÅŸÄ±k Sorgu DesteÄŸi   | SÄ±nÄ±rlÄ±                               | GeniÅŸ                                  |
| KullanÄ±m KolaylÄ±ÄŸÄ±       | Daha kolay ve anlaÅŸÄ±lÄ±r               | SQL bilgisi gerektirir                 |

### Hangi Durumda Hangisini KullanmalÄ±yÄ±z?

- **Nesne OdaklÄ± ve Basit Sorgular**: JPQL tercih edilmelidir. JPQL, nesne odaklÄ± bir yapÄ±ya sahip olduÄŸundan daha temiz ve anlaÅŸÄ±lÄ±r kod saÄŸlar.
- **KarmaÅŸÄ±k veya Performans Gerektiren Sorgular**: Native SQL tercih edilebilir. Native SQL, doÄŸrudan SQL sorgularÄ±nÄ± kullanmanÄ±za izin verir, bu nedenle karmaÅŸÄ±k iÅŸlemler iÃ§in daha esnektir.

JPQL ve Native SQL, Spring Boot ve JPA ile Ã§alÄ±ÅŸÄ±rken veritabanÄ± iÅŸlemlerini optimize etmek iÃ§in kullanabileceÄŸiniz gÃ¼Ã§lÃ¼ araÃ§lardÄ±r. Tercih ettiÄŸiniz yÃ¶ntem, projenizin ihtiyaÃ§larÄ±na ve veritabanÄ± yapÄ±nÄ±za baÄŸlÄ± olarak deÄŸiÅŸiklik gÃ¶sterebilir.

## Spring Boot ( Named Queries )
```sh 

```
---

Spring Boot ve JPA ile veri iÅŸlemleri gerÃ§ekleÅŸtirirken, sorgularÄ± yÃ¶netmek iÃ§in **Named Queries**, **Native SQL**, ve **JPQL (Java Persistence Query Language)** gibi Ã§eÅŸitli seÃ§enekler mevcuttur. Her biri farklÄ± ihtiyaÃ§lara gÃ¶re kullanÄ±lÄ±r ve avantajlar ile dezavantajlar sunar. Bu Ã¼Ã§ yÃ¶ntemin arasÄ±ndaki farklarÄ± ve kullanÄ±m alanlarÄ±nÄ± ayrÄ±ntÄ±lÄ± olarak aÃ§Ä±klayacaÄŸÄ±m.

### Named Queries (AdlandÄ±rÄ±lmÄ±ÅŸ Sorgular)

Named Queries, JPA ile birlikte tanÄ±mlanan ve belirli bir adÄ± olan, tekrar kullanÄ±labilir sorgulardÄ±r. Sorgular, genellikle entity sÄ±nÄ±flarÄ± Ã¼zerinde **@NamedQuery** veya **@NamedNativeQuery** anotasyonlarÄ± ile tanÄ±mlanÄ±r. Bu sayede, aynÄ± sorgu birden fazla yerde kullanÄ±lmasÄ± gerektiÄŸinde kod tekrarÄ± yapÄ±lmadan bu sorguya baÅŸvurulabilir.

#### Named Queriesâ€™in Ã–zellikleri

- **Tekrar KullanÄ±labilirlik**: Named Queries, bir kere tanÄ±mlandÄ±ktan sonra uygulamanÄ±n her yerinde kullanÄ±labilir.
- **Kodun Temizlenmesi**: Sorgu tanÄ±mlarÄ± entity sÄ±nÄ±fÄ± iÃ§inde tanÄ±mlandÄ±ÄŸÄ±ndan, sorgu mantÄ±ÄŸÄ± doÄŸrudan kod iÃ§inde yazÄ±lmaz ve bÃ¶ylece daha temiz bir kod yapÄ±sÄ± elde edilir.
- **Statik TanÄ±mlama**: Named Queries uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda derlenir, bu nedenle Ã§alÄ±ÅŸma sÄ±rasÄ±nda herhangi bir hata oluÅŸmaz. Sorgu hatalarÄ± uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda fark edilir.
- **Performans**: JPA, Named Queriesâ€™i uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda derlediÄŸi iÃ§in, Ã§alÄ±ÅŸma sÄ±rasÄ±nda daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r.

#### Named Queries KullanÄ±mÄ±

##### JPQL ile Named Query TanÄ±mlama:

```java
@Entity
@NamedQuery(name = "User.findByName", query = "SELECT u FROM User u WHERE u.name = :name")
public class User {
    @Id
    private Long id;
    private String name;
    // Getter ve Setter'lar
}
```

Bu Ã¶rnekte, **User.findByName** adÄ±nda bir Named Query tanÄ±mlanmÄ±ÅŸtÄ±r. Bu sorgu, `User` entityâ€™sindeki **name** alanÄ±na gÃ¶re veri Ã§ekmektedir.

Bu sorguyu bir repository'de kullanmak iÃ§in:

```java
public interface UserRepository extends JpaRepository<User, Long> {
    @Query(name = "User.findByName")
    List<User> findByName(@Param("name") String name);
}
```

##### Native SQL ile Named Query TanÄ±mlama:

```java
@Entity
@NamedNativeQuery(name = "User.findByAgeNative", query = "SELECT * FROM users WHERE age = :age", resultClass = User.class)
public class User {
    @Id
    private Long id;
    private String name;
    private int age;
    // Getter ve Setter'lar
}
```

Bu sorgu ise **User.findByAgeNative** adÄ±nda bir Native SQL sorgusudur ve doÄŸrudan SQL ile yazÄ±lmÄ±ÅŸtÄ±r.

#### Named Queries AvantajlarÄ±

- **Tekrar KullanÄ±labilirlik**: Birden fazla yerde aynÄ± sorguyu tekrar tanÄ±mlamadan kullanabilirsiniz.
- **Performans ArtÄ±ÅŸÄ±**: Uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda derlendiÄŸi iÃ§in sorgu hatalarÄ± Ã§alÄ±ÅŸma sÄ±rasÄ±nda deÄŸil, baÅŸlangÄ±Ã§ta fark edilir.
- **Statik YapÄ±**: Named Queries uygulama baÅŸlatÄ±lÄ±rken Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan, sorgularÄ±n geÃ§erliliÄŸi Ã¶nceden kontrol edilir ve Ã§alÄ±ÅŸma zamanÄ± hatalarÄ±nÄ±n Ã¶nÃ¼ne geÃ§ilir.

#### Named Queries DezavantajlarÄ±

- **Esneklik EksikliÄŸi**: Named Queries, sabit sorgular olarak tanÄ±mlanÄ±r, bu nedenle dinamik bir sorgu gereksiniminde yeterli esneklik saÄŸlamayabilir.
- **Kod KarmaÅŸasÄ±**: Ã‡ok fazla Named Query tanÄ±mlandÄ±ÄŸÄ±nda entity sÄ±nÄ±flarÄ± karmaÅŸÄ±k hale gelebilir.

---

### JPQL (Java Persistence Query Language)

JPQL, JPA ile birlikte Ã§alÄ±ÅŸan nesne odaklÄ± bir sorgulama dilidir ve doÄŸrudan SQL kullanmadan, Java sÄ±nÄ±flarÄ±na gÃ¶re sorgu yazmayÄ± saÄŸlar. JPQL, entity sÄ±nÄ±flarÄ± Ã¼zerinden Ã§alÄ±ÅŸÄ±r ve bu nedenle nesne tabanlÄ±dÄ±r.

#### JPQLâ€™in Ã–zellikleri

- **Nesne OdaklÄ±**: JPQL, doÄŸrudan tablo ve sÃ¼tun adlarÄ± yerine Java sÄ±nÄ±flarÄ± ve alanlarÄ± Ã¼zerinde Ã§alÄ±ÅŸÄ±r.
- **VeritabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±**: JPQL sorgularÄ±, JPA tarafÄ±ndan desteklenen herhangi bir veritabanÄ±nda Ã§alÄ±ÅŸacak ÅŸekilde soyutlanmÄ±ÅŸtÄ±r. Bu sayede veritabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar.
- **Ä°liÅŸki YÃ¶netimi**: JPQL, entity sÄ±nÄ±flarÄ± arasÄ±ndaki iliÅŸkileri yÃ¶netmek iÃ§in oldukÃ§a uygundur, bu da iliÅŸkisel veritabanÄ± iÅŸlemlerini daha kolay hale getirir.

#### JPQL KullanÄ±mÄ±

JPQL sorgularÄ± **@Query** anotasyonu ile yazÄ±labilir.

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> findByName(@Param("name") String name);
```

Bu Ã¶rnekte JPQL, doÄŸrudan User sÄ±nÄ±fÄ± Ã¼zerinden sorgulama yaparak veritabanÄ±nda **name** alanÄ±na gÃ¶re veri Ã§eker.

#### JPQL AvantajlarÄ±

- **Nesne OdaklÄ± ve VeritabanÄ± BaÄŸÄ±msÄ±z**: JPQL, nesne yÃ¶nelimli bir yapÄ± sunar ve veritabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar.
- **Kolay Ä°liÅŸki YÃ¶netimi**: JPQL, entity iliÅŸkilerini yÃ¶netmek iÃ§in kolay bir yol sunar, bu da daha sade ve okunabilir kod saÄŸlar.
- **Temiz Kod**: JPQL, entity sÄ±nÄ±fÄ± Ã¶zelliklerini doÄŸrudan kullanÄ±r, bu nedenle SQL komutlarÄ±na gÃ¶re daha temiz ve anlaÅŸÄ±lÄ±r bir yapÄ± saÄŸlar.

#### JPQL DezavantajlarÄ±

- **VeritabanÄ± Ã–zgÃ¼ Optimizasyonlardan Yoksun**: JPQL, veritabanÄ± baÄŸÄ±msÄ±z bir yapÄ±ya sahip olduÄŸundan, veritabanÄ±na Ã¶zgÃ¼ optimizasyonlarÄ± kullanmaz.
- **KarmaÅŸÄ±k Sorgu DesteÄŸi SÄ±nÄ±rlÄ±**: JPQL, Ã¶zellikle karmaÅŸÄ±k ve veritabanÄ±na Ã¶zgÃ¼ iÅŸlemlerde sÄ±nÄ±rlÄ±dÄ±r.

---

### Native SQL

Native SQL, doÄŸrudan SQL komutlarÄ± kullanÄ±larak yazÄ±lan sorgulardÄ±r. Bu tÃ¼r sorgular, veritabanÄ± baÄŸÄ±msÄ±z deÄŸildir ve doÄŸrudan veritabanÄ± tablolarÄ± ve sÃ¼tun adlarÄ± kullanÄ±larak Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Native SQL ile veritabanÄ±na Ã¶zgÃ¼ Ã¶zellikleri ve optimizasyonlarÄ± kullanmak mÃ¼mkÃ¼ndÃ¼r.

#### Native SQLâ€™in Ã–zellikleri

- **VeritabanÄ± BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**: Native SQL, belirli bir veritabanÄ±na Ã¶zgÃ¼ SQL sÃ¶z dizimini kullanÄ±r ve bu nedenle veritabanÄ± baÄŸÄ±mlÄ±dÄ±r.
- **KarmaÅŸÄ±k ve Ã–zel Sorgular Ä°Ã§in Uygundur**: Native SQL, karmaÅŸÄ±k ve veritabanÄ±na Ã¶zgÃ¼ sorgular iÃ§in idealdir.
- **Performans AvantajÄ±**: Native SQL, veritabanÄ±na Ã¶zgÃ¼ optimizasyonlarÄ± kullanarak yÃ¼ksek performans saÄŸlar.

#### Native SQL KullanÄ±mÄ±

Native SQL sorgularÄ±, **@Query** anotasyonunun iÃ§inde `nativeQuery = true` parametresi ile belirtilir.

```java
@Query(value = "SELECT * FROM users WHERE age > :age", nativeQuery = true)
List<User> findUsersOlderThan(@Param("age") int age);
```

Bu Ã¶rnekte doÄŸrudan SQL ile yazÄ±lmÄ±ÅŸ bir sorgu kullanÄ±lmÄ±ÅŸtÄ±r.

#### Native SQL AvantajlarÄ±

- **KarmaÅŸÄ±k Sorgular iÃ§in Uygun**: Native SQL, Ã¶zellikle karmaÅŸÄ±k ve veritabanÄ±na Ã¶zgÃ¼ iÅŸlemler iÃ§in idealdir.
- **Performans ArtÄ±ÅŸÄ±**: VeritabanÄ±na Ã¶zgÃ¼ optimizasyonlarÄ± kullanarak daha hÄ±zlÄ± sorgular saÄŸlar.
- **Esneklik**: VeritabanÄ± Ã¶zelliklerinden tam anlamÄ±yla yararlanÄ±r, bÃ¶ylece JPQLâ€™in sÄ±nÄ±rlamalarÄ±nÄ± aÅŸabilirsiniz.

#### Native SQL DezavantajlarÄ±

- **VeritabanÄ± BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**: Native SQL, belirli bir veritabanÄ±na Ã¶zgÃ¼ olduÄŸundan, baÅŸka bir veritabanÄ±na geÃ§iÅŸte sorunlar oluÅŸturabilir.
- **Kod KarmaÅŸÄ±klÄ±ÄŸÄ±**: SQL sorgularÄ±nÄ± doÄŸrudan kullanmak kodu daha karmaÅŸÄ±k hale getirebilir.
- **VeritabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ± EksikliÄŸi**: Native SQL, belirli bir veritabanÄ±na baÄŸÄ±mlÄ±dÄ±r ve baÅŸka bir veritabanÄ±na geÃ§ildiÄŸinde kodda deÄŸiÅŸiklik yapÄ±lmasÄ± gerekir.

---

### Named Queries, JPQL ve Native SQL ArasÄ±ndaki Farklar

| Ã–zellik                  | Named Queries                          | JPQL                                  | Native SQL                              |
|--------------------------|----------------------------------------|---------------------------------------|-----------------------------------------|
| Sorgu YapÄ±sÄ±             | Statik, entity sÄ±nÄ±fÄ± Ã¼zerinde tanÄ±mlanÄ±r | Nesne odaklÄ±, entity sÄ±nÄ±flarÄ± Ã¼zerinden | DoÄŸrudan SQL komutlarÄ± ile yazÄ±lÄ±r      |
| Tekrar KullanÄ±labilirlik | YÃ¼ksek, birden fazla yerde kullanÄ±labilir | Tekrar kullanÄ±labilir ancak entity sÄ±nÄ±fÄ±na baÄŸlÄ±dÄ±r | DÃ¼ÅŸÃ¼k, genelde Ã¶zel durumlar iÃ§in      |
| VeritabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±  | Evet (JPQL ile tanÄ±mlÄ±ysa)             | Evet                                  | HayÄ±r                                   |
| Performans               | Uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda derlenir, hÄ±zlÄ±dÄ±r | Orta, veritabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar | YÃ¼ksek, veritabanÄ±na

Ã¶zgÃ¼ optimizasyonlar kullanÄ±r |
| KarmaÅŸÄ±k Sorgu DesteÄŸi   | Orta, genelde basit sorgular iÃ§in      | Orta                                  | YÃ¼ksek, veritabanÄ±na Ã¶zgÃ¼ sorgular yapÄ±labilir |
| KolaylÄ±k                 | Kolay, kodda daÄŸÄ±lmamÄ±ÅŸ yapÄ± sunar     | Kolay, nesne odaklÄ± yapÄ±ya sahip      | SQL bilgisi gerektirir                  |

### Ã–zet ve Hangi Durumda Hangi YÃ¶ntem KullanÄ±lmalÄ±?

- **Named Queries**: Tekrar kullanÄ±labilir, statik sorgular gerektiÄŸinde ve aynÄ± sorguyu birden fazla yerde kullanmak gerektiÄŸinde tercih edilmelidir.
- **JPQL**: Nesne odaklÄ±, veritabanÄ± baÄŸÄ±msÄ±z sorgular iÃ§in idealdir. JPA entity iliÅŸkilerini yÃ¶netirken ve temel CRUD iÅŸlemlerinde daha Ã§ok tercih edilmelidir.
- **Native SQL**: VeritabanÄ±na Ã¶zgÃ¼ sorgular gerektiÄŸinde, karmaÅŸÄ±k iÅŸlemler ve Ã¶zel performans ihtiyaÃ§larÄ±nda kullanÄ±lÄ±r.

Her Ã¼Ã§ yÃ¶ntemin de kendine Ã¶zgÃ¼ avantajlarÄ± ve kullanÄ±m alanlarÄ± vardÄ±r. Projenizin ihtiyaÃ§larÄ±na gÃ¶re en uygun sorgu yÃ¶ntemi belirlenmelidir.


## Spring Boot (SayfalandÄ±rma ve SÄ±ralama (Pagination and Sorting))
```sh 

```
---
### SayfalandÄ±rma ve SÄ±ralama (Pagination and Sorting)

Spring Data, bÃ¼yÃ¼k veri setlerinde Ã§alÄ±ÅŸÄ±rken verilerin sayfalara bÃ¶lÃ¼nerek gÃ¶rÃ¼ntÃ¼lenmesini ve sÄ±ralanmasÄ±nÄ± saÄŸlar. `Pageable` ve `Sort` nesneleri sayesinde veriler sayfalara bÃ¶lÃ¼nerek belirli bir sÄ±rada listelenebilir.

Ã–rneÄŸin:

```java
Pageable pageable = PageRequest.of(0, 10, Sort.by("lastName").descending());
Page<Customer> customers = customerRepository.findAll(pageable);
```

Bu Ã¶rnekte `Customer` verileri, `lastName` alanÄ±na gÃ¶re azalan bir ÅŸekilde ilk 10 kayÄ±t iÃ§in sayfalama yapÄ±larak getirilir.

### Spring Data ile Transaksiyon YÃ¶netimi

Spring Data, iÅŸlem yÃ¶netimi (transaction management) desteÄŸi de sunar. Birden fazla veri tabanÄ± iÅŸleminin tek bir iÅŸlem olarak ele alÄ±nmasÄ± durumunda verilerin tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸlamak iÃ§in `@Transactional` anotasyonu kullanÄ±labilir. Bu sayede bir iÅŸlem baÅŸarÄ±sÄ±z olduÄŸunda tÃ¼m iÅŸlemler geri alÄ±nÄ±r (rollback yapÄ±lÄ±r).

```java
@Transactional
public void saveCustomerData(Customer customer, Address address) {
    customerRepository.save(customer);
    addressRepository.save(address);
}
```

### Spring Data Auditing (Denetim)

Spring Data Auditing, veri tabanÄ±ndaki kayÄ±tlarda oluÅŸturulma ve gÃ¼ncellenme tarihleri gibi verileri otomatik olarak tutar. `@CreatedDate` ve `@LastModifiedDate` anotasyonlarÄ± ile bu iÅŸlemler kolayca yapÄ±labilir.

Ã–rneÄŸin:

```java
@Entity
@EntityListeners(AuditingEntityListener.class)
public class Customer {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @CreatedDate
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime lastModifiedDate;

    // diÄŸer alanlar ve getter/setter metodlarÄ±
}
```

Bu Ã¶rnek sayesinde, `Customer` kaydÄ± oluÅŸturulduÄŸunda `createdDate`, gÃ¼ncellendiÄŸinde `lastModifiedDate` otomatik olarak gÃ¼ncellenir.

### Spring Dataâ€™nÄ±n AvantajlarÄ± ve DezavantajlarÄ±

**AvantajlarÄ±**:

- **HÄ±zlÄ± ve Kolay CRUD Ä°ÅŸlemleri**: Repository yapÄ±sÄ± sayesinde CRUD iÅŸlemleri hÄ±zlÄ±ca yapÄ±lÄ±r.
-

**Kod TekrarÄ±nÄ± AzaltÄ±r**: SorgularÄ±n Ã§oÄŸu dinamik olarak oluÅŸturulduÄŸu iÃ§in kod tekrarÄ± azalÄ±r.
- **VeritabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±**: AynÄ± veri eriÅŸim katmanÄ±, farklÄ± veri depolarÄ±nda kullanÄ±labilir.
- **SayfalandÄ±rma ve SÄ±ralama DesteÄŸi**: Verilerin kolayca sayfalanmasÄ± ve sÄ±ralanmasÄ± mÃ¼mkÃ¼ndÃ¼r.

**DezavantajlarÄ±**:

- **Ã–ÄŸrenme EÄŸrisi**: Ã–zellikle yeni baÅŸlayanlar iÃ§in Repository ve Spring Data yapÄ±sÄ±nÄ±n Ã¶ÄŸrenilmesi biraz zaman alabilir.
- **Performans Problemleri**: KarmaÅŸÄ±k sorgularda performans sorunlarÄ± yaÅŸanabilir. Bu durumda Ã¶zelleÅŸtirilmiÅŸ sorgular yazÄ±lmasÄ± gerekebilir.

### SonuÃ§

Spring Data, veri tabanÄ±yla Ã§alÄ±ÅŸan uygulamalar iÃ§in bÃ¼yÃ¼k kolaylÄ±klar saÄŸlayan, geniÅŸ Ã¶zellik yelpazesine sahip bir modÃ¼ldÃ¼r. FarklÄ± veri depolarÄ±yla entegre Ã§alÄ±ÅŸabilmesi ve standart bir veri eriÅŸim katmanÄ± sunmasÄ±, uygulamalarÄ±n daha hÄ±zlÄ± geliÅŸtirilmesini ve daha yÃ¶netilebilir hale getirilmesini saÄŸlar. Spring Data, veri iÅŸlemlerini modÃ¼ler ve esnek hale getirirken, yazÄ±lÄ±mÄ±n sÃ¼rdÃ¼rÃ¼lebilirliÄŸini de artÄ±rÄ±r.

Daha fazla detay isterseniz veya herhangi bir Ã¶zel konu hakkÄ±nda Ã¶rnekler gÃ¶rmek isterseniz, size yardÄ±mcÄ± olmaktan memnuniyet duyarÄ±m.

## Spring Boot (Delivered Query , Named Queries,  JPQL ve Native SQL ArasÄ±ndaki Farklar)
```sh 

```
---


Delivered Query , Named Queries,  JPQL ve Native SQL ArasÄ±ndaki Farklar
## Spring Boot
```sh 

```
---

Spring API, Spring Frameworkâ€™Ã¼n sunduÄŸu programlama arayÃ¼zlerini ve araÃ§larÄ±nÄ± kapsayan bir yapÄ±dÄ±r. Bu API'ler, Ã¶zellikle RESTful web servisleri oluÅŸturmak, Ã§eÅŸitli uygulama bileÅŸenlerini birbirine baÄŸlamak ve yazÄ±lÄ±m geliÅŸtirme sÃ¼recini kolaylaÅŸtÄ±rmak iÃ§in kullanÄ±lÄ±r. Spring API, web tabanlÄ± uygulamalarÄ±n geliÅŸtirilmesi ve yÃ¶netilmesi iÃ§in geniÅŸ bir araÃ§ seti sunar. Bu araÃ§ seti sayesinde geliÅŸtiriciler, yÃ¼ksek performanslÄ±, gÃ¼venli ve Ã¶lÃ§eklenebilir web servisleri ve API'ler oluÅŸturabilir.

Spring API, Ã¶zellikle REST API geliÅŸtirmede popÃ¼lerdir ve birÃ§ok kurumsal projede kullanÄ±lÄ±r. RESTful servisler, istemci-sunucu mimarisi temelinde HTTP protokolÃ¼ Ã¼zerinden veri alÄ±ÅŸveriÅŸi yapar ve Spring API bu servislerin hÄ±zlÄ± ve etkili bir ÅŸekilde oluÅŸturulmasÄ±na olanak tanÄ±r.

### Spring API'nin Temel BileÅŸenleri

Spring API, birÃ§ok farklÄ± bileÅŸeni iÃ§erir. Bu bileÅŸenler, web uygulamalarÄ± geliÅŸtirme, veri iÅŸleme, gÃ¼venlik saÄŸlama gibi farklÄ± gÃ¶revleri yerine getirmek Ã¼zere tasarlanmÄ±ÅŸtÄ±r. BaÅŸlÄ±ca bileÅŸenleri ÅŸunlardÄ±r:

1. **Spring MVC**: Model-View-Controller mimarisi Ã¼zerine kuruludur ve web tabanlÄ± uygulama geliÅŸtirmeyi saÄŸlar. Spring MVC, web isteklerini iÅŸleyerek yanÄ±tlar, yÃ¶nlendirme iÅŸlemlerini yÃ¶netir ve uygulama mantÄ±ÄŸÄ±nÄ± model katmanÄ±nda kapsar. Spring MVC, REST API geliÅŸtirmede de bÃ¼yÃ¼k rol oynar ve HTTP protokolÃ¼nÃ¼ etkin bir ÅŸekilde kullanarak veri alÄ±ÅŸveriÅŸi yapÄ±lmasÄ±nÄ± saÄŸlar.

2. **Spring Web**: Bu bileÅŸen, web uygulamalarÄ± ve REST APIâ€™ler geliÅŸtirmek iÃ§in kullanÄ±lan temel bir modÃ¼ldÃ¼r. Web Ã¼zerinden veri gÃ¶nderme, alma ve yÃ¶nlendirme iÅŸlemlerini iÃ§erir. Ã–zellikle Spring Boot ile birlikte kullanÄ±ldÄ±ÄŸÄ±nda, Spring Webâ€™in saÄŸladÄ±ÄŸÄ± basitleÅŸtirilmiÅŸ yapÄ±, hÄ±zlÄ± API geliÅŸtirmeyi saÄŸlar.

3. **Spring REST**: REST (Representational State Transfer) standartlarÄ± Ã¼zerine kurulu servisler geliÅŸtirmek iÃ§in kullanÄ±lan bir bileÅŸendir. RESTful servisler, HTTP metotlarÄ± (GET, POST, PUT, DELETE) ile Ã§alÄ±ÅŸÄ±r ve JSON, XML gibi veri formatlarÄ±nÄ± kullanarak veri alÄ±ÅŸveriÅŸi yapar. Spring REST, Spring MVC ile entegre Ã§alÄ±ÅŸarak RESTful API geliÅŸtirmeyi kolaylaÅŸtÄ±rÄ±r.

4. **Spring Data REST**: Spring Data REST, veri tabanÄ± iÅŸlemlerini REST API Ã¼zerinden kullanÄ±ma sunmayÄ± saÄŸlar. Bu modÃ¼l, veri tabanÄ± iÅŸlemlerini RESTful servisler aracÄ±lÄ±ÄŸÄ±yla otomatikleÅŸtirir ve CRUD iÅŸlemleri iÃ§in gerekli API'leri oluÅŸturur. Bu sayede Spring Data ile oluÅŸturulan veri modelleri, Spring Data REST kullanÄ±larak hÄ±zlÄ±ca API'ler haline getirilebilir.

5. **Spring HATEOAS (Hypermedia as the Engine of Application State)**: Spring HATEOAS, REST API'lerde daha zengin ve anlamlÄ± yanÄ±tlar oluÅŸturmayÄ± amaÃ§lar. Hypermedia, API'nin istemcinin kendi kendine yol bulmasÄ±nÄ± saÄŸlayan linkleri yanÄ±tlarla birlikte dÃ¶ndÃ¼rmesini saÄŸlar. Ã–rneÄŸin, bir kullanÄ±cÄ± bilgisi dÃ¶ndÃ¼rÃ¼lÃ¼rken, o kullanÄ±cÄ±ya ait iliÅŸkili diÄŸer kaynaklarÄ±n (sipariÅŸler, adresler) baÄŸlantÄ±larÄ± da yanÄ±t iÃ§inde sunulabilir.

6. **Spring Security**: API'lerin gÃ¼venliÄŸini saÄŸlamak iÃ§in kullanÄ±lan modÃ¼ldÃ¼r. Kimlik doÄŸrulama, yetkilendirme ve eriÅŸim kontrolÃ¼ gibi gÃ¼venlik iÅŸlemlerini yÃ¶netir. API'lerin gÃ¼venliÄŸini saÄŸlamak, Ã¶zellikle kullanÄ±cÄ± verilerini korumak iÃ§in son derece Ã¶nemlidir. Spring Security, REST API'ler iÃ§in OAuth2, JWT (JSON Web Tokens) gibi modern gÃ¼venlik protokollerini de destekler.

7. **Spring Cloud**: Mikroservis mimarisine uygun API'ler geliÅŸtirmek iÃ§in kullanÄ±lan Spring modÃ¼lÃ¼dÃ¼r. Spring Cloud, daÄŸÄ±tÄ±k sistemlerde kullanÄ±lan servis keÅŸfi, yÃ¼k dengeleme, yapÄ±landÄ±rma yÃ¶netimi gibi Ã¶zellikleri saÄŸlar. Ã–zellikle mikroservis tabanlÄ± uygulamalarda, Spring Cloud ile API'lerin yÃ¶netimi kolaylaÅŸÄ±r.

### Spring API ile RESTful Servis GeliÅŸtirme

RESTful servisler, Spring API'nin en sÄ±k kullanÄ±ldÄ±ÄŸÄ± alanlardan biridir. Spring API, REST standartlarÄ±na uygun servislerin hÄ±zlÄ± ve kolay bir ÅŸekilde geliÅŸtirilmesini saÄŸlar. Spring API ile RESTful servis geliÅŸtirmek iÃ§in izlenen adÄ±mlar ÅŸunlardÄ±r:

1. **Controller SÄ±nÄ±flarÄ±**: Spring API'de RESTful servislerin ana bileÅŸeni olan denetleyiciler (controllers) kullanÄ±lÄ±r. Bu sÄ±nÄ±flar, gelen HTTP isteklerini iÅŸleyerek uygun yanÄ±tlarÄ± dÃ¶ndÃ¼rÃ¼r. Her bir HTTP isteÄŸi, belirli bir denetleyici metoduna yÃ¶nlendirilir ve burada iÅŸlenir.

   Ã–rneÄŸin, `@RestController` anotasyonu ile bir denetleyici sÄ±nÄ±fÄ± tanÄ±mlanabilir ve `@RequestMapping` ile belirli bir URL ile eÅŸleÅŸtirilebilir:

   ```java
   @RestController
   @RequestMapping("/api/customers")
   public class CustomerController {

       @GetMapping("/{id}")
       public ResponseEntity<Customer> getCustomerById(@PathVariable Long id) {
           Customer customer = customerService.findById(id);
           return ResponseEntity.ok(customer);
       }

       @PostMapping
       public ResponseEntity<Customer> createCustomer(@RequestBody Customer customer) {
           Customer createdCustomer = customerService.save(customer);
           return ResponseEntity.status(HttpStatus.CREATED).body(createdCustomer);
       }
   }
   ```

   Bu Ã¶rnekte, `CustomerController` sÄ±nÄ±fÄ±, `/api/customers` yoluyla HTTP GET ve POST isteklerini iÅŸler. `@GetMapping` ve `@PostMapping` anotasyonlarÄ± ile bu isteklerin belirli metodlara yÃ¶nlendirilmesi saÄŸlanÄ±r.

2. **DTO (Data Transfer Object) KullanÄ±mÄ±**: APIâ€™ler aracÄ±lÄ±ÄŸÄ±yla veri alÄ±ÅŸveriÅŸinde kullanÄ±lan nesneler, genellikle DTO adÄ± verilen veri transfer nesneleri ile yÃ¶netilir. DTOâ€™lar, veri modelini doÄŸrudan istemciye gÃ¶ndermek yerine daha gÃ¼venli ve optimize edilmiÅŸ veri yapÄ±larÄ± sunar.

3. **Exception Handling**: Spring API, hata durumlarÄ±nda daha anlamlÄ± ve kullanÄ±cÄ± dostu yanÄ±tlar dÃ¶ndÃ¼rmek iÃ§in istisna yÃ¶netimi saÄŸlar. `@ExceptionHandler` anotasyonu ile belirli hata tÃ¼rlerine Ã¶zel yanÄ±tlar oluÅŸturulabilir. Bu, istemcinin hata durumlarÄ±nda daha ayrÄ±ntÄ±lÄ± bilgi almasÄ±nÄ± saÄŸlar.

   Ã–rneÄŸin:

   ```java
   @ControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(ResourceNotFoundException.class)
       public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
           ErrorResponse error = new ErrorResponse("Resource not found", ex.getMessage());
           return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
       }
   }
   ```

4. **ResponseEntity KullanÄ±mÄ±**: Spring API, yanÄ±tlarÄ± daha esnek bir ÅŸekilde dÃ¶ndÃ¼rmek iÃ§in `ResponseEntity` sÄ±nÄ±fÄ±nÄ± saÄŸlar. Bu sÄ±nÄ±f ile HTTP durum kodlarÄ±, baÅŸlÄ±k bilgileri ve yanÄ±t gÃ¶vdesi Ã¶zelleÅŸtirilebilir. `ResponseEntity`, yanÄ±tÄ±n daha anlamlÄ± ve detaylÄ± olmasÄ±nÄ± saÄŸlar.

5. **Parametre KullanÄ±mÄ±**: Spring API, API isteklerinde parametrelerin kolayca kullanÄ±lmasÄ±nÄ± saÄŸlar. `@RequestParam`, `@PathVariable` gibi anotasyonlar ile URL parametreleri, yol parametreleri ve sorgu parametreleri yÃ¶netilebilir.

   ```java
   @GetMapping
   public List<Customer> getCustomersByStatus(@RequestParam String status) {
       return customerService.findByStatus(status);
   }
   ```

### Spring Data REST ile Otomatik API GeliÅŸtirme

Spring Data REST, Spring Data ile oluÅŸturulmuÅŸ veri modellerini otomatik olarak REST API olarak sunmak iÃ§in kullanÄ±lÄ±r. Bu sayede veri tabanÄ± iÅŸlemleri iÃ§in manuel olarak denetleyici sÄ±nÄ±flarÄ± yazmaya gerek kalmaz. Spring Data REST, Spring Data repository arayÃ¼zlerini kullanarak otomatik olarak CRUD APIâ€™leri oluÅŸturur.

Ã–rneÄŸin, `CustomerRepository` aÅŸaÄŸÄ±daki gibi tanÄ±mlanmÄ±ÅŸsa:

```java
@RepositoryRestResource
public interface CustomerRepository extends JpaRepository<Customer, Long> {
}
```

Spring Data REST, bu repositoryâ€™ye otomatik olarak CRUD iÅŸlemlerini saÄŸlayan URLâ€™ler ekler:

- `GET /customers`: TÃ¼m mÃ¼ÅŸterileri getirir.
- `POST /customers`: Yeni bir mÃ¼ÅŸteri ekler.
- `GET /customers/{id}`: Belirli bir mÃ¼ÅŸteri detayÄ±nÄ± getirir.
- `PUT /customers/{id}`: Belirli bir mÃ¼ÅŸteriyi gÃ¼nceller.
- `DELETE /customers/{id}`: Belirli bir mÃ¼ÅŸteriyi siler.

Bu Ã¶zellik, veri tabanÄ± iÅŸlemlerini hÄ±zlÄ± bir ÅŸekilde API olarak sunmak isteyen geliÅŸtiriciler iÃ§in bÃ¼yÃ¼k bir avantaj saÄŸlar.

### Spring HATEOAS ile Hypermedia Destekli APIâ€™ler

Spring HATEOAS, REST API yanÄ±tlarÄ±nÄ± zenginleÅŸtirmek iÃ§in kullanÄ±lan bir modÃ¼ldÃ¼r. HATEOAS, istemcinin API yapÄ±sÄ±nÄ± daha iyi anlamasÄ±nÄ± ve navigasyonu kolaylaÅŸtÄ±rmasÄ±nÄ± saÄŸlar. YanÄ±t iÃ§erisine linkler ekleyerek, istemcinin ek bir dokÃ¼mana ihtiyaÃ§ duymadan ilgili kaynaklara eriÅŸebilmesi saÄŸlanÄ±r.

Ã–rneÄŸin, mÃ¼ÅŸteri detaylarÄ±nÄ± dÃ¶ndÃ¼rÃ¼rken, o mÃ¼ÅŸteriye ait sipariÅŸlerin linkini de yanÄ±tabilirsiniz. Bu, istemcinin mÃ¼ÅŸteri verisini aldÄ±ktan sonra ilgili sipariÅŸ bilgilerine kolayca ulaÅŸmasÄ±nÄ± saÄŸlar.

```java
@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    @Autowired
    private CustomerService customerService;

    @GetMapping("/{id}")
    public EntityModel<Customer> getCustomerById(@PathVariable Long id) {
        Customer customer = customerService.findById(id);

        EntityModel<Customer> resource = EntityModel.of(customer);
        resource.add(linkTo(methodOn(CustomerController.class).getCustomerById(id)).withSelfRel());
        resource.add(linkTo(methodOn(OrderController.class).getOrdersByCustomerId(id)).withRel("orders"));

        return resource;
    }
}
```

Bu Ã¶rnekte `EntityModel` kullanÄ±larak `Customer` nesnesine "self" linki ve iliÅŸkili "orders" linki eklenmiÅŸtir. Ä°stemci, yanÄ±tÄ± aldÄ±ÄŸÄ±nda mÃ¼ÅŸteriye ait sipariÅŸlere de kolayca eriÅŸebilir.

### Spring Security ile API GÃ¼venliÄŸi

APIâ€™lerin gÃ¼venliÄŸi, Ã¶zellikle hassas veri alÄ±ÅŸveriÅŸi yapÄ±lan uygulamalarda bÃ¼yÃ¼k Ã¶nem taÅŸÄ±r. Spring Security, kimlik doÄŸrulama ve yetkilendirme sÃ¼reÃ§lerini yÃ¶neterek API'leri gÃ¼venli hale getirir. Spring APIâ€™de gÃ¼venlik saÄŸlamak iÃ§in JWT (JSON Web Token) veya OAuth2 gibi modern gÃ¼venlik protokolleri kullanÄ±labilir.

**JWT ile Kimlik DoÄŸrulama**: JWT, kullanÄ±cÄ±nÄ±n kimliÄŸini doÄŸrulamak iÃ§in kullanÄ±lan, imzalÄ± bir token yapÄ±sÄ±dÄ±r. KullanÄ±cÄ± giriÅŸ yaptÄ±ÄŸÄ±nda, JWT token oluÅŸturulur ve kullanÄ±cÄ±ya gÃ¶nderilir. Ä°stemci, API isteklerinde bu token'Ä± taÅŸÄ±yarak kimliÄŸini doÄŸrular.

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
            .antMatchers("/api/auth/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .addFilter(new JWTAuthenticationFilter(authenticationManager()));
    }
}
```

Bu yapÄ±landÄ±rmada `/api/auth/**` altÄ±ndaki URL'lere kimlik doÄŸrulama olmadan eriÅŸim izni verilmiÅŸtir. DiÄŸer tÃ¼m URL'ler iÃ§in JWT kimlik doÄŸrulamasÄ± gereklidir.

### Spring API'de Swagger ile API DokÃ¼mantasyonu

Spring API'leri geliÅŸtirirken, istemcilerin API'leri nasÄ±l kullanacaÄŸÄ±nÄ± anlamalarÄ±nÄ± saÄŸlamak iÃ§in dokÃ¼mantasyon Ã¶nemlidir. Swagger, Spring APIâ€™leri iÃ§in kapsamlÄ± ve otomatik bir dokÃ¼mantasyon Ã§Ã¶zÃ¼mÃ¼ sunar. Spring Boot projelerine kolayca entegre edilebilir ve API uÃ§ noktalarÄ±nÄ± gÃ¶rselleÅŸtirir.

Swaggerâ€™Ä±n kullanÄ±mÄ± iÃ§in, `springdoc-openapi-ui` gibi bir baÄŸÄ±mlÄ±lÄ±k projeye eklenebilir. Bu, API uÃ§ noktalarÄ±nÄ±n interaktif bir dokÃ¼mantasyon sayfasÄ±nda gÃ¶sterilmesini saÄŸlar.

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-ui</artifactId>
    <version>1.5.9</version>
</dependency>
```

Swagger UI ile, geliÅŸtiriciler API isteklerini test edebilir ve dÃ¶nen yanÄ±tlarÄ± gÃ¶rebilir, bu da hata ayÄ±klama ve test sÃ¼recini kolaylaÅŸtÄ±rÄ±r.

### Spring API'nin AvantajlarÄ± ve DezavantajlarÄ±

**AvantajlarÄ±**:

- **HÄ±zlÄ± GeliÅŸtirme**: Spring API modÃ¼lleri, geliÅŸtiricilere standart yapÄ±lar ve anotasyonlar sunarak hÄ±zlÄ± bir ÅŸekilde API geliÅŸtirme imkanÄ± tanÄ±r.
- **Esneklik ve Ã–zelleÅŸtirilebilirlik**: Springâ€™in modÃ¼ler yapÄ±sÄ±, projeye uygun bileÅŸenlerin kullanÄ±lmasÄ±nÄ± ve Ã¶zelleÅŸtirilmesini kolaylaÅŸtÄ±rÄ±r.
- **GeniÅŸ GÃ¼venlik DesteÄŸi**: Spring Security ile gÃ¼Ã§lÃ¼ kimlik doÄŸrulama ve yetkilendirme sÃ¼reÃ§leri oluÅŸturulabilir.
- **KapsamlÄ± Ekosistem**: Spring Data, Spring MVC, Spring Security gibi modÃ¼ller, API geliÅŸtirme sÃ¼recinde her tÃ¼rlÃ¼ ihtiyaca yanÄ±t verir.

**DezavantajlarÄ±**:

- **Ã–ÄŸrenme EÄŸrisi**: Spring API, yeni baÅŸlayanlar iÃ§in karmaÅŸÄ±k olabilir, Ã¶zellikle HATEOAS, gÃ¼venlik yapÄ±landÄ±rmalarÄ± gibi Ã¶zellikler Ã¶ÄŸrenme sÃ¼recini uzatabilir.
- **Performans SorunlarÄ±**: BÃ¼yÃ¼k Ã¶lÃ§ekli uygulamalarda performans optimizasyonlarÄ± gerekebilir.
- **Ã–zelleÅŸtirme Gereksinimi**: Ã–zellikle API gÃ¼venliÄŸi veya Ã¶zelleÅŸtirilmiÅŸ sorgular gibi Ã¶zel gereksinimler iÃ§in yapÄ±landÄ±rmalar karmaÅŸÄ±k hale gelebilir.

### SonuÃ§

Spring API, gÃ¼Ã§lÃ¼ ve kapsamlÄ± bir araÃ§ seti sunarak kurumsal dÃ¼zeyde APIâ€™lerin hÄ±zlÄ± ve gÃ¼venli bir ÅŸekilde geliÅŸtirilmesini saÄŸlar. RESTful servisler, gÃ¼venlik Ã¶nlemleri, veri yÃ¶netimi ve dokÃ¼mantasyon gibi konularda saÄŸladÄ±ÄŸÄ± Ã§Ã¶zÃ¼mler, geliÅŸtiricilere modÃ¼ler, esnek ve test edilebilir APIâ€™ler oluÅŸturma imkanÄ± tanÄ±r. Spring APIâ€™ler, kurumsal projelerde tercih edilen bir yapÄ± olarak, geniÅŸ topluluk desteÄŸi ve sÃ¼rekli gÃ¼ncellenen ekosistemi sayesinde modern yazÄ±lÄ±m geliÅŸtirme sÃ¼reÃ§lerinin vazgeÃ§ilmez bir parÃ§asÄ± olmuÅŸtur.

Daha detaylÄ± bir konu veya Ã¶rnek ile ilgili sorularÄ±nÄ±z varsa, daha ayrÄ±ntÄ±lÄ± bilgi saÄŸlamaktan memnuniyet duyarÄ±m.



## Spring Boot (Spring Security)
```sh 

```
---

Spring Security, Java tabanlÄ± uygulamalarda kimlik doÄŸrulama, yetkilendirme ve eriÅŸim kontrolÃ¼ saÄŸlamak iÃ§in kullanÄ±lan gÃ¼Ã§lÃ¼ ve esnek bir gÃ¼venlik Ã§erÃ§evesidir. Spring Frameworkâ€™Ã¼n bir modÃ¼lÃ¼ olan Spring Security, web uygulamalarÄ±, RESTful APIâ€™ler ve mikroservis mimarilerinde gÃ¼venlik Ã¶nlemleri almak iÃ§in yaygÄ±n olarak kullanÄ±lÄ±r. Ã–zellikle kurumsal projelerde gÃ¼venliÄŸin kritik Ã¶nemde olduÄŸu durumlarda, Spring Securityâ€™nin sunduÄŸu kapsamlÄ± gÃ¼venlik Ã¶zellikleri, uygulamalarÄ±n yÃ¼ksek gÃ¼venlik standartlarÄ±na uygun bir ÅŸekilde geliÅŸtirilmesine olanak tanÄ±r.

### Spring Security'nin Temel Ã–zellikleri ve FaydalarÄ±

1. **Kimlik DoÄŸrulama (Authentication)**: KullanÄ±cÄ±larÄ±n sisteme eriÅŸim saÄŸlamak iÃ§in doÄŸrulanmasÄ±nÄ± saÄŸlar. Kimlik doÄŸrulama, kullanÄ±cÄ± adÄ± ve ÅŸifre ile yapÄ±labileceÄŸi gibi, OAuth2 ve JWT (JSON Web Token) gibi modern gÃ¼venlik protokolleri ile de desteklenir.

2. **Yetkilendirme (Authorization)**: Kimlik doÄŸrulamasÄ± yapÄ±lan kullanÄ±cÄ±larÄ±n hangi kaynaklara eriÅŸim iznine sahip olduÄŸunu belirler. KullanÄ±cÄ±lar belirli roller ve yetkilere gÃ¶re sÄ±nÄ±flandÄ±rÄ±lÄ±r ve bu yetkiler doÄŸrultusunda kaynaklara eriÅŸim izni verilir.

3. **HTTP GÃ¼venliÄŸi**: Spring Security, HTTP tabanlÄ± saldÄ±rÄ±lara karÅŸÄ± koruma saÄŸlar. Ã–zellikle CSRF (Cross-Site Request Forgery - Siteler ArasÄ± Ä°stek SahteciliÄŸi), XSS (Cross-Site Scripting - Siteler ArasÄ± Betik Ã‡alÄ±ÅŸtÄ±rma) ve Clickjacking gibi saldÄ±rÄ±lara karÅŸÄ± gÃ¼venlik Ã¶nlemleri sunar.

4. **Åifreleme ve Hashing DesteÄŸi**: Spring Security, kullanÄ±cÄ± ÅŸifrelerinin gÃ¼venli bir ÅŸekilde saklanmasÄ± ve iÅŸlenmesi iÃ§in hashing algoritmalarÄ± kullanÄ±r. Ã–rneÄŸin, BCrypt algoritmasÄ± ile ÅŸifrelerin gÃ¼venli bir ÅŸekilde saklanmasÄ±nÄ± saÄŸlar.

5. **Esnek Kimlik DoÄŸrulama MekanizmalarÄ±**: Temel kimlik doÄŸrulamanÄ±n yanÄ± sÄ±ra, LDAP (Lightweight Directory Access Protocol), OAuth2, OpenID Connect ve SSO (Single Sign-On) gibi Ã§eÅŸitli kimlik doÄŸrulama protokolleri ile entegre Ã§alÄ±ÅŸÄ±r.

6. **Kolay KonfigÃ¼rasyon ve Esneklik**: Spring Security, hem XML tabanlÄ± hem de Java tabanlÄ± konfigÃ¼rasyon destekler. GeliÅŸtiricilere, gÃ¼venlik ayarlarÄ±nÄ± Ã¶zelleÅŸtirme ve uygulama gereksinimlerine gÃ¶re yapÄ±landÄ±rma imkanÄ± tanÄ±r.

### Spring Securityâ€™nin Mimarisi

Spring Securityâ€™nin temel yapÄ±sÄ± Ã¼Ã§ ana bileÅŸenden oluÅŸur:

1. **SecurityContext**: Uygulamada oturum aÃ§an kullanÄ±cÄ±ya ait gÃ¼venlik bilgisini saklar. SecurityContext, kimlik doÄŸrulama iÅŸlemi tamamlandÄ±ÄŸÄ±nda kullanÄ±cÄ±nÄ±n kimliÄŸini doÄŸrulayan bilgileri iÃ§erir ve uygulama boyunca bu bilgilerden faydalanÄ±r.

2. **AuthenticationManager**: KullanÄ±cÄ±nÄ±n kimliÄŸini doÄŸrulayan ana bileÅŸendir. AuthenticationManager, kimlik doÄŸrulama saÄŸlayÄ±cÄ±larÄ± (authentication providers) aracÄ±lÄ±ÄŸÄ±yla kimlik doÄŸrulama iÅŸlemlerini gerÃ§ekleÅŸtirir. Bu saÄŸlayÄ±cÄ±lar, kullanÄ±cÄ± bilgilerini doÄŸrulamak iÃ§in veri tabanlarÄ±, LDAP veya Ã¼Ã§Ã¼ncÃ¼ parti kimlik doÄŸrulama servisleri ile entegre Ã§alÄ±ÅŸabilir.

3. **AccessDecisionManager**: Yetkilendirme kararlarÄ±nÄ± alÄ±r ve kullanÄ±cÄ±nÄ±n belirli bir kaynaÄŸa eriÅŸim hakkÄ± olup olmadÄ±ÄŸÄ±nÄ± belirler. KullanÄ±cÄ±, istenen kaynaÄŸa eriÅŸim iznine sahip deÄŸilse, eriÅŸim reddedilir.

### Spring Security ile Kimlik DoÄŸrulama (Authentication)

Kimlik doÄŸrulama, kullanÄ±cÄ±nÄ±n geÃ§erli bir kullanÄ±cÄ± adÄ± ve ÅŸifre ile sisteme giriÅŸ yapmasÄ± iÅŸlemidir. Spring Securityâ€™de kimlik doÄŸrulama iÅŸlemi `AuthenticationManager` aracÄ±lÄ±ÄŸÄ±yla gerÃ§ekleÅŸtirilir. `UsernamePasswordAuthenticationToken` sÄ±nÄ±fÄ±, en yaygÄ±n kimlik doÄŸrulama yÃ¶ntemi olan kullanÄ±cÄ± adÄ± ve ÅŸifreyle doÄŸrulama yapar. `AuthenticationProvider` ise bu doÄŸrulama sÃ¼recinin gerÃ§ek kaynaÄŸÄ±dÄ±r; yani kullanÄ±cÄ± bilgilerini doÄŸrulamak iÃ§in veri tabanÄ±nda arama yapar.

#### Ã–rnek Kimlik DoÄŸrulama YapÄ±landÄ±rmasÄ±

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
            .withUser("user")
            .password(passwordEncoder().encode("password"))
            .roles("USER")
            .and()
            .withUser("admin")
            .password(passwordEncoder().encode("admin"))
            .roles("ADMIN");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/user/**").hasAnyRole("USER", "ADMIN")
            .and()
            .formLogin();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

Bu yapÄ±landÄ±rmada, `inMemoryAuthentication` ile kullanÄ±cÄ± bilgileri bellekte saklanÄ±r. `/admin/**` yoluna sadece "ADMIN" rolÃ¼ne sahip kullanÄ±cÄ±lar eriÅŸebilirken, `/user/**` yoluna "USER" veya "ADMIN" rolÃ¼ne sahip kullanÄ±cÄ±lar eriÅŸebilir.

### Yetkilendirme (Authorization)

Spring Security, kullanÄ±cÄ±larÄ±n belirli kaynaklara eriÅŸimini kÄ±sÄ±tlayarak yetkilendirme iÅŸlemlerini yÃ¶netir. KullanÄ±cÄ±lar roller (roles) ve yetkiler (authorities) aracÄ±lÄ±ÄŸÄ±yla sÄ±nÄ±flandÄ±rÄ±lÄ±r. Bu roller ve yetkiler, belirli URLâ€™lere veya metodlara eriÅŸim kontrolÃ¼ saÄŸlamak iÃ§in kullanÄ±lÄ±r.

#### Rol TabanlÄ± Yetkilendirme

Rol tabanlÄ± yetkilendirme, kullanÄ±cÄ±nÄ±n rolÃ¼ne gÃ¶re kaynaklara eriÅŸim hakkÄ± vermeyi saÄŸlar. `@Secured` ve `@PreAuthorize` anotasyonlarÄ±, rol tabanlÄ± eriÅŸim kontrolÃ¼nÃ¼ gerÃ§ekleÅŸtirmede kullanÄ±lÄ±r.

```java
@Secured("ROLE_ADMIN")
public void adminOnlyMethod() {
    // YalnÄ±zca ROLE_ADMIN rolÃ¼ne sahip kullanÄ±cÄ±lar bu metodu Ã§aÄŸÄ±rabilir
}

@PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
public void userOrAdminMethod() {
    // ROLE_USER veya ROLE_ADMIN rolÃ¼ne sahip kullanÄ±cÄ±lar bu metodu Ã§aÄŸÄ±rabilir
}
```

### Spring Security ile HTTP GÃ¼venliÄŸi

Spring Security, HTTP tabanlÄ± gÃ¼venlik tehditlerine karÅŸÄ± koruma saÄŸlar. AÅŸaÄŸÄ±da, Spring Securityâ€™nin HTTP gÃ¼venliÄŸi kapsamÄ±nda saÄŸladÄ±ÄŸÄ± baÅŸlÄ±ca koruma mekanizmalarÄ± yer almaktadÄ±r:

1. **CSRF (Cross-Site Request Forgery)**: CSRF saldÄ±rÄ±larÄ±na karÅŸÄ± koruma saÄŸlar. CSRF, saldÄ±rganÄ±n kullanÄ±cÄ±nÄ±n oturumunu ele geÃ§irerek kullanÄ±cÄ± adÄ±na istek yapmasÄ±nÄ± saÄŸlayan bir saldÄ±rÄ± tÃ¼rÃ¼dÃ¼r. Spring Security, CSRF korumasÄ±nÄ± varsayÄ±lan olarak aktifleÅŸtirir.

2. **Clickjacking KorumasÄ±**: Spring Security, uygulamanÄ±n baÅŸka siteler tarafÄ±ndan Ã§erÃ§evelenmesini Ã¶nlemek iÃ§in X-Frame-Options baÅŸlÄ±ÄŸÄ±nÄ± kullanarak clickjacking saldÄ±rÄ±larÄ±na karÅŸÄ± koruma saÄŸlar.

3. **XSS KorumasÄ±**: XSS (Cross-Site Scripting) saldÄ±rÄ±larÄ±na karÅŸÄ± korunmak iÃ§in iÃ§erik gÃ¼venlik politikalarÄ± (Content Security Policies) uygulanabilir.

4. **HTTP Strict Transport Security (HSTS)**: HSTS, yalnÄ±zca HTTPS baÄŸlantÄ±larÄ±nÄ± zorunlu kÄ±larak veri aktarÄ±m gÃ¼venliÄŸini artÄ±rÄ±r.

### JWT ile Kimlik DoÄŸrulama ve Yetkilendirme

JWT, kullanÄ±cÄ± kimliÄŸini doÄŸrulamak ve API gÃ¼venliÄŸini saÄŸlamak iÃ§in popÃ¼ler bir yÃ¶ntemdir. JWT kullanÄ±ldÄ±ÄŸÄ±nda, kullanÄ±cÄ± giriÅŸ yaptÄ±ÄŸÄ±nda bir token Ã¼retilir ve bu token, sonraki isteklerde kimlik doÄŸrulamasÄ± iÃ§in kullanÄ±lÄ±r. Spring Security, JWT token ile kimlik doÄŸrulama iÅŸlemlerini kolayca yapÄ±landÄ±rma imkanÄ± sunar.

#### JWT Kimlik DoÄŸrulama Ã–rneÄŸi

JWT kullanarak kimlik doÄŸrulama yapÄ±lacak bir Ã¶rnek yapÄ±landÄ±rma ÅŸu ÅŸekildedir:

1. **JWT OluÅŸturma**: KullanÄ±cÄ± giriÅŸ yaptÄ±ÄŸÄ±nda, JWT token oluÅŸturulur ve istemciye dÃ¶ndÃ¼rÃ¼lÃ¼r.
2. **JWT DoÄŸrulama**: Ä°stemciden gelen her istekte, JWT doÄŸrulanarak kullanÄ±cÄ±nÄ±n kimliÄŸi belirlenir.

```java
// JWT oluÅŸturma ve doÄŸrulama iÅŸlemleri iÃ§in kullanÄ±lan sÄ±nÄ±f
public class JwtUtil {

    private String secretKey = "mySecretKey";

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10))
                .signWith(SignatureAlgorithm.HS256, secretKey)
                .compact();
    }

    public boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
}
```

### OAuth2 ve Spring Security

Spring Security, OAuth2 protokolÃ¼nÃ¼ destekleyerek Ã¼Ã§Ã¼ncÃ¼ taraf kimlik doÄŸrulama servisleriyle (Google, Facebook gibi) entegre Ã§alÄ±ÅŸabilir. OAuth

2, Ã¶zellikle kullanÄ±cÄ±larÄ±n aynÄ± hesapla farklÄ± uygulamalarda oturum aÃ§masÄ±nÄ± saÄŸlar ve API gÃ¼venliÄŸi iÃ§in de yaygÄ±n olarak kullanÄ±lÄ±r.

### Spring Security ile Test ve Hata YÃ¶netimi

Spring Security, gÃ¼venlik testlerini kolaylaÅŸtÄ±rmak iÃ§in `@WithMockUser`, `@WithUserDetails` gibi test anotasyonlarÄ± saÄŸlar. Bu anotasyonlar ile belirli roller ve yetkiler atanarak gÃ¼venlik testleri yapÄ±labilir.

```java
@Test
@WithMockUser(username = "admin", roles = {"ADMIN"})
public void testAdminAccess() {
    // ADMIN rolÃ¼yle test iÅŸlemleri yapÄ±lÄ±r
}
```

### Spring Securityâ€™nin AvantajlarÄ± ve DezavantajlarÄ±

**AvantajlarÄ±**:

- **YÃ¼ksek GÃ¼venlik DesteÄŸi**: Kimlik doÄŸrulama, yetkilendirme ve HTTP gÃ¼venliÄŸi saÄŸlar.
- **Esneklik**: LDAP, OAuth2, JWT gibi Ã§eÅŸitli kimlik doÄŸrulama protokolleri ile entegre Ã§alÄ±ÅŸabilir.
- **Kolay KonfigÃ¼rasyon**: XML veya Java tabanlÄ± konfigÃ¼rasyon seÃ§enekleri sunar.
- **ModÃ¼ler YapÄ±**: FarklÄ± gÃ¼venlik bileÅŸenlerinin ihtiyaca gÃ¶re eklenmesini saÄŸlar.

**DezavantajlarÄ±**:

- **Ã–ÄŸrenme EÄŸrisi**: Ä°lk kez kullananlar iÃ§in oldukÃ§a karmaÅŸÄ±k olabilir.
- **Performans Maliyeti**: GÃ¼venlik iÅŸlemleri ek yÃ¼k getirebilir, Ã¶zellikle bÃ¼yÃ¼k Ã¶lÃ§ekli uygulamalarda optimize edilmesi gerekebilir.

### SonuÃ§

Spring Security, uygulamalarda gÃ¼Ã§lÃ¼ bir gÃ¼venlik altyapÄ±sÄ± sunarak veri gizliliÄŸini ve gÃ¼venliÄŸini saÄŸlar. Kimlik doÄŸrulama, yetkilendirme ve HTTP gÃ¼venliÄŸi Ã¶zellikleriyle geniÅŸ kapsamlÄ± gÃ¼venlik ihtiyaÃ§larÄ±nÄ± karÅŸÄ±lar. Modern gÃ¼venlik standartlarÄ±nÄ± destekleyen Spring Security, web uygulamalarÄ± ve APIâ€™lerde gÃ¼venlik saÄŸlamak isteyen geliÅŸtiriciler iÃ§in ideal bir Ã§Ã¶zÃ¼mdÃ¼r.

Daha ayrÄ±ntÄ±lÄ± Ã¶rnekler veya belirli bir konuyla ilgili daha fazla bilgiye ihtiyacÄ±nÄ±z varsa, size yardÄ±mcÄ± olmaktan memnuniyet duyarÄ±m.

## ModelMapper
```sh 

```
---

ModelMapper, Java tabanlÄ± uygulamalarda veri nesneleri (model sÄ±nÄ±flarÄ±) arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerini kolaylaÅŸtÄ±ran bir kÃ¼tÃ¼phanedir. Ã–zellikle DTO (Data Transfer Object) ve Entity sÄ±nÄ±flarÄ± arasÄ±ndaki veri aktarÄ±mÄ±nÄ± otomatikleÅŸtirerek, kod tekrarÄ±nÄ± azaltÄ±r ve uygulamalarÄ±n daha temiz, sÃ¼rdÃ¼rÃ¼lebilir hale gelmesini saÄŸlar. DTO ve Entity nesneleri, genellikle veri tabanÄ±yla iletiÅŸim kuran veya kullanÄ±cÄ± arayÃ¼zÃ¼ne sunulan farklÄ± veri yapÄ±larÄ±nda temsil edilir. Bu nesneler arasÄ±nda veri aktarÄ±mÄ± gerektiren durumlarda, ModelMapper otomatik olarak gerekli eÅŸleÅŸtirmeleri yapar.

### ModelMapperâ€™Ä±n KullanÄ±m AmacÄ± ve FaydalarÄ±

1. **Kod TekrarÄ±nÄ± AzaltÄ±r**: DTO ve Entity sÄ±nÄ±flarÄ± arasÄ±nda veri aktarÄ±mÄ± yaparken her iki sÄ±nÄ±fÄ±n alanlarÄ±nÄ± manuel olarak eÅŸleÅŸtirmek gerekir. ModelMapper, bu eÅŸleÅŸtirmeyi otomatik hale getirerek kod tekrarÄ±nÄ± azaltÄ±r.

2. **Daha Temiz ve YÃ¶netilebilir Kod**: Otomatik eÅŸleÅŸtirme sayesinde veri dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemleri daha temiz bir kod yapÄ±sÄ± iÃ§inde yÃ¼rÃ¼tÃ¼lÃ¼r. Bu, Ã¶zellikle bÃ¼yÃ¼k projelerde yÃ¶netilebilirliÄŸi artÄ±rÄ±r.

3. **HÄ±zlÄ± GeliÅŸtirme**: ModelMapper, eÅŸleÅŸtirmeleri otomatik olarak gerÃ§ekleÅŸtirdiÄŸinden, veri dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri daha hÄ±zlÄ± yapÄ±lÄ±r ve geliÅŸtirme sÃ¼reci kÄ±salÄ±r.

4. **Esneklik ve Ã–zelleÅŸtirilebilirlik**: ModelMapper, belirli alanlarda manuel eÅŸleÅŸtirme ve Ã¶zelleÅŸtirme yapmayÄ± da destekler. Ã–zel gereksinimlere gÃ¶re eÅŸleÅŸtirme kurallarÄ± tanÄ±mlanabilir.

### ModelMapperâ€™Ä±n Temel Ã–zellikleri

ModelMapper, Ã¶zellikle alan adlarÄ± aynÄ± olan sÄ±nÄ±flar arasÄ±nda otomatik eÅŸleÅŸtirme yapmasÄ± ile bilinir. Bu eÅŸleÅŸtirme sÃ¼recinde, kaynak (source) nesne ile hedef (destination) nesne arasÄ±ndaki alanlarÄ±n isimleri ve tÃ¼rleri eÅŸleÅŸtirilir. ModelMapper, aynÄ± zamanda karmaÅŸÄ±k nesne yapÄ±larÄ± ve Ã¶zel dÃ¶nÃ¼ÅŸÃ¼mler iÃ§in de geniÅŸ bir yapÄ±landÄ±rma desteÄŸi sunar.

- **Otomatik EÅŸleÅŸtirme (Implicit Mapping)**: Alan adlarÄ± aynÄ± olan sÄ±nÄ±flar arasÄ±ndaki eÅŸleÅŸtirmeleri otomatik olarak yapar.
- **Ã–zelleÅŸtirilmiÅŸ EÅŸleÅŸtirme (Explicit Mapping)**: Belirli alanlar iÃ§in Ã¶zel dÃ¶nÃ¼ÅŸÃ¼m kurallarÄ± belirlenebilir.
- **Derin Kopyalama (Deep Copy)**: Nesneler iÃ§indeki alt nesneleri de otomatik olarak eÅŸleÅŸtirir ve derin kopyalama yapar.
- **Koleksiyon EÅŸleÅŸtirme**: Listeler ve diÄŸer koleksiyon tÃ¼rleri arasÄ±ndaki eÅŸleÅŸtirmeleri destekler.
- **KoÅŸullu EÅŸleÅŸtirme**: Belirli koÅŸullara gÃ¶re eÅŸleÅŸtirme kurallarÄ± tanÄ±mlanabilir.

### ModelMapper KullanÄ±mÄ±

ModelMapper kullanmak iÃ§in `ModelMapper` sÄ±nÄ±fÄ±nÄ±n bir Ã¶rneÄŸini oluÅŸturmak ve `map` metodunu Ã§aÄŸÄ±rarak kaynak nesneyi hedef nesneye dÃ¶nÃ¼ÅŸtÃ¼rmek yeterlidir. AÅŸaÄŸÄ±da basit bir Ã¶rnek gÃ¶sterilmektedir.

#### Basit Bir ModelMapper Ã–rneÄŸi

Ã–rneÄŸin, `User` ve `UserDTO` adlÄ± iki sÄ±nÄ±fÄ±mÄ±z olduÄŸunu dÃ¼ÅŸÃ¼nelim. `User` sÄ±nÄ±fÄ± veri tabanÄ±yla iliÅŸkili bir `Entity` iken, `UserDTO` sÄ±nÄ±fÄ± kullanÄ±cÄ± arayÃ¼zÃ¼nde kullanÄ±lan bir veri taÅŸÄ±ma nesnesidir.

```java
public class User {
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    // Getter ve Setter metotlarÄ±
}

public class UserDTO {
    private Long id;
    private String firstName;
    private String lastName;
    private String email;
    // Getter ve Setter metotlarÄ±
}
```

Bu iki sÄ±nÄ±f arasÄ±nda veri dÃ¶nÃ¼ÅŸÃ¼mÃ¼ yapmak iÃ§in ModelMapper kullanabiliriz:

```java
ModelMapper modelMapper = new ModelMapper();
User user = new User(1L, "John", "Doe", "john.doe@example.com");
UserDTO userDTO = modelMapper.map(user, UserDTO.class);

System.out.println("DTO First Name: " + userDTO.getFirstName());
System.out.println("DTO Email: " + userDTO.getEmail());
```

Bu Ã¶rnekte `user` nesnesinin tÃ¼m alanlarÄ± otomatik olarak `userDTO` nesnesine aktarÄ±lÄ±r. ModelMapper, alan adlarÄ± aynÄ± olduÄŸu sÃ¼rece, nesneler arasÄ±ndaki tÃ¼m veriyi sorunsuz bir ÅŸekilde eÅŸleÅŸtirir.

### Ã–zelleÅŸtirilmiÅŸ EÅŸleÅŸtirme

ModelMapper, Ã¶zel dÃ¶nÃ¼ÅŸÃ¼m kurallarÄ± tanÄ±mlamak iÃ§in geniÅŸ bir yapÄ±landÄ±rma desteÄŸi sunar. Ã–zellikle alan adlarÄ± farklÄ± olan sÄ±nÄ±flar veya karmaÅŸÄ±k nesne yapÄ±larÄ± arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmasÄ± gerektiÄŸinde, eÅŸleÅŸtirme kurallarÄ± belirlemek gerekir.

#### FarklÄ± Alan AdlarÄ± Ä°Ã§in EÅŸleÅŸtirme

Ã–rneÄŸin, `User` sÄ±nÄ±fÄ±ndaki `firstName` alanÄ±nÄ± `UserDTO` sÄ±nÄ±fÄ±nda `name` olarak adlandÄ±rdÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. Bu durumda, ModelMapperâ€™a `firstName` alanÄ±nÄ± `name` alanÄ±na eÅŸleÅŸtirmesini manuel olarak sÃ¶ylememiz gerekir.

```java
ModelMapper modelMapper = new ModelMapper();
modelMapper.typeMap(User.class, UserDTO.class).addMappings(mapper -> 
    mapper.map(User::getFirstName, UserDTO::setName));

User user = new User(1L, "John", "Doe", "john.doe@example.com");
UserDTO userDTO = modelMapper.map(user, UserDTO.class);

System.out.println("DTO Name: " + userDTO.getName());
```

Bu yapÄ±landÄ±rmada, `User` sÄ±nÄ±fÄ±ndaki `firstName` alanÄ± `UserDTO` sÄ±nÄ±fÄ±ndaki `name` alanÄ±na eÅŸleÅŸtirilir. `addMappings` metodu ile Ã¶zel eÅŸleÅŸtirme kurallarÄ± belirleyebiliriz.

### Koleksiyon EÅŸleÅŸtirme

ModelMapper, koleksiyon tÃ¼rlerini de dÃ¶nÃ¼ÅŸtÃ¼rebilir. Ã–zellikle listeler arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri, bÃ¼yÃ¼k veri setlerinde sÄ±klÄ±kla ihtiyaÃ§ duyulan bir Ã¶zelliktir.

```java
List<User> userList = Arrays.asList(new User(1L, "John", "Doe", "john@example.com"),
                                    new User(2L, "Jane", "Doe", "jane@example.com"));

Type listType = new TypeToken<List<UserDTO>>() {}.getType();
List<UserDTO> userDTOList = modelMapper.map(userList, listType);

userDTOList.forEach(userDTO -> System.out.println("DTO Name: " + userDTO.getFirstName()));
```

Bu Ã¶rnekte, `User` nesnelerinden oluÅŸan bir liste `UserDTO` nesnelerinden oluÅŸan bir listeye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmÃ¼ÅŸtÃ¼r.

### Derin Kopyalama (Deep Copy)

ModelMapper, nesneler arasÄ±ndaki alt nesneleri de eÅŸleÅŸtirerek derin kopyalama yapabilir. Ã–rneÄŸin, `Address` sÄ±nÄ±fÄ±na sahip bir `User` nesnesinin `UserDTO` nesnesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi durumunda, `Address` nesnesi de otomatik olarak eÅŸleÅŸtirilir.

```java
public class User {
    private Long id;
    private String firstName;
    private Address address;
    // Getter ve Setter metotlarÄ±
}

public class UserDTO {
    private Long id;
    private String firstName;
    private AddressDTO address;
    // Getter ve Setter metotlarÄ±
}

public class Address {
    private String street;
    private String city;
    // Getter ve Setter metotlarÄ±
}

public class AddressDTO {
    private String street;
    private String city;
    // Getter ve Setter metotlarÄ±
}

ModelMapper modelMapper = new ModelMapper();
User user = new User(1L, "John", new Address("Main St", "New York"));
UserDTO userDTO = modelMapper.map(user, UserDTO.class);

System.out.println("DTO City: " + userDTO.getAddress().getCity());
```

Bu Ã¶rnekte, `User` nesnesindeki `Address` nesnesi otomatik olarak `UserDTO` nesnesindeki `AddressDTO` nesnesine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r.

### KoÅŸullu EÅŸleÅŸtirme

ModelMapper, belirli bir koÅŸula gÃ¶re eÅŸleÅŸtirme yapÄ±lmasÄ±na da olanak tanÄ±r. Ã–rneÄŸin, belirli bir alanÄ±n boÅŸ olmamasÄ± durumunda eÅŸleÅŸtirme yapÄ±lmasÄ±nÄ± isteyebiliriz.

```java
modelMapper.getConfiguration().setPropertyCondition(Conditions.isNotNull());
```

Bu ayar ile, sadece `null` olmayan alanlar eÅŸleÅŸtirilir. Bu sayede kaynak nesnedeki boÅŸ alanlarÄ±n hedef nesneye aktarÄ±lmasÄ± engellenir.

### ModelMapper ile DTO ve Entity ArasÄ±ndaki DÃ¶nÃ¼ÅŸÃ¼mÃ¼n AvantajlarÄ± ve DezavantajlarÄ±

**AvantajlarÄ±**:

- **Kod BasitleÅŸtirir**: DÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri iÃ§in yazÄ±lmasÄ± gereken kod miktarÄ±nÄ± azaltÄ±r.
- **Esnek ve GÃ¼Ã§lÃ¼ YapÄ±landÄ±rma**: FarklÄ± durumlara gÃ¶re Ã¶zelleÅŸtirme yapÄ±labilir.
- **Koleksiyon EÅŸleÅŸtirme**: Listeler ve diÄŸer koleksiyon tÃ¼rleri iÃ§in dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerini kolaylaÅŸtÄ±rÄ±r.
- **Test Edilebilirlik**: DTO ve Entity arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri standart hale geldi
  ÄŸi iÃ§in daha test edilebilir bir yapÄ± sunar. Ã–rneÄŸin, tÃ¼m dÃ¶nÃ¼ÅŸÃ¼mler ModelMapper aracÄ±lÄ±ÄŸÄ±yla yapÄ±ldÄ±ÄŸÄ±ndan, dÃ¶nÃ¼ÅŸÃ¼m sÃ¼recinin doÄŸru Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ± tek bir noktada test edilebilir.

**DezavantajlarÄ±**:

- **Performans Maliyeti**: Ã–zellikle bÃ¼yÃ¼k veri setlerinde otomatik dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri performans aÃ§Ä±sÄ±ndan maliyetli olabilir. Bu durumda, ModelMapper yerine manuel dÃ¶nÃ¼ÅŸÃ¼m yÃ¶ntemleri tercih edilebilir.
- **Ã–ÄŸrenme EÄŸrisi**: ModelMapperâ€™Ä±n tÃ¼m Ã¶zelliklerini verimli kullanabilmek iÃ§in bir miktar Ã¶ÄŸrenme sÃ¼reci gerekebilir. Ã–zellikle karmaÅŸÄ±k nesne yapÄ±larÄ± ve Ã¶zelleÅŸtirilmiÅŸ dÃ¶nÃ¼ÅŸÃ¼mler iÃ§in ayrÄ±ntÄ±lÄ± bilgiye ihtiyaÃ§ duyulabilir.
- **Gereksiz EÅŸleÅŸtirmeler**: ModelMapper, tÃ¼m alanlarÄ± eÅŸleÅŸtirmeye Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in bazÄ± durumlarda gereksiz eÅŸleÅŸtirmeler yapÄ±labilir. Bu durumda belirli alanlarÄ± hariÃ§ tutmak gerekebilir.

### ModelMapperâ€™Ä±n Alternatifleri ve KarÅŸÄ±laÅŸtÄ±rma

ModelMapper, Java dÃ¼nyasÄ±nda popÃ¼ler bir kÃ¼tÃ¼phane olmakla birlikte, aynÄ± iÅŸlevi gÃ¶ren bazÄ± alternatifleri de vardÄ±r. Bu alternatifler arasÄ±nda Dozer, MapStruct ve Orika gibi kÃ¼tÃ¼phaneler Ã¶ne Ã§Ä±kar.

- **MapStruct**: ModelMapperâ€™dan farklÄ± olarak derleme zamanÄ±nda (compile-time) dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerini gerÃ§ekleÅŸtirir. Bu sayede daha hÄ±zlÄ± Ã§alÄ±ÅŸÄ±r, Ã§Ã¼nkÃ¼ dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri Ã§alÄ±ÅŸma zamanÄ±nda yapÄ±lmaz. Ã–zellikle bÃ¼yÃ¼k projelerde performans avantajÄ± saÄŸlar.
- **Dozer**: Dozer de otomatik eÅŸleÅŸtirme yapabilen bir kÃ¼tÃ¼phanedir ancak ModelMapper kadar esnek yapÄ±landÄ±rma sunmaz.
- **Orika**: Orika, bÃ¼yÃ¼k veri setleri iÃ§in optimize edilmiÅŸtir ve hÄ±zlÄ± dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri yapabilir.

ModelMapper, Ã¶zellikle kullanÄ±m kolaylÄ±ÄŸÄ± ve esnek yapÄ±landÄ±rma seÃ§enekleri sayesinde kÃ¼Ã§Ã¼k ve orta Ã¶lÃ§ekli projelerde daha sÄ±k tercih edilirken, MapStruct performans avantajÄ± sayesinde bÃ¼yÃ¼k projelerde daha yaygÄ±n olarak kullanÄ±lÄ±r.

### ModelMapper YapÄ±landÄ±rma Ã–zellikleri

ModelMapperâ€™Ä±n sunduÄŸu bazÄ± yapÄ±landÄ±rma Ã¶zellikleri ÅŸunlardÄ±r:

1. **EÅŸleÅŸtirme Stratejileri**: EÅŸleÅŸtirme stratejileri, ModelMapperâ€™Ä±n nasÄ±l Ã§alÄ±ÅŸacaÄŸÄ±nÄ± belirler. Ã–rneÄŸin, standart eÅŸleÅŸtirme stratejisi `STANDARD` iken, daha esnek bir eÅŸleÅŸtirme iÃ§in `LOOSE` stratejisi kullanÄ±labilir. `LOOSE` stratejisi, kÃ¼Ã§Ã¼k farklÄ±lÄ±klarÄ± gÃ¶z ardÄ± ederek eÅŸleÅŸtirme yapmaya Ã§alÄ±ÅŸÄ±r.

    ```java
    modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.LOOSE);
    ```

2. **BoÅŸ AlanlarÄ± HariÃ§ Tutma**: BoÅŸ (null) deÄŸerleri eÅŸleÅŸtirme iÅŸleminden hariÃ§ tutmak iÃ§in `setPropertyCondition` yapÄ±landÄ±rmasÄ± kullanÄ±labilir.

    ```java
    modelMapper.getConfiguration().setPropertyCondition(Conditions.isNotNull());
    ```

3. **KarmaÅŸÄ±k EÅŸleÅŸtirme**: KarmaÅŸÄ±k nesne yapÄ±larÄ± iÃ§in `TypeMap` kullanÄ±larak daha ayrÄ±ntÄ±lÄ± dÃ¶nÃ¼ÅŸÃ¼m kurallarÄ± oluÅŸturulabilir.

    ```java
    TypeMap<User, UserDTO> typeMap = modelMapper.createTypeMap(User.class, UserDTO.class);
    typeMap.addMappings(mapper -> mapper.map(src -> src.getAddress().getCity(), UserDTO::setCity));
    ```

Bu Ã¶rnekte, `User` nesnesindeki `address.city` alanÄ± `UserDTO` nesnesindeki `city` alanÄ±na eÅŸleÅŸtirilmektedir.

### Spring Boot ile ModelMapper Entegrasyonu

Spring Boot projelerinde ModelMapper kullanÄ±mÄ± oldukÃ§a yaygÄ±ndÄ±r. ModelMapper, Spring konteynerÄ±na bir `@Bean` olarak eklenir ve proje genelinde kullanÄ±labilir hale getirilir.

```java
@Configuration
public class ModelMapperConfig {
    
    @Bean
    public ModelMapper modelMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
        return modelMapper;
    }
}
```

Bu yapÄ±landÄ±rma ile `ModelMapper` nesnesi `@Autowired` anotasyonu ile diÄŸer sÄ±nÄ±flara enjekte edilebilir. Bu sayede, uygulamanÄ±n farklÄ± katmanlarÄ±nda dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri iÃ§in ModelMapper kolayca kullanÄ±labilir.

```java
@Service
public class UserService {

    @Autowired
    private ModelMapper modelMapper;

    public UserDTO convertToDto(User user) {
        return modelMapper.map(user, UserDTO.class);
    }

    public User convertToEntity(UserDTO userDTO) {
        return modelMapper.map(userDTO, User.class);
    }
}
```

Bu yapÄ±landÄ±rma sayesinde, `UserService` sÄ±nÄ±fÄ± iÃ§inde `convertToDto` ve `convertToEntity` metotlarÄ± ile `User` ve `UserDTO` arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemleri kolayca yapÄ±labilir.

### SonuÃ§

ModelMapper, Java tabanlÄ± uygulamalarda veri transfer nesneleri (DTO) ve veri tabanÄ± nesneleri (Entity) arasÄ±ndaki dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerini kolaylaÅŸtÄ±rmak iÃ§in gÃ¼Ã§lÃ¼ ve esnek bir araÃ§tÄ±r. Otomatik eÅŸleÅŸtirme, derin kopyalama, koÅŸullu eÅŸleÅŸtirme gibi Ã¶zellikleriyle veri dÃ¶nÃ¼ÅŸÃ¼mlerini hÄ±zlÄ±, kolay ve sÃ¼rdÃ¼rÃ¼lebilir hale getirir. Kod tekrarÄ±nÄ± azaltarak daha temiz ve yÃ¶netilebilir bir kod yapÄ±sÄ± saÄŸlar.

ModelMapper, Ã¶zellikle veri modelleme ve DTO katmanÄ±nÄ±n yoÄŸun olarak kullanÄ±ldÄ±ÄŸÄ± projelerde tercih edilir. Ancak bÃ¼yÃ¼k projelerde performans kaygÄ±larÄ± olan durumlarda alternatif kÃ¼tÃ¼phaneler de deÄŸerlendirilmelidir. Spring Boot ile entegre edilmesi kolaydÄ±r ve Spring konteynerÄ±nda bir `@Bean` olarak tanÄ±mlanarak proje genelinde kullanÄ±labilir.

DetaylÄ± veya Ã¶zel dÃ¶nÃ¼ÅŸÃ¼m senaryolarÄ±nda ModelMapperâ€™Ä±n sunduÄŸu yapÄ±landÄ±rma Ã¶zelliklerinden faydalanarak karmaÅŸÄ±k veri modelleri arasÄ±nda hÄ±zlÄ± dÃ¶nÃ¼ÅŸÃ¼mler gerÃ§ekleÅŸtirilebilir. ModelMapperâ€™Ä±n saÄŸladÄ±ÄŸÄ± esneklik, Ã¶zelleÅŸtirilebilirlik ve basit kullanÄ±mÄ±, onu Java ekosistemindeki popÃ¼ler araÃ§lardan biri yapmaktadÄ±r.



## ModelMapper kullanÄ±rken dikkat etmeniz gereken bazÄ± kurallar
```sh 

```
---


ModelMapper kullanÄ±rken dikkat etmeniz gereken bazÄ± kurallar ve en iyi uygulamalar vardÄ±r. Bu kurallar, ModelMapperâ€™Ä±n performansÄ±nÄ± optimize etmek, dÃ¶nÃ¼ÅŸÃ¼m sÃ¼recini hatasÄ±z ve daha anlaÅŸÄ±lÄ±r hale getirmek iÃ§in Ã¶nemlidir. Ä°ÅŸte dikkat edilmesi gereken bazÄ± temel kurallar:

### 1. **Matching Strategy (EÅŸleÅŸtirme Stratejisi) SeÃ§imine Dikkat Edin**
- ModelMapper, varsayÄ±lan olarak `STANDARD` eÅŸleÅŸtirme stratejisini kullanÄ±r. Bu strateji, alan adlarÄ±nÄ±n tamamen eÅŸleÅŸmesini bekler ve kÃ¼Ã§Ã¼k harf-farklÄ±lÄ±klarÄ±nÄ± veya alt sÄ±nÄ±f yapÄ±larÄ± gÃ¶z ardÄ± etmez.
- EÄŸer alan adlarÄ±nda kÃ¼Ã§Ã¼k farklÄ±lÄ±klar varsa veya daha esnek bir eÅŸleÅŸtirme gerekiyorsa `LOOSE` stratejisini kullanabilirsiniz. Ancak `LOOSE` stratejisi daha esnektir ve yanlÄ±ÅŸ eÅŸleÅŸtirme yapma ihtimali daha yÃ¼ksektir.
- Ã–neri: MÃ¼mkÃ¼nse `STRICT` veya `STANDARD` stratejisini kullanarak eÅŸleÅŸtirme doÄŸruluÄŸunu artÄ±rÄ±n.

   ```java
   modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
   ```

### 2. **BoÅŸ (null) AlanlarÄ± HariÃ§ Tutma**
- VarsayÄ±lan olarak, ModelMapper tÃ¼m alanlarÄ± eÅŸleÅŸtirmeye Ã§alÄ±ÅŸÄ±r. Ancak bazÄ± durumlarda, `null` olan alanlarÄ± hedef nesneye taÅŸÄ±mak istemeyebilirsiniz. Ã–rneÄŸin, gÃ¼ncelleme iÅŸlemlerinde boÅŸ alanlarÄ±n eski deÄŸerleri deÄŸiÅŸtirmemesi gerekebilir.
- `isNotNull` koÅŸulunu kullanarak `null` deÄŸerleri hariÃ§ tutabilirsiniz.

   ```java
   modelMapper.getConfiguration().setPropertyCondition(Conditions.isNotNull());
   ```

### 3. **EÅŸleÅŸtirilecek AlanlarÄ±n AdlarÄ±nÄ±n TutarlÄ± OlmasÄ±na Ã–zen GÃ¶sterin**
- ModelMapper, alan adlarÄ±nÄ± temel alarak otomatik eÅŸleÅŸtirme yapar. Bu yÃ¼zden kaynak (source) ve hedef (destination) nesneler arasÄ±ndaki alan adlarÄ±nÄ±n tutarlÄ± olmasÄ± Ã¶nemlidir.
- FarklÄ± adlandÄ±rÄ±lmÄ±ÅŸ alanlar arasÄ±nda eÅŸleÅŸtirme yapmanÄ±z gerektiÄŸinde, `TypeMap` veya `addMappings` kullanarak Ã¶zelleÅŸtirme yapabilirsiniz.

   ```java
   modelMapper.typeMap(User.class, UserDTO.class).addMappings(mapper -> 
       mapper.map(User::getFirstName, UserDTO::setName));
   ```

### 4. **KarmaÅŸÄ±k ve BÃ¼yÃ¼k Nesneler Ä°Ã§in EÅŸleÅŸtirmeyi BasitleÅŸtirin**
- BÃ¼yÃ¼k nesneler ve Ã§ok katmanlÄ± yapÄ±lar ModelMapper ile eÅŸleÅŸtirildiÄŸinde performans sorunlarÄ± yaÅŸanabilir. Bu durumda yalnÄ±zca ihtiyacÄ±nÄ±z olan alanlarÄ± eÅŸleÅŸtirmeye Ã¶zen gÃ¶sterin.
- Ã–zellikle karmaÅŸÄ±k nesne yapÄ±larÄ±nda, alt nesneler arasÄ±nda yapÄ±lan derin kopyalama iÅŸlemleri (deep copy) performans kaybÄ±na yol aÃ§abilir. Gereksiz eÅŸleÅŸtirmelerden kaÃ§Ä±nÄ±n.

### 5. **Koleksiyonlar Ä°Ã§in TÃ¼r Belirlemesi YapÄ±n**
- ModelMapper, koleksiyon tÃ¼rleri arasÄ±nda dÃ¶nÃ¼ÅŸÃ¼m yaparken tÃ¼r bilgisine ihtiyaÃ§ duyar. Koleksiyonlar iÃ§in dÃ¶nÃ¼ÅŸÃ¼m yaparken tÃ¼r bilgilerini `TypeToken` ile belirtin.
- Ã–rneÄŸin, `List<User>` nesnesini `List<UserDTO>` nesnesine dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `TypeToken` kullanmak Ã¶nemlidir.

   ```java
   Type listType = new TypeToken<List<UserDTO>>() {}.getType();
   List<UserDTO> userDTOList = modelMapper.map(userList, listType);
   ```

### 6. **DTO ve Entity SÄ±nÄ±flarÄ±nda Fazla Alan KullanmayÄ±n**
- DTO (Data Transfer Object) ve Entity sÄ±nÄ±flarÄ±nda yalnÄ±zca ihtiyacÄ±nÄ±z olan alanlarÄ± kullanÄ±n. Fazla ve gereksiz alanlar, dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerini karmaÅŸÄ±klaÅŸtÄ±rabilir ve hatalara yol aÃ§abilir.
- AyrÄ±ca, her iki sÄ±nÄ±fta aynÄ± iÅŸlevi gÃ¶ren alanlarÄ±n adlarÄ±nÄ±n uyumlu olmasÄ±na dikkat edin.

### 7. **Mapping YapÄ±sÄ±nÄ± Test Edin**
- Ã–zellikle karmaÅŸÄ±k dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerinde, ModelMapperâ€™Ä±n doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olmak iÃ§in birim testler yazÄ±n.
- Testler, eÅŸleÅŸtirmenin beklendiÄŸi gibi yapÄ±ldÄ±ÄŸÄ±nÄ± doÄŸrulamanÄ±za yardÄ±mcÄ± olur. Ã–rneÄŸin, `assertEquals` kullanarak kaynak ve hedef nesnelerdeki alanlarÄ±n doÄŸru ÅŸekilde eÅŸleÅŸtirildiÄŸini kontrol edebilirsiniz.

   ```java
   @Test
   public void testUserToUserDtoMapping() {
       ModelMapper modelMapper = new ModelMapper();
       User user = new User(1L, "John", "Doe", "john@example.com");
       UserDTO userDTO = modelMapper.map(user, UserDTO.class);

       assertEquals(user.getFirstName(), userDTO.getFirstName());
       assertEquals(user.getEmail(), userDTO.getEmail());
   }
   ```

### 8. **PerformansÄ± Ä°zleyin**
- ModelMapper, Ã§alÄ±ÅŸma zamanÄ±nda eÅŸleÅŸtirme yaptÄ±ÄŸÄ± iÃ§in Ã¶zellikle bÃ¼yÃ¼k veri setleri Ã¼zerinde Ã§alÄ±ÅŸÄ±rken performans sorunlarÄ± yaÅŸanabilir.
- Performans kritik uygulamalarda alternatif dÃ¶nÃ¼ÅŸÃ¼m kÃ¼tÃ¼phanelerini (Ã¶rneÄŸin, MapStruct) deÄŸerlendirebilirsiniz.

### 9. **Ã–zelleÅŸtirilmiÅŸ EÅŸleÅŸtirmeler Ä°Ã§in TypeMap KullanÄ±mÄ±**
- KarmaÅŸÄ±k dÃ¶nÃ¼ÅŸÃ¼mler veya farklÄ± adlandÄ±rma durumlarÄ±nda `TypeMap` kullanarak Ã¶zel eÅŸleÅŸtirmeler tanÄ±mlayabilirsiniz.
- `TypeMap`, belirli dÃ¶nÃ¼ÅŸÃ¼mler iÃ§in yapÄ±landÄ±rmalarÄ± saklar ve performans aÃ§Ä±sÄ±ndan daha avantajlÄ±dÄ±r.

   ```java
   TypeMap<User, UserDTO> typeMap = modelMapper.createTypeMap(User.class, UserDTO.class);
   typeMap.addMappings(mapper -> mapper.map(User::getAddress, UserDTO::setUserAddress));
   ```

### 10. **GerekmedikÃ§e Derin EÅŸleÅŸtirmelerden KaÃ§Ä±nÄ±n**
- ModelMapper varsayÄ±lan olarak derin eÅŸleÅŸtirme yapar, yani alt nesneleri de eÅŸleÅŸtirir. Ancak, tÃ¼m alt nesnelerin dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi her zaman gerekmeyebilir.
- Derin eÅŸleÅŸtirmenin kapatÄ±lmasÄ± gereken durumlarda `modelMapper.getConfiguration().setDeepCopyEnabled(false);` ayarÄ±nÄ± kullanabilirsiniz.

### 11. **EÅŸleÅŸtirme Ã‡akÄ±ÅŸmalarÄ±nÄ± Ã–nleyin**
- AynÄ± kaynak sÄ±nÄ±fÄ± farklÄ± hedef sÄ±nÄ±flara dÃ¶nÃ¼ÅŸtÃ¼rmek istediÄŸinizde, `TypeMap` kullanarak her dÃ¶nÃ¼ÅŸÃ¼m iÃ§in ayrÄ± bir yapÄ±landÄ±rma tanÄ±mlayÄ±n. Bu, ModelMapperâ€™Ä±n Ã§akÄ±ÅŸan dÃ¶nÃ¼ÅŸÃ¼m yapÄ±landÄ±rmalarÄ±nÄ± Ã¶nlemesini saÄŸlar.
- AynÄ± tÃ¼rde iki farklÄ± hedef nesneye dÃ¶nÃ¼ÅŸÃ¼m yapÄ±lmasÄ± gerektiÄŸinde, her dÃ¶nÃ¼ÅŸÃ¼m iÃ§in Ã¶zel `TypeMap` tanÄ±mlarÄ± kullanarak dÃ¶nÃ¼ÅŸÃ¼mleri yÃ¶netebilirsiniz.

### 12. **@Configuration SÄ±nÄ±fÄ± ile Merkezi KonfigÃ¼rasyon SaÄŸlayÄ±n**
- Ã–zellikle Spring Boot projelerinde ModelMapperâ€™Ä± merkezi bir yapÄ±landÄ±rma sÄ±nÄ±fÄ±nda `@Bean` olarak tanÄ±mlayÄ±n ve tÃ¼m uygulama genelinde aynÄ± `ModelMapper` nesnesini kullanÄ±n.
- Merkezi bir konfigÃ¼rasyon, kodun yÃ¶netilebilirliÄŸini artÄ±rÄ±r ve tek bir noktadan tÃ¼m ModelMapper yapÄ±landÄ±rmalarÄ±nÄ± deÄŸiÅŸtirme imkanÄ± sunar.

   ```java
   @Configuration
   public class ModelMapperConfig {
       
       @Bean
       public ModelMapper modelMapper() {
           ModelMapper modelMapper = new ModelMapper();
           modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.STRICT);
           return modelMapper;
       }
   }
   ```

### SonuÃ§

ModelMapper, veri dÃ¶nÃ¼ÅŸÃ¼mlerini hÄ±zlÄ± ve kolay hale getiren gÃ¼Ã§lÃ¼ bir kÃ¼tÃ¼phanedir. Ancak, Ã¶zellikle bÃ¼yÃ¼k projelerde veya karmaÅŸÄ±k veri modellerinde bazÄ± performans ve yapÄ±landÄ±rma sorunlarÄ± yaÅŸanabilir. Bu yÃ¼zden yukarÄ±daki kurallara dikkat etmek, ModelMapperâ€™Ä±n daha verimli kullanÄ±lmasÄ±nÄ± saÄŸlar. Ã–zellikle `MatchingStrategy` seÃ§imi, `TypeMap` ile Ã¶zelleÅŸtirme, koleksiyon tÃ¼rlerinin belirlenmesi ve gereksiz derin eÅŸleÅŸtirmelerden kaÃ§Ä±nma gibi kurallar, ModelMapperâ€™Ä±n iÅŸlevselliÄŸini artÄ±rÄ±r ve dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemlerinin daha gÃ¼venli ve hÄ±zlÄ± olmasÄ±nÄ± saÄŸlar.

Dikkat etmeniz gereken bu kurallar sayesinde ModelMapperâ€™Ä± daha verimli kullanabilir ve veri dÃ¶nÃ¼ÅŸtÃ¼rme iÅŸlemlerini yÃ¶netilebilir bir yapÄ±ya kavuÅŸturabilirsiniz.

## Lombok
```sh 

```
---
Lombok, Java geliÅŸtiricilerinin daha az kod yazarak daha okunabilir ve bakÄ±m yapÄ±labilir kodlar geliÅŸtirmesini saÄŸlamak amacÄ±yla kullanÄ±lan bir kÃ¼tÃ¼phanedir. Java dilinde, getter ve setter metodlarÄ±, `toString()`, `equals()`, `hashCode()`, constructor (yapÄ±cÄ± metodlar) gibi birÃ§ok tekrarlayan kod yazmak gerekmektedir. Lombok, bu tarz kodlarÄ± otomatik olarak oluÅŸturarak, geliÅŸtiricinin kod tekrarÄ±nÄ± azaltmasÄ±nÄ± saÄŸlar ve kodu daha temiz hale getirir.

### Lombokâ€™un AmacÄ± ve FaydalarÄ±

1. **Kod TekrarÄ±nÄ± AzaltÄ±r**: Lombok, Java dilinde sÄ±kÃ§a yazÄ±lan getter/setter, constructor gibi metotlarÄ± otomatik oluÅŸturur. Bu, Ã¶zellikle bÃ¼yÃ¼k projelerde kod tekrarÄ±nÄ± azaltÄ±r ve kodun daha okunabilir hale gelmesini saÄŸlar.

2. **Daha Temiz ve Okunabilir Kod**: Lombok, sÄ±nÄ±flarÄ±n sadece iÅŸ mantÄ±ÄŸÄ±nÄ± iÃ§ermesini saÄŸlar. Gereksiz metotlar ve alanlar yerine, sadece anotasyonlarla bu iÅŸlemler yapÄ±labilir, bu da kodu daha sade hale getirir.

3. **Daha HÄ±zlÄ± GeliÅŸtirme**: Tekrarlayan kod yazmak yerine, Lombok anotasyonlarÄ± kullanÄ±larak hÄ±zlÄ± bir ÅŸekilde sÄ±nÄ±flar tanÄ±mlanabilir. Lombok, boilerplate kod olarak bilinen ve defalarca yazÄ±lmasÄ± gereken yapÄ±larÄ± ortadan kaldÄ±rarak zamandan tasarruf saÄŸlar.

### Lombok Kurulumu

Lombok, Java projelerine Maven veya Gradle baÄŸÄ±mlÄ±lÄ±ÄŸÄ± eklenerek kolayca entegre edilebilir.

Maven ile kurulum:

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.20</version>
    <scope>provided</scope>
</dependency>
```

Gradle ile kurulum:

```gradle
implementation 'org.projectlombok:lombok:1.18.20'
```

Eklendikten sonra, Lombok kullanÄ±labilir hale gelir ve projeye dahil edilen anotasyonlar, kod derlendiÄŸinde otomatik olarak ilgili metotlarÄ± oluÅŸturur.

### Lombokâ€™un BaÅŸlÄ±ca AnotasyonlarÄ± ve KullanÄ±mÄ±

Lombok, farklÄ± iÅŸlemleri gerÃ§ekleÅŸtiren birÃ§ok anotasyona sahiptir. Her anotasyonun kendine Ã¶zgÃ¼ iÅŸlevi vardÄ±r ve uygun yerlerde kullanÄ±ldÄ±ÄŸÄ±nda kodu oldukÃ§a sadeleÅŸtirir.

#### 1. `@Getter` ve `@Setter`

`@Getter` ve `@Setter` anotasyonlarÄ±, sÄ±nÄ±f iÃ§indeki alanlar iÃ§in getter ve setter metodlarÄ±nÄ± otomatik olarak oluÅŸturur. Bu anotasyonlar, Ã¶zellikle POJO (Plain Old Java Object) sÄ±nÄ±flarÄ±nda yaygÄ±n olarak kullanÄ±lÄ±r.

```java
import lombok.Getter;
import lombok.Setter;

public class User {
    @Getter @Setter
    private Long id;
    
    @Getter @Setter
    private String name;
}
```

Bu Ã¶rnekte, `id` ve `name` alanlarÄ± iÃ§in getter ve setter metotlarÄ± otomatik olarak oluÅŸturulur. Lombok sayesinde, bu metotlarÄ± manuel olarak yazmak zorunda kalmazsÄ±nÄ±z.

#### 2. `@ToString`

`@ToString` anotasyonu, `toString()` metodunu otomatik olarak oluÅŸturur. Bu metot, nesnenin tÃ¼m alanlarÄ±nÄ± veya belirtilen alanlarÄ±nÄ± iÃ§eren bir `String` temsilini dÃ¶ndÃ¼rÃ¼r.

```java
import lombok.ToString;

@ToString
public class User {
    private Long id;
    private String name;
}
```

Bu anotasyon, `User` nesnesi iÃ§in `toString()` metodunu oluÅŸturur ve id ve name alanlarÄ±nÄ±n deÄŸerlerini dÃ¶ndÃ¼rÃ¼r. AyrÄ±ca `exclude` parametresi ile `toString()` metodunda yer almasÄ±nÄ± istemediÄŸiniz alanlarÄ± belirleyebilirsiniz:

```java
@ToString(exclude = "id")
public class User {
    private Long id;
    private String name;
}
```

Bu durumda, `toString()` metodu `id` alanÄ±nÄ± hariÃ§ tutarak sadece `name` alanÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.

#### 3. `@EqualsAndHashCode`

`@EqualsAndHashCode` anotasyonu, `equals()` ve `hashCode()` metodlarÄ±nÄ± otomatik olarak oluÅŸturur. Bu metotlar, nesnelerin eÅŸitliÄŸini kontrol etmek ve nesneleri bir hash tablosunda saklamak iÃ§in kullanÄ±lÄ±r.

```java
import lombok.EqualsAndHashCode;

@EqualsAndHashCode
public class User {
    private Long id;
    private String name;
}
```

Bu anotasyon, `User` sÄ±nÄ±fÄ± iÃ§in `equals()` ve `hashCode()` metodlarÄ±nÄ± oluÅŸturur. `onlyExplicitlyIncluded` parametresi ile belirli alanlarÄ±n eÅŸitlik kontrolÃ¼ne dahil edilmesi saÄŸlanabilir.

#### 4. `@NoArgsConstructor`, `@AllArgsConstructor`, ve `@RequiredArgsConstructor`

- **@NoArgsConstructor**: Parametresiz bir yapÄ±cÄ± metod (constructor) oluÅŸturur.
- **@AllArgsConstructor**: SÄ±nÄ±ftaki tÃ¼m alanlar iÃ§in bir yapÄ±cÄ± metod oluÅŸturur.
- **@RequiredArgsConstructor**: Sadece `final` ve `@NonNull` olarak iÅŸaretlenmiÅŸ alanlar iÃ§in bir yapÄ±cÄ± metod oluÅŸturur.

```java
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;

@NoArgsConstructor
@AllArgsConstructor
@RequiredArgsConstructor
public class User {
    private Long id;
    private final String name;
}
```

Bu Ã¶rnekte, `User` sÄ±nÄ±fÄ± iÃ§in parametresiz, tÃ¼m alanlarÄ± iÃ§eren ve sadece `name` alanÄ±nÄ± zorunlu kÄ±lan yapÄ±cÄ± metodlar oluÅŸturulacaktÄ±r.

#### 5. `@Data`

`@Data` anotasyonu, `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode` ve `@RequiredArgsConstructor` anotasyonlarÄ±nÄ± tek bir yerde toplar. Genellikle veri taÅŸÄ±ma nesnelerinde (DTO) kullanÄ±lÄ±r.

```java
import lombok.Data;

@Data
public class User {
    private Long id;
    private String name;
}
```

Bu anotasyon, `User` sÄ±nÄ±fÄ± iÃ§in tÃ¼m getter/setter, `toString()`, `equals()`, `hashCode()` ve final alanlar iÃ§in bir yapÄ±cÄ± metod oluÅŸturur.

#### 6. `@Builder`

`@Builder` anotasyonu, sÄ±nÄ±fÄ±n bir builder deseni ile oluÅŸturulmasÄ±nÄ± saÄŸlar. Bu, Ã¶zellikle Ã§ok sayÄ±da parametreye sahip nesnelerin daha okunabilir bir ÅŸekilde oluÅŸturulmasÄ±na olanak tanÄ±r.

```java
import lombok.Builder;

@Builder
public class User {
    private Long id;
    private String name;
}
```

Bu anotasyon, `User` sÄ±nÄ±fÄ± iÃ§in bir builder oluÅŸturur. `User` nesnesi aÅŸaÄŸÄ±daki gibi oluÅŸturulabilir:

```java
User user = User.builder()
                .id(1L)
                .name("John Doe")
                .build();
```

#### 7. `@Value`

`@Value` anotasyonu, immutable (deÄŸiÅŸmez) sÄ±nÄ±flar oluÅŸturmak iÃ§in kullanÄ±lÄ±r. TÃ¼m alanlar `final` olur ve sÄ±nÄ±fÄ±n getter metotlarÄ± ile `toString()`, `equals()`, `hashCode()` metotlarÄ± otomatik olarak oluÅŸturulur.

```java
import lombok.Value;

@Value
public class User {
    Long id;
    String name;
}
```

Bu sÄ±nÄ±fÄ±n `id` ve `name` alanlarÄ± deÄŸiÅŸtirilemez hale gelir, sadece okuma yapÄ±labilir.

#### 8. `@NonNull`

`@NonNull` anotasyonu, bir alanÄ±n null olamayacaÄŸÄ±nÄ± belirtir. Bu anotasyon ile iÅŸaretlenen alan null olarak verilirse, `NullPointerException` fÄ±rlatÄ±lÄ±r.

```java
import lombok.NonNull;

public class User {
    private Long id;
    
    @NonNull
    private String name;
}
```

Bu Ã¶rnekte, `name` alanÄ±na null deÄŸer atanÄ±rsa, Ã§alÄ±ÅŸma zamanÄ±nda bir `NullPointerException` meydana gelir.

### Lombok KullanÄ±rken Dikkat Edilmesi Gerekenler

1. **Kodun AnlaÅŸÄ±labilirliÄŸi**: Lombok kodu otomatik oluÅŸturduÄŸu iÃ§in, kodu inceleyen birinin hangi metotlarÄ±n mevcut olduÄŸunu anlamasÄ± zorlaÅŸabilir. Ã–zellikle `@Data`, `@Builder` gibi anotasyonlar kullanÄ±lan sÄ±nÄ±flarda, IDE yardÄ±mÄ±yla kodu incelemek faydalÄ± olur.

2. **EÅŸitlik ve Hash Kodu**: `@EqualsAndHashCode` anotasyonunu kullanÄ±rken dikkatli olun. EÅŸitlik ve hash kodu, nesnelerin karÅŸÄ±laÅŸtÄ±rÄ±lmasÄ±nda ve hash tablosunda saklanmasÄ±nda Ã¶nemli rol oynar. EÅŸitlik kontrollerini belirli alanlarla sÄ±nÄ±rlandÄ±rmanÄ±z gerekiyorsa `@EqualsAndHashCode` ile bu alanlarÄ± tanÄ±mlayÄ±n.

3. **Performans KaygÄ±larÄ±**: Lombokâ€™un tÃ¼m alanlar iÃ§in getter/setter oluÅŸturmasÄ± her durumda gerekli olmayabilir. Gereksiz metotlar performans kaygÄ±larÄ±na neden olabilir. Sadece ihtiyaÃ§ duyulan anotasyonlarÄ± kullanmaya Ã¶zen gÃ¶sterin.

4. **IDE DesteÄŸi**: Lombok, IDEA veya Eclipse gibi IDE'lerde desteklenir, ancak IDE Ã¼zerinde ek bir eklenti yÃ¼klemek gerekebilir. Lombok'un tam olarak Ã§alÄ±ÅŸabilmesi iÃ§in IDE'ye Lombok eklentisi kurmalÄ±sÄ±nÄ±z.

5. **Immutable SÄ±nÄ±flar Ä°Ã§in @Value Kullanabilirsiniz. `@Value` anotasyonu, immutable (deÄŸiÅŸtirilemez) sÄ±nÄ±flar oluÅŸturmak iÃ§in Lombokâ€™un saÄŸladÄ±ÄŸÄ± bir kolaylÄ±ktÄ±r. `@Value` anotasyonu kullanÄ±ldÄ±ÄŸÄ±nda sÄ±nÄ±fÄ±n tÃ¼m alanlarÄ± otomatik olarak `final` ve private olur; ayrÄ±ca sÄ±nÄ±fa getter metotlarÄ±, `toString()`, `equals()` ve `hashCode()` metotlarÄ± eklenir. Bu, sÄ±nÄ±fÄ±n deÄŸiÅŸmezliÄŸini saÄŸlar ve veri taÅŸÄ±ma nesneleri (DTO) veya sabit veri yapÄ±larÄ± iÃ§in oldukÃ§a uygun hale getirir.

```java
import lombok.Value;

@Value
public class User {
    Long id;
    String name;
}
```

Bu Ã¶rnekte `User` sÄ±nÄ±fÄ±, `@Value` anotasyonu ile iÅŸaretlendiÄŸinden, oluÅŸturulduktan sonra deÄŸiÅŸtirilemez hale gelir. `id` ve `name` alanlarÄ±na ilk deÄŸer atandÄ±ktan sonra bu alanlarÄ±n deÄŸeri deÄŸiÅŸtirilemez. BÃ¶ylece `User` sÄ±nÄ±fÄ± immutable bir sÄ±nÄ±f haline gelir ve daha gÃ¼venli bir yapÄ± sunar.

### Lombok ile Ä°lgili DiÄŸer Ã–nemli Anotasyonlar

#### 1. `@SneakyThrows`
`@SneakyThrows` anotasyonu, checked exception (kontrollÃ¼ istisnalar) kullanÄ±mÄ±nÄ± basitleÅŸtirir. Javaâ€™da genellikle checked exceptionâ€™lar (IOException, SQLException gibi) `try-catch` bloklarÄ± iÃ§inde yakalanmak zorundadÄ±r. Ancak `@SneakyThrows` ile bu zorunluluk ortadan kaldÄ±rÄ±labilir.

```java
import lombok.SneakyThrows;

public class FileReaderExample {

    @SneakyThrows
    public void readFile(String fileName) {
        FileReader fileReader = new FileReader(fileName);
        // Dosya okuma iÅŸlemleri
    }
}
```

Bu Ã¶rnekte, `FileReader` normalde `FileNotFoundException` fÄ±rlatÄ±r ve `try-catch` bloÄŸu gerektirir. Ancak `@SneakyThrows`, bu istisnayÄ± method imzasÄ±nda belirtmeden kullanmamÄ±za olanak tanÄ±r. **Dikkat edilmesi gereken nokta:** `@SneakyThrows` kullanÄ±mÄ±, checked exceptionâ€™larÄ±n gÃ¶zden kaÃ§masÄ±na yol aÃ§abilir; bu yÃ¼zden dikkatli kullanÄ±lmalÄ±dÄ±r.

#### 2. `@Accessors`
`@Accessors` anotasyonu, getter ve setter metodlarÄ±nÄ±n isimlendirme yapÄ±sÄ±nÄ± deÄŸiÅŸtirmemize olanak tanÄ±r. Normalde getter/setter metotlarÄ± `getField()` ve `setField()` ÅŸeklinde isimlendirilir. Ancak `@Accessors(fluent = true)` kullanarak, alan adÄ±nÄ± doÄŸrudan getter/setter metodu olarak kullanabilirsiniz.

```java
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;

@Getter
@Setter
@Accessors(fluent = true)
public class User {
    private Long id;
    private String name;
}
```

Bu durumda `user.getName()` yerine `user.name()` ve `user.setName("John")` yerine `user.name("John")` yazabilirsiniz. `@Accessors(chain = true)` ise, setter metotlarÄ±nÄ±n zincirleme (chaining) kullanÄ±mÄ±na izin verir. Bu sayede daha akÄ±cÄ± bir yapÄ± saÄŸlanÄ±r.

```java
user.id(1L).name("John");
```

#### 3. `@NonNull`
`@NonNull` anotasyonu, null deÄŸerlerin kabul edilmediÄŸi alanlarÄ± belirtir. Bu anotasyon `null` bir deÄŸer atanmaya Ã§alÄ±ÅŸÄ±ldÄ±ÄŸÄ±nda otomatik olarak `NullPointerException` fÄ±rlatÄ±r. Ã–zellikle gÃ¼venli veri iÅŸlemlerinde faydalÄ±dÄ±r.

```java
import lombok.NonNull;

public class User {

    private Long id;
    
    @NonNull
    private String name;
}
```

Bu Ã¶rnekte, `name` alanÄ± `null` olarak atanÄ±rsa `NullPointerException` oluÅŸur. `@NonNull`, Ã¶zellikle zorunlu alanlarÄ±n belirlenmesi ve gÃ¼venli hale getirilmesinde yardÄ±mcÄ± olur.

### Lombok KullanÄ±rken Dikkat Edilmesi Gereken Ã–nemli Noktalar

1. **Kod BakÄ±mÄ± ve Okunabilirlik**: Lombok, kodu oldukÃ§a sadeleÅŸtirir, ancak aynÄ± zamanda metotlarÄ± gÃ¶rÃ¼nmez hale getirdiÄŸi iÃ§in kodun anlaÅŸÄ±lmasÄ±nÄ± zorlaÅŸtÄ±rabilir. TakÄ±m Ã§alÄ±ÅŸmasÄ± yapÄ±lan projelerde, Ã¶zellikle projeye yeni katÄ±lan geliÅŸtiricilerin kodu anlamasÄ± daha uzun sÃ¼rebilir.

2. **Kodun Derleme AÅŸamasÄ±nda Ãœretilmesi**: Lombok anotasyonlarÄ±, derleme zamanÄ±nda (compile-time) metotlarÄ± ekler, bu nedenle IDE tarafÄ±ndan her zaman doÄŸru bir ÅŸekilde tanÄ±nmayabilir. IDE desteÄŸinin saÄŸlanabilmesi iÃ§in Lombok eklentisinin yÃ¼klenmiÅŸ olmasÄ± gerekir.

3. **Performans ve Gereksizlikten KaÃ§Ä±nma**: Lombok tÃ¼m alanlar iÃ§in getter/setter metodlarÄ± veya tÃ¼m alanlarÄ± iÃ§eren `toString()` metodunu otomatik olarak oluÅŸturur. Bu nedenle, yalnÄ±zca gerÃ§ekten ihtiyaÃ§ duyulan metotlarÄ± ve anotasyonlarÄ± kullanmak daha performanslÄ± bir yapÄ± sunar.

4. **Immutable SÄ±nÄ±flar iÃ§in @Value KullanÄ±mÄ±**: Immutable (deÄŸiÅŸmez) sÄ±nÄ±flar, veri gÃ¼venliÄŸi aÃ§Ä±sÄ±ndan tercih edilir. `@Value` anotasyonu ile oluÅŸturulan immutable sÄ±nÄ±flar, eÅŸzamanlÄ± (concurrent) iÅŸlemlerde veri tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸlar. Ancak mutable (deÄŸiÅŸebilir) olmasÄ± gereken sÄ±nÄ±flarda `@Value` kullanmaktan kaÃ§Ä±nÄ±lmalÄ±dÄ±r.

5. **Test ve Hata AyÄ±klama**: Lombokâ€™un oluÅŸturduÄŸu metotlar Ã§alÄ±ÅŸma zamanÄ±nda hataya yol aÃ§arsa, bu hatalarÄ± bulmak zor olabilir. Bu yÃ¼zden Lombok kullanÄ±rken yazdÄ±ÄŸÄ±nÄ±z sÄ±nÄ±flarÄ± iyi test etmek, beklenmedik hatalarÄ±n Ã¶nÃ¼ne geÃ§mek aÃ§Ä±sÄ±ndan Ã¶nemlidir.

6. **Ã–zel Durumlara Dikkat**: Lombok bazÄ± Ã¶zel durumlarda (Ã¶rneÄŸin, karmaÅŸÄ±k yapÄ±lÄ± sÄ±nÄ±flar veya bÃ¼yÃ¼k veri yapÄ±larÄ± gibi) beklenmedik performans sorunlarÄ±na yol aÃ§abilir. Ã–zellikle Ã§ok sayÄ±da alan iÃ§eren veya derin yapÄ±daki nesneler iÃ§in performans optimizasyonuna dikkat edilmelidir.

### Lombokâ€™un SaÄŸladÄ±ÄŸÄ± Genel Avantaj ve Dezavantajlar

#### Avantajlar

- **Kod TekrarÄ±nÄ± AzaltÄ±r**: Lombokâ€™un anotasyonlarÄ± sayesinde sÄ±nÄ±flarda sÄ±kÃ§a yazÄ±lmasÄ± gereken kodlar otomatik olarak oluÅŸturulur. Bu sayede kod tekrarÄ±ndan kaÃ§Ä±nÄ±lÄ±r.
- **Daha Az Kod, Daha Fazla Okunabilirlik**: Lombok, sÄ±nÄ±flarÄ± daha anlaÅŸÄ±lÄ±r hale getirir. Ã–zellikle `@Data` gibi anotasyonlar ile tÃ¼m temel metotlar tek bir satÄ±rda oluÅŸturulabilir.
- **Kolay Entegrasyon**: Lombok, Maven veya Gradle projelerine kolayca eklenebilir ve IDEâ€™ler ile uyumludur.

#### Dezavantajlar

- **IDE BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**: Lombok, IDE tarafÄ±ndan otomatik olarak tanÄ±nmayabilir, bu yÃ¼zden ek bir eklentiye ihtiyaÃ§ duyar.
- **BakÄ±m ZorluÄŸu**: Lombokâ€™un otomatik olarak Ã¼rettiÄŸi kodlar sÄ±nÄ±fÄ±n iÃ§inde gÃ¶rÃ¼nmez olduÄŸu iÃ§in, sÄ±nÄ±fÄ±n davranÄ±ÅŸÄ±nÄ± anlamak zor olabilir.
- **Performans Maliyetleri**: Lombok, Ã¶zellikle `toString()`, `equals()`, `hashCode()` gibi metodlarÄ± karmaÅŸÄ±k yapÄ±lar iÃ§in otomatik olarak oluÅŸtururken performans kaybÄ±na yol aÃ§abilir.
- **Standartlara BaÄŸÄ±mlÄ±lÄ±k**: Lombok, Java'nÄ±n standart bir kÃ¼tÃ¼phanesi deÄŸildir. Proje baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ±n artmasÄ± bazÄ± kurumsal projelerde kabul edilmeyebilir.

### SonuÃ§

Lombok, Java projelerinde boilerplate kod olarak bilinen, sÄ±kÃ§a tekrar eden yapÄ±larÄ± otomatik olarak oluÅŸturarak kodu sadeleÅŸtirir, geliÅŸtirme hÄ±zÄ±nÄ± artÄ±rÄ±r ve kodun daha okunabilir olmasÄ±nÄ± saÄŸlar. `@Data`, `@Builder`, `@Value`, `@Getter` ve `@Setter` gibi anotasyonlarÄ± sayesinde Java projelerinde bÃ¼yÃ¼k kolaylÄ±k saÄŸlar.

Ancak Lombokâ€™un kullanÄ±mÄ±, bazÄ± durumlarda karmaÅŸÄ±klaÅŸabilir ve takÄ±m Ã§alÄ±ÅŸmasÄ± yapÄ±lan projelerde dikkatli kullanÄ±lmalÄ±dÄ±r. Kodun anlaÅŸÄ±labilirliÄŸi, performans ve bakÄ±m aÃ§Ä±sÄ±ndan Lombokâ€™un saÄŸladÄ±ÄŸÄ± avantajlarÄ± ve potansiyel dezavantajlarÄ± deÄŸerlendirerek kullanmak en doÄŸru yaklaÅŸÄ±m olacaktÄ±r.

Lombokâ€™un Ã¶zelliklerinden en iyi ÅŸekilde faydalanmak iÃ§in ihtiyaca gÃ¶re doÄŸru anotasyonlarÄ± kullanmaya Ã¶zen gÃ¶sterin ve her anotasyonun kullanÄ±m amacÄ±nÄ± iyi anlayÄ±n. Kodunuzun sÃ¼rdÃ¼rÃ¼lebilirliÄŸini saÄŸlamak iÃ§in Lombok ile yazÄ±lan sÄ±nÄ±flarÄ± iyi test etmeyi unutmayÄ±n.



## Spring Boot (@PostConstruct)
```sh 

```
---

#### 1. **`@PostConstruct` Anotasyonu:**
- **Ne yapar?** Bu metodun, sÄ±nÄ±fÄ±n tÃ¼m baÄŸÄ±mlÄ±lÄ±klarÄ± atandÄ±ktan sonra Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±nÄ± saÄŸlar.
- Yani, `springData()` metodu, sÄ±nÄ±fÄ±n diÄŸer bileÅŸenleri veya baÄŸÄ±mlÄ±lÄ±klarÄ± (Ã¶rneÄŸin, `apiResult` gibi) Spring tarafÄ±ndan hazÄ±r hale getirildikten sonra Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r.
- **Neden kullanÄ±lÄ±r?** EÄŸer belirli bir nesne veya deÄŸiÅŸken (Ã¶rneÄŸin `apiResult`) sÄ±nÄ±f baÅŸlatÄ±ldÄ±ÄŸÄ±nda otomatik olarak baÅŸlatÄ±lmak isteniyorsa,
- bu anotasyon kullanÄ±lÄ±r. BÃ¶ylece her seferinde constructorâ€™da veya manuel olarak baÅŸlatmak zorunda kalmazsÄ±nÄ±z.

#### 2. **`apiResult = new ApiResult();`**
- **Ne yapar?** `springData()` metodu Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda, `apiResult` nesnesi yeni bir `ApiResult` Ã¶rneÄŸi olarak baÅŸlatÄ±lÄ±r.
- Bu sayede sÄ±nÄ±fÄ±n diÄŸer metotlarÄ± bu `apiResult` Ã¶rneÄŸini kullanabilir.
- **BaÄŸlam:** `apiResult` burada bir sÄ±nÄ±f deÄŸiÅŸkeni (instance variable) olarak tanÄ±mlanmÄ±ÅŸtÄ±r.
- EÄŸer bu deÄŸiÅŸkenin baÅŸlatÄ±lmasÄ± gerekiyorsa, `@PostConstruct` anotasyonu ile baÄŸÄ±mlÄ±lÄ±klarÄ±n atandÄ±ktan hemen sonra bu iÅŸlemi gerÃ§ekleÅŸtirebilirsiniz.

### Ã–zet:
- **`@PostConstruct`**, Spring tarafÄ±ndan yÃ¶netilen bir sÄ±nÄ±fÄ±n yaÅŸam dÃ¶ngÃ¼sÃ¼nde constructor'dan sonra,
- ancak diÄŸer metodlarÄ±n Ã§aÄŸrÄ±lmasÄ±ndan Ã¶nce Ã§alÄ±ÅŸtÄ±rÄ±lacak bir metodu belirtir.
- Bu anotasyon ile sÄ±nÄ±fÄ±n ilk kurulum aÅŸamasÄ±nda gerekli hazÄ±rlÄ±klarÄ± yapmak iÃ§in kullanÄ±labilir,
- Ã¶rneÄŸin: veri baÅŸlatma, baÄŸlantÄ± kurma ya da deÄŸiÅŸkenlere ilk deÄŸer atama gibi iÅŸlemler.



---
## GET attributes
@GetMapping(
name = "/addres_list_name",
value = "/list",
//path = "/list2"
params = "active=true",
consumes = "application/json",
produces = "application/json",
headers = "X-API-VERSION=1"
)
@Override
public ResponseEntity<List<AddressDto>> addressApiList() {
return ResponseEntity.status(HttpStatus.OK).body(iAddressService.addressServiceList());
}

Bu komutta kullanÄ±lan `@GetMapping` anotasyonu, Spring Framework'deki RESTful API geliÅŸtirme iÅŸlemlerinde kullanÄ±lan bir anotasyondur. Bu anotasyon, bir HTTP GET isteÄŸine yanÄ±t veren bir metodun yapÄ±landÄ±rÄ±lmasÄ±nÄ± saÄŸlar. Kodda verilen her bir Ã¶zelliÄŸi (attribute) detaylÄ± bir ÅŸekilde inceleyip, nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± ve ne anlama geldiÄŸini aÃ§Ä±klayacaÄŸÄ±m. AyrÄ±ca, her bir Ã¶zelliÄŸin API'nin nasÄ±l Ã§alÄ±ÅŸmasÄ±nÄ± etkilediÄŸini de ayrÄ±ntÄ±lÄ± olarak aÃ§Ä±klayacaÄŸÄ±m.

### Komut:
```java
@GetMapping(
    name = "/addres_list_name",
    value = "/list",
    path = "/list",
    params = "active=true",
    consumes = "application/json",
    produces = "application/xml",
    headers = "X-API-VERSION=1"
)
@Override
public ResponseEntity<List<AddressDto>> addressApiList() {
    return ResponseEntity.status(HttpStatus.OK).body(iAddressService.addressServiceList());
}
```

## KÄ±saca
    /*
    Ä°ÅŸte `@GetMapping` anotasyonundaki parametrelerin kÄ±sa ve madde madde aÃ§Ä±klamalarÄ±:

1. **`name`:**
    - Metoda bir isim verir (genellikle iÃ§sel kullanÄ±m iÃ§indir, dÄ±ÅŸarÄ±dan gÃ¶rÃ¼nmez).
    - Ã–rnek: `name = "/address_list_name"`

2. **`value`:**
    - GET isteÄŸinin URL yolunu belirtir (endpoint).
    - Ã–rnek: `value = "/list"`

3. **`path`:**
    - `value` ile aynÄ± iÅŸlevi gÃ¶rÃ¼r, endpoint yolunu belirtir.
    - Ã–rnek: `path = "/list2"`

4. **`params`:**
    - GET isteÄŸinde belirli bir query parametresinin bulunmasÄ±nÄ± zorunlu kÄ±lar.
    - Ã–rnek: `params = "active=true"`
    - EndPoint: http://lcaolhost:4444/list?active=true

5. **`consumes`:**
    - Ä°stek veri formatÄ±nÄ± (Content-Type) belirtir, sadece bu formatta gelen verileri kabul eder.
    - Ã–rnek: `consumes = "application/json"`

6. **`produces`:**
    - YanÄ±t veri formatÄ±nÄ± belirtir, API'nin dÃ¶neceÄŸi formatÄ± tanÄ±mlar.
    - Ã–rnek: `produces = "application/json"`
    - - Ã–rnek: `produces = "application/xml"`

7. **`headers`:**
    - Ä°stek baÅŸlÄ±ÄŸÄ±nda (header) belirli bir bilginin bulunmasÄ±nÄ± zorunlu kÄ±lar.
    - Ã–rnek: `headers = "X-API-VERSION=1"`
      */
## name attribute Ã¶rnek vermek
"Bu isim, Spring'in dahili mekanizmasÄ±nda kullanÄ±labilir" ifadesi, Spring'in kendi yapÄ±sÄ±nda bu ismi referans olarak kullanabileceÄŸi anlamÄ±na gelir.
Ancak, bu isim dÄ±ÅŸarÄ±ya gÃ¶rÃ¼nmez, yani API'yi Ã§aÄŸÄ±ran istemciler bu ismi gÃ¶rmez veya bilmezler.
Bu isim, genellikle Spring'in iÃ§sel iÅŸlemlerinde, logging (kayÄ±t tutma), izleme veya debugging (hata ayÄ±klama) gibi durumlarda kullanÄ±labilir.

### Ã–rnek:
Spring uygulamanÄ±zda birden fazla endpoint olabilir ve her birine `name` Ã¶zelliÄŸi ile benzersiz isimler verebilirsiniz. Bu isimler, Ã¶zellikle monitoring (izleme) veya hata ayÄ±klama araÃ§larÄ± tarafÄ±ndan kullanÄ±labilir.

#### KullanÄ±m Senaryosu:
1. **Ä°zleme ve Debugging:** UygulamanÄ±z bir monitoring aracÄ± ile izleniyorsa, belirli bir endpoint'in adÄ± bu araÃ§larda kolayca gÃ¶rÃ¼ntÃ¼lenebilir ve loglarda daha anlaÅŸÄ±lÄ±r bir bilgi saÄŸlar.

2. **Logging:** LoglarÄ±nÄ±zda hangi metodun hangi isimle Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nÄ± belirtmek isteyebilirsiniz. Ã–rneÄŸin, hata aldÄ±ÄŸÄ±nÄ±zda bu endpoint'e verilen isim loglarda gÃ¶zÃ¼kebilir.

### Ã–rnek:
```java
@GetMapping(
    name = "getAddressListEndpoint",
    value = "/list",
    produces = "application/json"
)
public ResponseEntity<List<AddressDto>> addressApiList() {
    log.info("Calling the endpoint: getAddressListEndpoint");
    return ResponseEntity.ok(iAddressService.addressServiceList());
}
```

Bu Ã¶rnekte, `log.info("Calling the endpoint: getAddressListEndpoint");` satÄ±rÄ±, bu endpoint'e yapÄ±lan Ã§aÄŸrÄ±larÄ±n loglanmasÄ±nÄ± saÄŸlar. Loglarda bu metodun adÄ± `getAddressListEndpoint` olarak gÃ¶rÃ¼nÃ¼r. Bu, metodun ne iÅŸe yaradÄ±ÄŸÄ±nÄ± anlamayÄ± kolaylaÅŸtÄ±rÄ±r.

### Spring Actuator ile KullanÄ±m:
EÄŸer Spring Actuator kullanÄ±yorsanÄ±z, uygulamanÄ±zÄ±n `name` ile tanÄ±mlanmÄ±ÅŸ metodlarÄ±nÄ± izleme veya raporlama araÃ§larÄ±yla daha anlamlÄ± hale getirebilirsiniz.

```bash
curl http://localhost:8080/actuator/mappings
```

Bu komutla, Spring Actuator Ã¼zerinde tanÄ±mlÄ± tÃ¼m endpoint'leri gÃ¶rebilirsiniz ve bu noktada `name` ile verilmiÅŸ isimler bu mapping bilgisi iÃ§inde gÃ¶rÃ¼nÃ¼r.

### `@GetMapping` Anotasyonunun AyrÄ±ntÄ±lÄ± AÃ§Ä±klamasÄ±:
Spring Framework'de `@GetMapping` anotasyonu, bir HTTP GET isteÄŸini belirli bir metoda eÅŸlemek iÃ§in kullanÄ±lÄ±r.
Bu metoda gelen GET isteÄŸi, `value` ve diÄŸer koÅŸullara gÃ¶re doÄŸru URL'ye ve isteklere yÃ¶nlendirilir.

#### 1. **`name`:**
```java
name = "/addres_list_name"
```
- **AÃ§Ä±klama:** `name` Ã¶zelliÄŸi, Spring'in dahili kullanÄ±mÄ±nda metodlara bir referans ismi vermek iÃ§in kullanÄ±lÄ±r. Normalde bu isim dÄ±ÅŸarÄ±ya yansÄ±tÄ±lmaz ve kullanÄ±cÄ±nÄ±n gÃ¶remeyeceÄŸi bir Ã¶zelliktir.
- **AnlamÄ±:** Bu metot iÃ§in bir isim tanÄ±mlanmÄ±ÅŸtÄ±r: "/addres_list_name". Bu, proje iÃ§inde Spring'in bu metodu izleyebilmesi ve gerektiÄŸinde referans verebilmesi iÃ§in kullanÄ±labilir.
- **KullanÄ±mÄ±:** Ã–zellikle bÃ¼yÃ¼k projelerde, belirli metodlara referans vermek ve metodlarÄ±n izlenebilirliÄŸini artÄ±rmak iÃ§in faydalÄ±dÄ±r.
- Ancak genellikle kÃ¼Ã§Ã¼k projelerde bu Ã¶zelliÄŸin kullanÄ±mÄ± zorunlu deÄŸildir ve isteÄŸe baÄŸlÄ±dÄ±r.

#### 2. **`value`:**
```java
value = "/list"
```
- **AÃ§Ä±klama:** `value` Ã¶zelliÄŸi, GET isteÄŸinin URL yolunu tanÄ±mlar.
- Bu, istemcinin hangi URL'ye istek yapacaÄŸÄ±nÄ± belirleyen temel yoldur.
- **AnlamÄ±:** `/list` olarak belirlenen bu URL, istemcinin `http://localhost:4444/api/address/list` adresine GET isteÄŸi yaparak bu metoda ulaÅŸmasÄ±nÄ± saÄŸlar.
- UygulamanÄ±n Ã§alÄ±ÅŸtÄ±ÄŸÄ± kÃ¶k URL ve sÄ±nÄ±f dÃ¼zeyinde tanÄ±mlanan yol (muhtemelen `/api/address`) bu yolun tam halini belirler.
- **KullanÄ±mÄ±:** Ä°stemci, bu API'ye eriÅŸmek istediÄŸinde `http://localhost:4444/api/address/list` yoluna bir GET isteÄŸi yapar.
- Bu URL, servise dÄ±ÅŸarÄ±dan eriÅŸim iÃ§in kapÄ± gÃ¶revi gÃ¶rÃ¼r.

#### 3. **`params`:**
```java
params = "active=true"
```
- **AÃ§Ä±klama:** `params` Ã¶zelliÄŸi, HTTP isteÄŸinin belirli bir query parametresini iÃ§ermesi gerektiÄŸini belirtir. Burada, URL'de belirli parametreler bulunmasÄ± zorunlu kÄ±lÄ±nmÄ±ÅŸtÄ±r.
- **AnlamÄ±:** API Ã§aÄŸrÄ±sÄ± yapÄ±lÄ±rken, URL'de `active=true` query parametresi olmalÄ±dÄ±r. Ã–rneÄŸin: `http://localhost:4444/api/address/list?active=true` ÅŸeklinde bir GET isteÄŸi yapÄ±lmasÄ± gerekir.
- EÄŸer bu parametre belirtilmezse veya deÄŸeri farklÄ± olursa, istek bu metoda yÃ¶nlendirilmez.
- **KullanÄ±mÄ±:** `params` Ã¶zelliÄŸi ile aynÄ± endpoint'e farklÄ± parametreler gÃ¶ndererek farklÄ± iÅŸlemler gerÃ§ekleÅŸtirebiliriz.
- Parametre kontrolÃ¼, isteÄŸin doÄŸru metodla eÅŸleÅŸmesini saÄŸlar.

#### 4. **`consumes`:**
```java
consumes = "application/json"
```
- **AÃ§Ä±klama:** `consumes` Ã¶zelliÄŸi, API'ye gÃ¶nderilecek olan isteÄŸin veri formatÄ±nÄ± belirtir.
- Yani bu metod, yalnÄ±zca belirli bir formatta (bu Ã¶rnekte `application/json`) gÃ¶nderilen istekleri kabul eder.
- **AnlamÄ±:** Bu API, sadece JSON formatÄ±ndaki verileri kabul eder.
- Bu, istemcinin isteÄŸi yaparken `Content-Type: application/json` baÅŸlÄ±ÄŸÄ± ile veri gÃ¶ndermesi gerektiÄŸi anlamÄ±na gelir.
- EÄŸer istek baÅŸka bir formatta (Ã¶rneÄŸin XML) gÃ¶nderilirse, API bunu iÅŸleyemez ve 415 (Unsupported Media Type) hatasÄ± dÃ¶ner.
- **KullanÄ±mÄ±:** `consumes` Ã¶zelliÄŸi, API'nin yalnÄ±zca belirli formatta veri almasÄ±nÄ± saÄŸlamak iÃ§in kullanÄ±lÄ±r.
- Genellikle JSON (`application/json`), XML (`application/xml`), veya form verisi (`application/x-www-form-urlencoded`) formatlarÄ±yla Ã§alÄ±ÅŸÄ±r.

#### 5. **`produces`:**
```java
produces = "application/json"
```
- **AÃ§Ä±klama:** `produces` Ã¶zelliÄŸi, bu metodun istemciye hangi formatta yanÄ±t dÃ¶ndÃ¼receÄŸini belirtir.
- Bu durumda, API JSON formatÄ±nda bir yanÄ±t dÃ¶ndÃ¼recektir.
- **AnlamÄ±:** YanÄ±t, `application/json` formatÄ±nda dÃ¶necektir. Ä°stemci bu endpoint'i Ã§aÄŸÄ±rÄ±rken `Accept: application/json` baÅŸlÄ±ÄŸÄ±nÄ± ekleyebilir ve yanÄ±tÄ±n JSON formatÄ±nda olduÄŸunu bilmelidir.
- EÄŸer istemci farklÄ± bir format beklerse (Ã¶rneÄŸin XML), 406 (Not Acceptable) hatasÄ± dÃ¶nebilir.
- **KullanÄ±mÄ±:** Bu Ã¶zellik, API'nin belirli bir formatta yanÄ±t dÃ¶ndÃ¼rmesini zorunlu kÄ±lar.
- JSON, XML, HTML gibi farklÄ± formatlar arasÄ±nda seÃ§im yapabilirsiniz.

#### 6. **`headers`:**
```java
headers = "X-API-VERSION=1"
```
- **AÃ§Ä±klama:** `headers` Ã¶zelliÄŸi, HTTP isteÄŸinde belirli bir baÅŸlÄ±ÄŸÄ±n (header) bulunmasÄ±nÄ± zorunlu kÄ±lar.
- Bu Ã¶rnekte, `X-API-VERSION` baÅŸlÄ±ÄŸÄ± kullanÄ±lmaktadÄ±r.
- **AnlamÄ±:** Bu API'yi Ã§aÄŸÄ±rÄ±rken HTTP isteÄŸine `X-API-VERSION: 1` baÅŸlÄ±ÄŸÄ± eklenmelidir.
- Bu genellikle API versiyonlamasÄ± iÃ§in kullanÄ±lÄ±r.
- Ä°stemci bu baÅŸlÄ±ÄŸÄ± gÃ¶ndermezse ya da farklÄ± bir deÄŸer gÃ¶nderirse, bu metot Ã§alÄ±ÅŸmaz ve genellikle 400 (Bad Request) veya 404 (Not Found) hatasÄ± dÃ¶nebilir.
- **KullanÄ±mÄ±:** `headers` Ã¶zelliÄŸi, API versiyonlama, gÃ¼venlik veya farklÄ± ihtiyaÃ§lar doÄŸrultusunda isteklere eklenen baÅŸlÄ±klarÄ± kontrol etmek iÃ§in kullanÄ±lÄ±r.
- Versiyonlamada API'nin farklÄ± sÃ¼rÃ¼mlerini desteklemek iÃ§in baÅŸlÄ±klar sÄ±kÃ§a kullanÄ±lÄ±r.

### Metodun GÃ¶vdesi:
```java
@Override
public ResponseEntity<List<AddressDto>> addressApiList() {
    return ResponseEntity.status(HttpStatus.OK).body(iAddressService.addressServiceList());
}
```
#### 1. **`@Override`:**
- **AÃ§Ä±klama:** Bu anotasyon, bir metotun Ã¼st sÄ±nÄ±fta veya bir interface'de tanÄ±mlandÄ±ÄŸÄ±nÄ± ve burada tekrar tanÄ±mlandÄ±ÄŸÄ±nÄ± belirtir. Bu, metodun bir interface olan `IAddressApi`'dan alÄ±ndÄ±ÄŸÄ±nÄ± gÃ¶sterir.
- **AnlamÄ±:** Bu metot, `IAddressApi` interfaceâ€™inde tanÄ±mlanmÄ±ÅŸ olmalÄ±dÄ±r. Bu, Spring'te Interface-Implementation iliÅŸkisini saÄŸlar.

#### 2. **`ResponseEntity`:**
- **AÃ§Ä±klama:** `ResponseEntity`, HTTP yanÄ±tlarÄ±nÄ± dÃ¶ndÃ¼rmek iÃ§in kullanÄ±lan bir sÄ±nÄ±ftÄ±r.
- YanÄ±tÄ±n durum kodu ve gÃ¶vdesi gibi HTTP yanÄ±tÄ± ile ilgili tÃ¼m bilgileri iÃ§erir.
- **AnlamÄ±:** Bu metod, HTTP yanÄ±tÄ± olarak bir liste dÃ¶ndÃ¼rÃ¼r (`List<AddressDto>`).
- Bu liste, Spring'in HTTP yanÄ±tÄ± olarak iÅŸleyebileceÄŸi ÅŸekilde paketlenir.
- AyrÄ±ca, yanÄ±t durum kodu olarak `HttpStatus.OK` (200) belirlenmiÅŸtir.
- **KullanÄ±mÄ±:** `ResponseEntity`, API yanÄ±tÄ±nÄ±n durum kodunu (`HttpStatus`), baÅŸlÄ±klarÄ±nÄ± ve gÃ¶vdesini kontrol etmek iÃ§in gÃ¼Ã§lÃ¼ bir yapÄ± saÄŸlar.
- YanÄ±tÄ±n gÃ¶vdesi burada `iAddressService.addressServiceList()` tarafÄ±ndan saÄŸlanan veri olacaktÄ±r.

#### 3. **`iAddressService.addressServiceList()`:**
- **AÃ§Ä±klama:** Bu, `iAddressService` adÄ±nda bir servis tarafÄ±ndan saÄŸlanan bir metottur.
- `addressServiceList()` metodu, adresleri listeleyen bir servis Ã§aÄŸrÄ±sÄ±dÄ±r.
- **AnlamÄ±:** Bu servis Ã§aÄŸrÄ±sÄ±, adresleri (`AddressDto`) iÃ§eren bir liste dÃ¶ndÃ¼rÃ¼r ve bu liste API'ye yanÄ±t olarak istemciye iletilir.
- **KullanÄ±mÄ±:** Servis katmanÄ±nda iÅŸ mantÄ±ÄŸÄ± genellikle burada yapÄ±lÄ±r.
- Bu, veritabanÄ± veya baÅŸka bir kaynaktan verilerin alÄ±nmasÄ±nÄ± ve iÅŸlenmesini saÄŸlar. Burada iÅŸlenen veri, API yanÄ±tÄ± olarak dÃ¶ndÃ¼rÃ¼lecektir.

### APIâ€™nin NasÄ±l Ã‡alÄ±ÅŸacaÄŸÄ±:
Bu metod, `http://localhost:4444/api/address/list` URL'sine yapÄ±lan GET isteklerini karÅŸÄ±lar. Ancak bu

isteÄŸin Ã§alÄ±ÅŸabilmesi iÃ§in birkaÃ§ koÅŸul vardÄ±r:

1. **URL Parametresi:** Ä°stek, `active=true` query parametresini iÃ§ermelidir. Ã–rneÄŸin: `http://localhost:4444/api/address/list?active=true`.
2. **BaÅŸlÄ±klar (Headers):** HTTP isteÄŸi, `X-API-VERSION: 1` baÅŸlÄ±ÄŸÄ±nÄ± iÃ§ermelidir. Bu, API'nin doÄŸru versiyonuna eriÅŸtiÄŸinizi garanti eder.
3. **Ä°Ã§erik Tipi (Content-Type):** Ä°stek verisi JSON formatÄ±nda olmalÄ±dÄ±r, yani `Content-Type: application/json` baÅŸlÄ±ÄŸÄ± ile gÃ¶nderilmelidir.
4. **YanÄ±t FormatÄ± (Produces):** YanÄ±t JSON formatÄ±nda dÃ¶ndÃ¼rÃ¼lecektir. Ä°stemci, bu yanÄ±tÄ± alacaksa `Accept: application/json` baÅŸlÄ±ÄŸÄ± ile Ã§aÄŸrÄ± yapabilir.

### Ã–zet:
Bu API'nin GET metoduna gelen istek, belirli bir URL, query parametre, baÅŸlÄ±k ve iÃ§erik tÃ¼rÃ¼ ile sÄ±nÄ±rlandÄ±rÄ±lmÄ±ÅŸtÄ±r.
Sadece `active=true` parametresi ile, `X-API-VERSION=1` baÅŸlÄ±ÄŸÄ± ile ve `application/json` formatÄ±nda gelen istekler iÅŸlenir.
YanÄ±t olarak JSON formatÄ±nda bir `AddressDto` listesi dÃ¶ndÃ¼rÃ¼lÃ¼r.
Bu yapÄ±, API'nin versiyonlama, veri formatÄ± yÃ¶netimi ve parametre kontrolÃ¼ gibi geliÅŸmiÅŸ Ã¶zelliklerini kullanarak RESTful bir mimari sunar.

## @EnableWebMvc
---
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    // CORS yapÄ±landÄ±rmasÄ±
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")  // TÃ¼m URL'ler iÃ§in geÃ§erli
                .allowedOrigins("http://localhost:3000")  // Ä°zin verilen kÃ¶ken
                .allowedMethods("GET", "POST", "PUT", "DELETE")  // Ä°zin verilen HTTP metodlarÄ±
                .allowedHeaders("*");  // Ä°zin verilen baÅŸlÄ±klar
    }

    // Statik kaynaklar iÃ§in yapÄ±landÄ±rma
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")  // KaynaklarÄ±n URL deseni
                .addResourceLocations("/public/", "classpath:/static/")  // KaynaklarÄ±n yerleri
                .setCachePeriod(3600);  // Cache sÃ¼resi (saniye)
    }

    // Interceptor eklemek iÃ§in yapÄ±landÄ±rma
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CustomInterceptor())  // CustomInterceptor sÄ±nÄ±fÄ± ile Interceptor eklenir
                .addPathPatterns("/api/**")  // Hangi URL deseninde geÃ§erli olacaÄŸÄ±
                .excludePathPatterns("/api/login", "/api/register");  // HariÃ§ tutulacak URL desenleri
    }
}


Spring Boot'ta `WebConfig` sÄ±nÄ±fÄ± genellikle Ã¶zel yapÄ±landÄ±rmalar yapmak iÃ§in kullanÄ±lÄ±r. Ã–zellikle CORS yapÄ±landÄ±rmasÄ±, statik kaynaklarÄ±n yÃ¶netimi, `Interceptor` ekleme gibi Ã§eÅŸitli web ayarlarÄ±nÄ± Ã¶zelleÅŸtirmek amacÄ±yla tercih edilir. AÅŸaÄŸÄ±da bir `WebConfig` Ã¶rneÄŸi ve aÃ§Ä±klamalarÄ± yer almaktadÄ±r:

### WebConfig Ã–rneÄŸi

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    // CORS yapÄ±landÄ±rmasÄ±
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")  // TÃ¼m URL'ler iÃ§in geÃ§erli
                .allowedOrigins("http://localhost:3000")  // Ä°zin verilen kÃ¶ken
                .allowedMethods("GET", "POST", "PUT", "DELETE")  // Ä°zin verilen HTTP metodlarÄ±
                .allowedHeaders("*");  // Ä°zin verilen baÅŸlÄ±klar
    }

    // Statik kaynaklar iÃ§in yapÄ±landÄ±rma
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")  // KaynaklarÄ±n URL deseni
                .addResourceLocations("/public/", "classpath:/static/")  // KaynaklarÄ±n yerleri
                .setCachePeriod(3600);  // Cache sÃ¼resi (saniye)
    }

    // Interceptor eklemek iÃ§in yapÄ±landÄ±rma
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new CustomInterceptor())  // CustomInterceptor sÄ±nÄ±fÄ± ile Interceptor eklenir
                .addPathPatterns("/api/**")  // Hangi URL deseninde geÃ§erli olacaÄŸÄ±
                .excludePathPatterns("/api/login", "/api/register");  // HariÃ§ tutulacak URL desenleri
    }
}
```

### AÃ§Ä±klamalar:

1. **@Configuration**: Spring Boot'ta yapÄ±landÄ±rma sÄ±nÄ±flarÄ±nÄ± iÅŸaretler. `WebConfig`, Spring'e bu sÄ±nÄ±fÄ±n yapÄ±landÄ±rma amaÃ§lÄ± olduÄŸunu sÃ¶yler.

2. **@EnableWebMvc**: Bu anotasyon, Spring MVC'nin tam kontrolÃ¼nÃ¼ elde etmek iÃ§in kullanÄ±lÄ±r. Ancak, Spring Boot varsayÄ±lan olarak birÃ§ok MVC ayarÄ±nÄ± otomatik olarak yapar. Bu nedenle, genellikle bu anotasyona ihtiyaÃ§ duyulmaz. EÄŸer manuel kontrol gerekiyorsa eklenir.

3. **addCorsMappings(CorsRegistry registry)**: Bu metot, Cross-Origin Resource Sharing (CORS) yapÄ±landÄ±rmasÄ± saÄŸlar. Bu yapÄ±landÄ±rmada:
    - `addMapping("/**")`: TÃ¼m URL'ler iÃ§in CORS kÄ±sÄ±tlamalarÄ±nÄ± uygular.
    - `allowedOrigins("http://localhost:3000")`: Sadece `localhost:3000` kÃ¶keninden gelen istekleri kabul eder.
    - `allowedMethods("GET", "POST", "PUT", "DELETE")`: Ä°zin verilen HTTP metodlarÄ±nÄ± tanÄ±mlar.
    - `allowedHeaders("*")`: TÃ¼m baÅŸlÄ±klara izin verir.

4. **addResourceHandlers(ResourceHandlerRegistry registry)**: Bu metot, statik kaynaklarÄ±n (CSS, JS, resimler vb.) nerede bulunduÄŸunu ve bu kaynaklara nasÄ±l eriÅŸileceÄŸini tanÄ±mlar.
    - `addResourceHandler("/resources/**")`: `/resources/` ile baÅŸlayan URL'ler bu statik kaynaklara eriÅŸir.
    - `addResourceLocations("/public/", "classpath:/static/")`: KaynaklarÄ±n dosya sisteminde ve classpath iÃ§inde nerede olduÄŸunu belirtir.

5. **addInterceptors(InterceptorRegistry registry)**: Bu metot, istekleri iÅŸleme aÅŸamasÄ±nda Ã¶ncesinde veya sonrasÄ±nda ek davranÄ±ÅŸlar ekleyen Interceptor'lar tanÄ±mlar.
    - `addInterceptor(new CustomInterceptor())`: `CustomInterceptor` sÄ±nÄ±fÄ± ile bir Interceptor eklenir.
    - `addPathPatterns("/api/**")`: Bu Interceptor sadece `/api/` ile baÅŸlayan URL'lerde Ã§alÄ±ÅŸÄ±r.
    - `excludePathPatterns("/api/login", "/api/register")`: `/api/login` ve `/api/register` URL'leri Interceptor'dan hariÃ§ tutulur.

Bu ÅŸekilde, Spring Boot projelerinizde CORS, statik kaynak yÃ¶netimi ve Interceptor'larÄ± yÃ¶netebilirsiniz. `WebMvcConfigurer` arayÃ¼zÃ¼, bu yapÄ±landÄ±rmalarÄ± yapmanÄ±za imkan tanÄ±r.


`.setCachePeriod(3600)` metodu, statik kaynaklar iÃ§in cache (Ã¶nbellekleme) sÃ¼resini saniye cinsinden ayarlayan bir iÅŸlevdir. Buradaki 3600 deÄŸeri, cache sÃ¼resinin 3600 saniye, yani 1 saat olduÄŸunu belirtir. Bu sÃ¼re boyunca tarayÄ±cÄ± veya istemci, statik kaynaklarÄ± (Ã¶rneÄŸin CSS, JavaScript, resim dosyalarÄ± gibi) yeniden indirmek yerine Ã¶nbellekten kullanÄ±r.

Ã–nbellekleme, sunucu Ã¼zerindeki yÃ¼kÃ¼ azaltmak ve uygulamanÄ±n performansÄ±nÄ± artÄ±rmak iÃ§in kullanÄ±lÄ±r. Statik kaynaklar sÄ±k sÄ±k deÄŸiÅŸmez, bu yÃ¼zden istemcilerin her seferinde sunucudan bu dosyalarÄ± indirmesine gerek yoktur. Ã–nbellekleme sÃ¼resi ÅŸu anlama gelir:

- **Cache sÃ¼resi dolmadan**: Ä°stemci (tarayÄ±cÄ± gibi), kaynaÄŸÄ± tekrar sunucudan talep etmez, bunun yerine daha Ã¶nce aldÄ±ÄŸÄ± ve Ã¶nbelleÄŸe kaydettiÄŸi versiyonu kullanÄ±r.
- **Cache sÃ¼resi dolduktan sonra**: Ä°stemci, kaynaÄŸÄ±n gÃ¼ncellenmiÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol etmek iÃ§in sunucuya yeni bir talep gÃ¶nderir.

Ã–rneÄŸin, `.setCachePeriod(3600)` kullanÄ±ldÄ±ÄŸÄ±nda, istemci bir CSS dosyasÄ±nÄ± ilk defa aldÄ±ÄŸÄ±nda, bu dosya 1 saat boyunca istemcinin cache belleÄŸinde tutulur ve bu sÃ¼re dolmadan sunucuya tekrar bu dosya iÃ§in istek gÃ¶ndermez.

Bu yÃ¶ntem Ã¶zellikle bÃ¼yÃ¼k dosyalar ve sÄ±k gÃ¼ncellenmeyen statik iÃ§erikler iÃ§in faydalÄ±dÄ±r, Ã§Ã¼nkÃ¼ istemciler sunucudan gereksiz yere veri indirmez ve bÃ¶ylece uygulamanÄ±zÄ±n performansÄ± artar.


`public void addResourceHandlers(ResourceHandlerRegistry registry)` metodu, Spring Boot'ta statik kaynaklarÄ±n (CSS, JavaScript, resim dosyalarÄ± vb.) nasÄ±l yÃ¶netileceÄŸini ve nerede bulunacaÄŸÄ±nÄ± yapÄ±landÄ±rmak iÃ§in kullanÄ±lan bir metottur. Bu metot, Spring MVC'nin varsayÄ±lan olarak saÄŸladÄ±ÄŸÄ± statik kaynak yÃ¶netimini Ã¶zelleÅŸtirmemizi saÄŸlar.

### KullanÄ±m AmacÄ±
Bu metot ile uygulamanÄ±zÄ±n kaynaklarÄ±nÄ±n nerede yer aldÄ±ÄŸÄ±nÄ± ve bu kaynaklara nasÄ±l eriÅŸileceÄŸini belirleyebilirsiniz. Statik kaynaklar genellikle `src/main/resources/static` dizininde tutulur. Ancak, bu dizini deÄŸiÅŸtirmek, farklÄ± dizinler eklemek veya Ã¶nbellekleme ayarlarÄ± gibi ek yapÄ±landÄ±rmalar yapmak istediÄŸinizde `addResourceHandlers` metodunu kullanabilirsiniz.

### Parametre: `ResourceHandlerRegistry`
`ResourceHandlerRegistry`, statik kaynaklarÄ±n tanÄ±mlandÄ±ÄŸÄ± bir yapÄ±landÄ±rma aracÄ±dÄ±r. Bu parametre ile Spring MVC'ye hangi URL desenlerine karÅŸÄ± hangi kaynaklarÄ±n sunulacaÄŸÄ±nÄ± belirleriz.

### Ã–rnek

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/resources/**")  // URL deseni
            .addResourceLocations("classpath:/static/", "/public/")  // KaynaklarÄ±n konumlarÄ±
            .setCachePeriod(3600);  // Ã–nbellekleme sÃ¼resi (saniye)
}
```

### AÃ§Ä±klamalar:

1. **`addResourceHandler("/resources/**")`**: Bu, URL desenini belirtir. Yani uygulamanÄ±zda `/resources/` ile baÅŸlayan herhangi bir URL, tanÄ±mladÄ±ÄŸÄ±nÄ±z kaynak dosyalarÄ±na yÃ¶nlendirilecektir. Ã–rneÄŸin, `/resources/css/style.css` gibi bir URL bu yapÄ±landÄ±rmaya uygun olacaktÄ±r.

2. **`addResourceLocations("classpath:/static/", "/public/")`**: Bu metot, kaynak dosyalarÄ±nÄ±n yerini tanÄ±mlar. Burada iki farklÄ± kaynak dizini belirtilmiÅŸ:
    - `classpath:/static/`: Bu, `src/main/resources/static/` dizinini ifade eder. Spring Boot projelerinde genellikle statik dosyalar burada tutulur.
    - `/public/`: Bu da proje klasÃ¶rÃ¼nÃ¼zdeki bir dizini ifade eder. EÄŸer dosyalarÄ±nÄ±z `public` klasÃ¶rÃ¼nde bulunuyorsa, buraya eriÅŸim de saÄŸlar.

3. **`setCachePeriod(3600)`**: Bu, yukarÄ±da aÃ§Ä±kladÄ±ÄŸÄ±mÄ±z gibi, kaynaklarÄ±n istemci tarafÄ±nda ne kadar sÃ¼reyle Ã¶nbellekte saklanacaÄŸÄ±nÄ± (saniye cinsinden) belirler. 3600 saniye, yani 1 saat Ã¶nbellekleme sÃ¼resi saÄŸlar.

### Bu YapÄ±landÄ±rmanÄ±n AvantajlarÄ±
- **Statik dosya eriÅŸimini Ã¶zelleÅŸtirme**: VarsayÄ±lan dizinlerin dÄ±ÅŸÄ±nda, farklÄ± dizinlerden de statik kaynaklarÄ± sunabilirsiniz.
- **Ã–nbellekleme**: PerformansÄ± artÄ±rmak iÃ§in istemcinin statik dosyalarÄ± Ã¶nbelleÄŸe almasÄ±nÄ± saÄŸlayabilirsiniz.
- **FarklÄ± yollar tanÄ±mlama**: FarklÄ± URL desenleriyle farklÄ± kaynaklarÄ± yÃ¶netebilir, proje dÃ¼zeninizi daha esnek hale getirebilirsiniz.

### Ne Zaman KullanÄ±lÄ±r?
- Statik kaynaklarÄ± varsayÄ±lan dizin dÄ±ÅŸÄ±na taÅŸÄ±mak veya baÅŸka bir dizinden sunmak istiyorsanÄ±z.
- Ã–nbellekleme ayarlarÄ±nÄ± kontrol etmek istiyorsanÄ±z.
- Birden fazla kaynak dizinini yapÄ±landÄ±rmanÄ±z gerekiyorsa.
- Ã–zel URL desenleri ile statik kaynaklara eriÅŸimi ayarlamak istiyorsanÄ±z.

Bu metodun Spring MVC'deki temel rolÃ¼, uygulamanÄ±zÄ±n statik dosyalarÄ±nÄ± daha esnek bir ÅŸekilde yÃ¶netmenize yardÄ±mcÄ± olmaktÄ±r.


`addInterceptors(InterceptorRegistry registry)` metodu, Spring Boot'ta istekleri karÅŸÄ±lamadan Ã¶nce veya sonra ek iÅŸlemler gerÃ§ekleÅŸtirmek iÃ§in **Interceptor**'larÄ± yapÄ±landÄ±rmak amacÄ±yla kullanÄ±lÄ±r. Interceptor'lar, web uygulamalarÄ±ndaki HTTP isteklerinin giriÅŸ ve Ã§Ä±kÄ±ÅŸÄ±nda ek iÅŸlemler yapabilen sÄ±nÄ±flardÄ±r. Ã–zellikle kimlik doÄŸrulama, yetkilendirme, loglama, performans izleme gibi iÅŸlemler iÃ§in kullanÄ±lÄ±rlar.

### Interceptor Nedir?
Bir **Interceptor**, uygulamaya gelen veya giden HTTP isteklerinin Ã¶ncesinde ya da sonrasÄ±nda Ã§alÄ±ÅŸÄ±r. Herhangi bir iÅŸlemi tamamlamadan Ã¶nce belirli kontroller yapabilir veya isteÄŸe ek bilgiler ekleyebilir.

### Metodun DetaylÄ± AÃ§Ä±klamasÄ±

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new CustomInterceptor())  // CustomInterceptor sÄ±nÄ±fÄ± ile Interceptor eklenir
            .addPathPatterns("/api/**")  // Hangi URL deseninde geÃ§erli olacaÄŸÄ±
            .excludePathPatterns("/api/login", "/api/register");  // HariÃ§ tutulacak URL desenleri
}
```

### AdÄ±m AdÄ±m AÃ§Ä±klama:

#### 1. **`addInterceptor(new CustomInterceptor())`**:
Bu kÄ±sÄ±m, `CustomInterceptor` adlÄ± sÄ±nÄ±fÄ± kullanarak bir Interceptor ekler. `CustomInterceptor`, bizim tanÄ±mladÄ±ÄŸÄ±mÄ±z bir sÄ±nÄ±f olup `HandlerInterceptor` arayÃ¼zÃ¼nÃ¼ ya da `HandlerInterceptorAdapter` sÄ±nÄ±fÄ±nÄ± geniÅŸletir.

   ```java
   public class CustomInterceptor implements HandlerInterceptor {

       @Override
       public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
           // Ä°stek iÅŸlenmeden Ã¶nce Ã§alÄ±ÅŸÄ±r
           return true;  // EÄŸer false dÃ¶nerse istek devam etmez
       }

       @Override
       public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
           // Ä°stek iÅŸlendikten sonra ama cevap istemciye gitmeden Ã¶nce Ã§alÄ±ÅŸÄ±r
       }

       @Override
       public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
           // Ä°stek tamamlandÄ±ktan sonra Ã§alÄ±ÅŸÄ±r, genellikle temizleme iÅŸlemleri iÃ§in kullanÄ±lÄ±r
       }
   }
   ```

- **`preHandle`**: Ä°stek sunucuya ulaÅŸmadan Ã¶nce Ã§alÄ±ÅŸÄ±r. Burada, kimlik doÄŸrulama, loglama, izin kontrolÃ¼ gibi iÅŸlemler yapÄ±labilir. EÄŸer `false` dÃ¶nerse istek iÅŸlenmez ve burada durdurulur.
- **`postHandle`**: Ä°stek baÅŸarÄ±yla iÅŸlendiÄŸinde ama yanÄ±t henÃ¼z istemciye gitmeden Ã¶nce Ã§alÄ±ÅŸÄ±r. Bu aÅŸamada, model veya view ile ek iÅŸlemler yapÄ±labilir.
- **`afterCompletion`**: Ä°stek tamamen tamamlandÄ±ÄŸÄ±nda Ã§alÄ±ÅŸÄ±r. Bu aÅŸamada genellikle temizleme, loglama gibi iÅŸlemler yapÄ±lÄ±r.

#### 2. **`addPathPatterns("/api/**")`**:
Bu kÄ±sÄ±mda, Interceptor'Ä±n hangi URL'lerde aktif olacaÄŸÄ±nÄ± belirleriz. Ã–rneÄŸin, `"/api/**"` deseni, `/api/` ile baÅŸlayan tÃ¼m URL'lere uygulanÄ±r. Bu, `/api/v1/products`, `/api/orders`, `/api/customers` gibi URL'ler olabilir.

Yani, `/api/**` ile eÅŸleÅŸen her istek Interceptor tarafÄ±ndan iÅŸlenecektir.

#### 3. **`excludePathPatterns("/api/login", "/api/register")`**:
Bu kÄ±sÄ±m, belirli URL'leri Interceptor'dan hariÃ§ tutmak iÃ§in kullanÄ±lÄ±r. Yani, `/api/login` ve `/api/register` URL'leri Interceptor tarafÄ±ndan iÅŸlenmeyecektir.

Ã–rneÄŸin, kimlik doÄŸrulama ve kayÄ±t gibi iÅŸlemler genellikle tÃ¼m kullanÄ±cÄ±lara aÃ§Ä±k olur, bu yÃ¼zden bu URL'ler Interceptor'Ä±n denetiminden hariÃ§ tutulabilir. Bu, Ã¶zellikle oturum aÃ§mamÄ±ÅŸ kullanÄ±cÄ±larÄ±n da bu iÅŸlemleri yapabilmesini saÄŸlar.

### Ã–zet:

Bu yapÄ±landÄ±rma ÅŸunu saÄŸlar:

1. **Interceptor eklenir**: `CustomInterceptor`, uygulamaya bir Interceptor olarak eklenmiÅŸtir. Bu Interceptor, gelen HTTP isteklerini iÅŸleyebilir veya kontrol edebilir.

2. **Path desenleri belirlenir**: Interceptor, sadece `/api/**` ile baÅŸlayan URL'lerde Ã§alÄ±ÅŸacaktÄ±r. Bu da, API'ye yapÄ±lan isteklerin tamamÄ±nda bu Interceptor'Ä±n kullanÄ±lacaÄŸÄ± anlamÄ±na gelir.

3. **HariÃ§ tutulan URL'ler belirlenir**: `/api/login` ve `/api/register` URL'leri, Interceptor'Ä±n dÄ±ÅŸÄ±nda bÄ±rakÄ±lmÄ±ÅŸtÄ±r. Yani, bu iki URL'ye yapÄ±lan istekler Interceptor tarafÄ±ndan iÅŸlenmeyecek.

### Ne zaman kullanÄ±lÄ±r?
- **Kimlik doÄŸrulama ve yetkilendirme**: KullanÄ±cÄ±larÄ±n yetkilerini denetlemek iÃ§in her isteÄŸin baÅŸÄ±nda kimlik doÄŸrulama kontrolÃ¼ yapmak amacÄ±yla kullanÄ±labilir.
- **Loglama**: TÃ¼m isteklerin ve yanÄ±tlarÄ±n loglanmasÄ± gerekiyorsa Interceptor ile bu iÅŸlemler gerÃ§ekleÅŸtirilir.
- **Performans takibi**: Ä°steklerin ne kadar sÃ¼rede tamamlandÄ±ÄŸÄ±nÄ± takip etmek iÃ§in kullanÄ±labilir.
- **Ä°stek deÄŸiÅŸtirme**: Giden ve gelen istek/yanÄ±t baÅŸlÄ±klarÄ±na eklemeler yapma gibi iÅŸlemler de Interceptor ile yapÄ±labilir.

### Ã–rnek KullanÄ±m Senaryosu:

Diyelim ki bir e-ticaret uygulamanÄ±z var ve `/api/**` ile baÅŸlayan tÃ¼m isteklerde kullanÄ±cÄ± kimliÄŸi doÄŸrulamasÄ± yapmak istiyorsunuz. Ancak `/api/login` ve `/api/register` yollarÄ± herkese aÃ§Ä±k olmalÄ±. Ä°ÅŸte bu durumda, `addInterceptors` metoduyla bir Interceptor ekleyip bu yollar hariÃ§ diÄŸer tÃ¼m API isteklerine kimlik doÄŸrulama kontrolÃ¼ ekleyebilirsiniz.

```java
public class CustomInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String token = request.getHeader("Authorization");
        if (token == null || !isValidToken(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return false;  // Ä°stek iÅŸlenmez ve hata dÃ¶ner
        }
        return true;  // Ä°stek iÅŸlenmeye devam eder
    }

    private boolean isValidToken(String token) {
        // Token doÄŸrulama iÅŸlemi
        return token.equals("geÃ§erli-token");
    }
}
```

Bu yapÄ±landÄ±rma ile, `/api/**` yollarÄ±na gelen istekler iÃ§in `Authorization` baÅŸlÄ±ÄŸÄ± ile gelen token'lar doÄŸrulanacak, ancak `/api/login` ve `/api/register` gibi yollara gelen istekler bu kontrolÃ¼n dÄ±ÅŸÄ±nda tutulacaktÄ±r.







---
`@CrossOrigin` Spring Boot'ta bir anotasyon olup, **Cross-Origin Resource Sharing (CORS)** ile ilgili ayarlarÄ± yÃ¶netmek iÃ§in kullanÄ±lÄ±r. CORS, bir kaynaÄŸÄ±n (Ã¶rneÄŸin, bir API'nin) baÅŸka bir alan adÄ± (domain) Ã¼zerindeki istemciler tarafÄ±ndan kullanÄ±lmasÄ±na izin verip vermeyeceÄŸini belirleyen bir gÃ¼venlik mekanizmasÄ±dÄ±r.

TarayÄ±cÄ±lar, bir web sayfasÄ±nÄ±n baÅŸka bir alan adÄ±ndan veri istemesine normalde izin vermezler (aynÄ± kaynaktan gelmeyen istekler kÄ±sÄ±tlanÄ±r). Ancak bazÄ± durumlarda bir web uygulamasÄ±nÄ±n, baÅŸka bir alan adÄ±ndaki bir API'den veri Ã§ekmesi gerekebilir. Ä°ÅŸte burada **CORS** devreye girer ve bu isteklere izin verilip verilmeyeceÄŸini belirler.

### `@CrossOrigin` Anotasyonu Nedir?
`@CrossOrigin`, Spring Boot'ta CORS ayarlarÄ±nÄ± yapÄ±landÄ±rmak iÃ§in kullanÄ±lan bir anotasyondur. Bu anotasyon, belirli bir API veya tÃ¼m uygulama genelinde baÅŸka bir alan adÄ±ndan gelen isteklere izin vermek iÃ§in kullanÄ±lÄ±r.

### KullanÄ±mÄ±

1. **Bir Denetleyici Seviyesinde (Controller Level)**:
   Bir denetleyicinin (controller) tÃ¼m yÃ¶ntemlerine baÅŸka bir alan adÄ±ndan gelen isteklere izin vermek iÃ§in bu anotasyon kullanÄ±labilir.

   ```java
   @RestController
   @CrossOrigin(origins = "http://example.com")
   public class MyController {

       @GetMapping("/data")
       public String getData() {
           return "Cross-origin data";
       }
   }
   ```

   Bu Ã¶rnekte, `http://example.com` alan adÄ±ndan gelen istekler `getData()` yÃ¶ntemine eriÅŸebilir. EÄŸer `origins` parametresi belirtilmezse, tÃ¼m alan adlarÄ±na izin verilir.

2. **YÃ¶ntem Seviyesinde (Method Level)**:
   Sadece belirli bir yÃ¶ntem iÃ§in CORS ayarlarÄ±nÄ± uygulamak isterseniz, bunu yÃ¶ntem seviyesinde kullanabilirsiniz.

   ```java
   @RestController
   public class MyController {

       @CrossOrigin(origins = "http://example.com")
       @GetMapping("/restricted-data")
       public String getRestrictedData() {
           return "Restricted cross-origin data";
       }
   }
   ```

   Bu durumda, sadece `http://example.com` alan adÄ±ndan gelen istekler `getRestrictedData()` metoduna eriÅŸebilir.

### `@CrossOrigin` Anotasyonunun Parametreleri

1. **`origins`**:
   Ä°steklerin kabul edileceÄŸi alan adlarÄ±nÄ± belirtir. Bir veya birden fazla alan adÄ± ekleyebilirsiniz. VarsayÄ±lan olarak, tÃ¼m alan adlarÄ±na (`*`) izin verilir.

   ```java
   @CrossOrigin(origins = {"http://example.com", "http://another-domain.com"})
   ```

2. **`methods`**:
   Hangi HTTP yÃ¶ntemlerinin (GET, POST, PUT, DELETE vs.) izin verileceÄŸini belirtir. EÄŸer belirtilmezse, varsayÄ±lan olarak tÃ¼m yÃ¶ntemlere izin verilir.

   ```java
   @CrossOrigin(methods = {RequestMethod.GET, RequestMethod.POST})
   ```

3. **`allowedHeaders`**:
   Ä°zin verilen baÅŸlÄ±klarÄ± belirtir. VarsayÄ±lan olarak, tÃ¼m baÅŸlÄ±klara izin verilir.

   ```java
   @CrossOrigin(allowedHeaders = {"Content-Type", "Authorization"})
   ```

4. **`exposedHeaders`**:
   TarayÄ±cÄ±ya aÃ§Ä±ÄŸa Ã§Ä±karÄ±lacak baÅŸlÄ±klarÄ± belirtir. VarsayÄ±lan olarak, CORS baÅŸlÄ±klarÄ± tarayÄ±cÄ±ya aÃ§Ä±lmaz.

   ```java
   @CrossOrigin(exposedHeaders = {"X-Custom-Header"})
   ```

5. **`allowCredentials`**:
   Kimlik doÄŸrulama bilgileri (Ã§erezler gibi) gÃ¶nderilip gÃ¶nderilmeyeceÄŸini belirtir. VarsayÄ±lan olarak `false`'tur.

   ```java
   @CrossOrigin(allowCredentials = "true")
   ```

6. **`maxAge`**:
   TarayÄ±cÄ±nÄ±n, bu ayarlarÄ±n geÃ§erliliÄŸini Ã¶nbelleÄŸe alacaÄŸÄ± sÃ¼reyi (saniye cinsinden) belirtir. VarsayÄ±lan olarak `1800` (30 dakika)'dÄ±r.

   ```java
   @CrossOrigin(maxAge = 3600)
   ```

### Global CORS YapÄ±landÄ±rmasÄ±
Sadece belirli denetleyicilere deÄŸil, uygulamanÄ±n tamamÄ±na CORS yapÄ±landÄ±rmasÄ±nÄ± eklemek iÃ§in `WebMvcConfigurer` arabirimi kullanÄ±lÄ±r.

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://example.com")
                .allowedMethods("GET", "POST")
                .allowedHeaders("Content-Type")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

Bu yapÄ±landÄ±rma ile, uygulamanÄ±n tÃ¼m yollarÄ±na (`/**`) `http://example.com` alan adÄ±ndan gelen GET ve POST isteklerine izin verilir.

### Ã–zetle:
- `@CrossOrigin` anotasyonu, Spring Boot uygulamanÄ±zda farklÄ± alan adlarÄ±ndan gelen istekleri kabul etmek iÃ§in kullanÄ±lÄ±r.
- Bu anotasyon ile belirli API'ler iÃ§in CORS politikasÄ± belirlenebilir.
- `origins`, `methods`, `allowedHeaders`, `exposedHeaders`, `allowCredentials`, ve `maxAge` gibi parametrelerle daha ince ayarlar yapabilirsiniz.

CORS politikalarÄ±nÄ± doÄŸru ayarlamak, gÃ¼venlik aÃ§Ä±sÄ±ndan kritik olabilir. UygulamanÄ±zÄ±n dÄ±ÅŸarÄ±ya aÃ§Ä±k alan adlarÄ±ndan gelen istekleri ne zaman ve nasÄ±l kabul edeceÄŸini dikkatli bir ÅŸekilde belirlemelisiniz.

## CORS DEVAM
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://example.com")
                .allowedMethods("GET", "POST")
                .allowedHeaders("Content-Type")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```
Bu kod parÃ§asÄ±, Spring Boot'ta **CORS (Cross-Origin Resource Sharing)** yapÄ±landÄ±rmasÄ±nÄ± yÃ¶netmek iÃ§in kullanÄ±lan bir sÄ±nÄ±fÄ± gÃ¶sterir. Spring Boot uygulamalarÄ±nda farklÄ± alan adlarÄ±ndan gelen istekleri yÃ¶netmek iÃ§in CORS yapÄ±landÄ±rmasÄ± yapmak gerekebilir ve bu yapÄ±landÄ±rma `WebMvcConfigurer` arayÃ¼zÃ¼ kullanÄ±larak saÄŸlanÄ±r. Kod parÃ§asÄ±nÄ± detaylÄ±ca aÃ§Ä±klayalÄ±m:

### @Configuration Anotasyonu
`@Configuration` anotasyonu, bu sÄ±nÄ±fÄ±n bir **Spring yapÄ±landÄ±rma sÄ±nÄ±fÄ±** olduÄŸunu belirtir. Spring, bu anotasyonla iÅŸaretlenmiÅŸ sÄ±nÄ±flarÄ±, baÅŸlatma sÄ±rasÄ±nda konfigÃ¼rasyon bilgilerini iÃ§eren sÄ±nÄ±flar olarak tanÄ±r. Bu sÄ±nÄ±fÄ±n iÃ§inde tanÄ±mladÄ±ÄŸÄ±nÄ±z metodlar ve yapÄ±landÄ±rmalar Spring IOC Container (BaÄŸÄ±mlÄ±lÄ±k Enjeksiyon YÃ¶neticisi) tarafÄ±ndan yÃ¶netilir ve uygulamanÄ±n baÅŸlatÄ±lmasÄ± sÄ±rasÄ±nda yÃ¼klenir.

Ã–rneÄŸin, bu sÄ±nÄ±f bir CORS yapÄ±landÄ±rmasÄ±nÄ± iÃ§eren bir sÄ±nÄ±f olduÄŸu iÃ§in, Spring Boot bu sÄ±nÄ±fÄ± otomatik olarak tanÄ±yacak ve CORS ayarlarÄ±nÄ± uygulamanÄ±n tÃ¼mÃ¼ne yayacaktÄ±r.

### WebMvcConfigurer ArayÃ¼zÃ¼
`WebMvcConfigurer`, Spring MVC iÃ§in yapÄ±landÄ±rmalarÄ± Ã¶zelleÅŸtirmenize olanak tanÄ±yan bir arayÃ¼zdÃ¼r. Bu arayÃ¼z, Spring MVC'nin varsayÄ±lan yapÄ±landÄ±rmasÄ±nÄ± deÄŸiÅŸtirmek istediÄŸinizde kullanÄ±lÄ±r. `WebMvcConfigurer` kullanarak aÅŸaÄŸÄ±daki gibi yapÄ±landÄ±rmalarÄ± Ã¶zelleÅŸtirebilirsiniz:
- CORS (Cross-Origin Resource Sharing) ayarlarÄ±
- View Resolver (gÃ¶rÃ¼nÃ¼m Ã§Ã¶zÃ¼mleyici) ayarlarÄ±
- Kaynak (resource) ayarlarÄ±
- Yol eÅŸlemesi (path mapping) ayarlarÄ±

Bu arayÃ¼zdeki metodlarÄ± override ederek, Spring MVC'nin iÅŸleyiÅŸini uygulamaya Ã¶zgÃ¼ hale getirebilirsiniz.

### addCorsMappings(CorsRegistry registry) Metodu
Bu metod, CORS yapÄ±landÄ±rmasÄ±nÄ± tanÄ±mladÄ±ÄŸÄ±nÄ±z yer. Bu metod Spring tarafÄ±ndan Ã§aÄŸrÄ±lÄ±r ve **CORS politikalarÄ±nÄ±** Ã¶zelleÅŸtirmenize olanak tanÄ±r. Ä°Ã§inde **CorsRegistry** nesnesini kullanarak, hangi yollarÄ±n (URL endpoint'lerinin) hangi alan adlarÄ±ndan gelen isteklere izin vereceÄŸini belirleyebilirsiniz.

#### DetaylÄ± Parametreler:
- **registry.addMapping("/**")**:
  Bu kÄ±sÄ±m, hangi yollarÄ±n CORS yapÄ±landÄ±rmasÄ±na tabi olduÄŸunu tanÄ±mlar. Burada `"/**"` kullanarak uygulamanÄ±zdaki tÃ¼m yollarÄ± belirtmiÅŸ oluyorsunuz. Yani bu yapÄ±landÄ±rma, uygulamanÄ±n tÃ¼m API endpoint'leri iÃ§in geÃ§erlidir.

  EÄŸer sadece belirli bir yol iÃ§in CORS ayarÄ± yapmak isterseniz, o yolu belirtebilirsiniz. Ã–rneÄŸin, sadece `/api/**` yollarÄ± iÃ§in izin vermek istiyorsanÄ±z:

  ```java
  registry.addMapping("/api/**")
  ```

- **allowedOrigins("http://example.com")**:
  Bu kÄ±sÄ±m, hangi alan adlarÄ±ndan gelen isteklere izin verileceÄŸini tanÄ±mlar. Ã–rnekte sadece `http://example.com` alan adÄ±ndan gelen isteklere izin veriyorsunuz. EÄŸer bu kÄ±smÄ± `*` olarak ayarlarsanÄ±z, tÃ¼m alan adlarÄ±ndan gelen isteklere izin verilmiÅŸ olur:

  ```java
  allowedOrigins("*")
  ```

  Ancak, gÃ¼venlik aÃ§Ä±sÄ±ndan genelde belirli bir alan adÄ± tanÄ±mlamak daha gÃ¼venlidir.

- **allowedMethods("GET", "POST")**:
  Bu kÄ±sÄ±m, hangi HTTP yÃ¶ntemlerine izin verileceÄŸini belirler. Ã–rnekte sadece **GET** ve **POST** yÃ¶ntemlerine izin verilmektedir. EÄŸer diÄŸer yÃ¶ntemlere de (PUT, DELETE vb.) izin vermek isterseniz bunlarÄ± ekleyebilirsiniz:

  ```java
  allowedMethods("GET", "POST", "PUT", "DELETE")
  ```

  VarsayÄ±lan olarak tÃ¼m yÃ¶ntemler (GET, POST, PUT, DELETE vb.) desteklenir, ancak bu metod ile belirli yÃ¶ntemleri sÄ±nÄ±rlayabilirsiniz.

- **allowedHeaders("Content-Type")**:
  Bu kÄ±sÄ±m, hangi baÅŸlÄ±klarÄ±n (headers) CORS istekleri sÄ±rasÄ±nda kabul edileceÄŸini belirler. Ã–rneÄŸin, sadece **Content-Type** baÅŸlÄ±ÄŸÄ±na izin vermek iÃ§in kullanÄ±lÄ±r. EÄŸer tÃ¼m baÅŸlÄ±klara izin vermek isterseniz `*` kullanabilirsiniz:

  ```java
  allowedHeaders("*")
  ```

  Ä°stek sÄ±rasÄ±nda hangi baÅŸlÄ±klarÄ±n geÃ§erli olacaÄŸÄ±nÄ± belirlemek, uygulamanÄ±zÄ±n gÃ¼venliÄŸini arttÄ±rmaya yardÄ±mcÄ± olabilir.

- **allowCredentials(true)**:
  Bu kÄ±sÄ±m, **kimlik doÄŸrulama bilgileri** (Ã¶rneÄŸin, Ã§erezler veya kimlik doÄŸrulama baÅŸlÄ±klarÄ± gibi) ile yapÄ±lacak isteklere izin verilip verilmeyeceÄŸini belirler. EÄŸer `true` olarak ayarlanmÄ±ÅŸsa, kimlik doÄŸrulama bilgileri ile gelen istekler kabul edilir. Bu ayarÄ± dikkatli kullanmak gerekir Ã§Ã¼nkÃ¼ uygulamanÄ±zÄ±n gÃ¼venlik risklerini artÄ±rabilir.

- **maxAge(3600)**:
  Bu kÄ±sÄ±m, tarayÄ±cÄ±nÄ±n CORS Ã¶nbellekleme sÃ¼resini (saniye cinsinden) tanÄ±mlar. Burada `3600` olarak ayarlanmÄ±ÅŸ ve bu, CORS ayarlarÄ±nÄ±n tarayÄ±cÄ±da **1 saat** boyunca geÃ§erli olacaÄŸÄ± anlamÄ±na gelir. TarayÄ±cÄ± bu sÃ¼re boyunca aynÄ± kaynak iÃ§in CORS doÄŸrulamasÄ±nÄ± tekrar etmez ve bu da performans aÃ§Ä±sÄ±ndan fayda saÄŸlar.

### Ã–rnek Senaryo:
Bu CORS yapÄ±landÄ±rmasÄ± ile, uygulamanÄ±zÄ±n tÃ¼m yollarÄ±na (`/**`) `http://example.com` alan adÄ±ndan gelen GET ve POST isteklerine izin veriyorsunuz. Bu istekler sÄ±rasÄ±nda kimlik doÄŸrulama bilgileri (Ã§erezler vb.) kabul ediliyor ve tarayÄ±cÄ± bu yapÄ±landÄ±rmayÄ± 1 saat boyunca Ã¶nbelleÄŸe alÄ±yor.

### Spring Boot'ta Global CORS YapÄ±landÄ±rmasÄ±
Bu yapÄ±landÄ±rma, Spring Boot uygulamanÄ±zÄ±n global CORS ayarlarÄ±nÄ± yapÄ±landÄ±rmanÄ±zÄ± saÄŸlar. Yani bu sÄ±nÄ±f ve metod, tÃ¼m denetleyicilere (controller) ve API endpoint'lerine uygulanÄ±r. EÄŸer sadece belirli endpoint'ler iÃ§in CORS ayarÄ± yapmak isterseniz, `@CrossOrigin` anotasyonunu ilgili denetleyici veya metodun Ã¼stÃ¼ne ekleyebilirsiniz.

### Genel Ã–zeti:
Bu kod parÃ§asÄ±, Spring Boot'ta **CORS** yapÄ±landÄ±rmasÄ±nÄ± yÃ¶netmek iÃ§in kullanÄ±lan bir sÄ±nÄ±f Ã¶rneÄŸidir. Spring'in `WebMvcConfigurer` arayÃ¼zÃ¼nÃ¼ uygulayarak, uygulamanÄ±zÄ±n tÃ¼m yollarÄ±nda CORS politikalarÄ±nÄ± belirlemenize olanak tanÄ±r. Bu sayede, uygulamanÄ±zÄ±n baÅŸka bir alan adÄ±ndan gelen isteklere nasÄ±l yanÄ±t vereceÄŸini kontrol edebilirsiniz.

---
## Spring Boot Jpa Terimler
Spring Data JPA ile kullanÄ±lan bu terimler, bir veritabanÄ± Ã¼zerinde otomatik olarak veri tablolarÄ±nÄ±n yÃ¶netilmesine olanak tanÄ±yan JPA (Java Persistence API) saÄŸlayÄ±cÄ±sÄ±nÄ±n yapÄ±landÄ±rma seÃ§enekleridir. Her bir yapÄ±landÄ±rma seÃ§eneÄŸi, JPA'nÄ±n veritabanÄ± ÅŸemasÄ± Ã¼zerinde nasÄ±l bir iÅŸlem yapacaÄŸÄ±nÄ± belirler. Bu iÅŸlemler uygulamanÄ±zÄ±n baÅŸlatÄ±lmasÄ± sÄ±rasÄ±nda veritabanÄ± ile nasÄ±l etkileÅŸimde bulunulacaÄŸÄ±nÄ± kontrol eder. DetaylÄ± olarak aÃ§Ä±klarsak:

### 1. `none`
- **AÃ§Ä±klama:**
  `none` ayarÄ±, JPA'nÄ±n uygulama baÅŸlatÄ±lÄ±rken veritabanÄ± Ã¼zerinde herhangi bir ÅŸema yÃ¶netimi iÅŸlemi yapmamasÄ±nÄ± saÄŸlar. Yani JPA, tablolarÄ± oluÅŸturmaz, gÃ¼ncellemez veya doÄŸrulamaz.

- **KullanÄ±m Durumu:**
  EÄŸer veritabanÄ± ÅŸema yÃ¶netimini tamamen dÄ±ÅŸ bir araÃ§la veya manuel olarak yapmak istiyorsanÄ±z ve JPA'nÄ±n ÅŸema Ã¼zerinde hiÃ§bir etkisi olmamasÄ± gerekiyorsa `none` kullanÄ±lÄ±r.

- **Ã–zellikleri:**
  VeritabanÄ± Ã¼zerinde hiÃ§ deÄŸiÅŸiklik yapmaz. TablolarÄ±n ve diÄŸer yapÄ±larÄ±n zaten hazÄ±r olduÄŸu varsayÄ±lÄ±r.

### 2. `update`
- **AÃ§Ä±klama:**
  `update` ayarÄ±, mevcut ÅŸemanÄ±n korunmasÄ±nÄ± ve yalnÄ±zca gerekli deÄŸiÅŸikliklerin (Ã¶rneÄŸin yeni sÃ¼tunlar veya tablolar ekleme) uygulanmasÄ±nÄ± saÄŸlar. Ancak, bu iÅŸlem sÄ±rasÄ±nda var olan veriler korunur. `update` modunda JPA, mevcut tabloya yeni alanlar veya iliÅŸkiler ekler ancak var olan alanlarÄ± deÄŸiÅŸtirmez veya silmez.

- **KullanÄ±m Durumu:**
  GeliÅŸtirme sÄ±rasÄ±nda, veritabanÄ±ndaki tablolarÄ± yeniden oluÅŸturmadan sadece yeni eklemeler yapmak istediÄŸinizde `update` ayarÄ± kullanÄ±labilir.

- **Ã–zellikleri:**
    - VeritabanÄ±ndaki tablolarÄ±n varlÄ±ÄŸÄ±nÄ± kontrol eder.
    - Yeni alanlar ekler ancak mevcut verileri silmez veya deÄŸiÅŸtirmez.

### 3. `create`
- **AÃ§Ä±klama:**
  `create` ayarÄ±, uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda veritabanÄ±ndaki tÃ¼m mevcut tablolarÄ± silip yeniden oluÅŸturur. Bu, veritabanÄ±nda yeni tablolar oluÅŸtururken sÄ±fÄ±rdan baÅŸlamak anlamÄ±na gelir. Var olan tablolar ve veriler tamamen silinir ve ardÄ±ndan ÅŸemaya uygun yeni tablolar oluÅŸturÄ±lÄ±r.

- **KullanÄ±m Durumu:**
  Genellikle test veya geliÅŸtirme ortamlarÄ±nda, veritabanÄ± ÅŸemasÄ±nÄ±n sÃ¼rekli olarak sÄ±fÄ±rdan oluÅŸturulmasÄ± gerektiÄŸinde kullanÄ±lÄ±r. CanlÄ± ortamda kullanÄ±lmasÄ± Ã¶nerilmez Ã§Ã¼nkÃ¼ mevcut tÃ¼m veriler kaybolur.

- **Ã–zellikleri:**
    - Var olan tablolarÄ± siler.
    - TablolarÄ± yeniden oluÅŸturur ve boÅŸ bir ÅŸema ile baÅŸlar.

### 4. `create-drop`
- **AÃ§Ä±klama:**
  `create-drop` ayarÄ±, `create` moduna benzer bir ÅŸekilde baÅŸlar; uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda veritabanÄ±ndaki tÃ¼m tablolarÄ± silip yeniden oluÅŸturur. Ancak, `create-drop`'un farkÄ± uygulama kapatÄ±ldÄ±ÄŸÄ±nda, JPA'nÄ±n oluÅŸturduÄŸu tablolarÄ±n tekrar silinmesidir. Yani, tabloyu oluÅŸturur, uygulama kapanÄ±nca ise siler.

- **KullanÄ±m Durumu:**
  Test senaryolarÄ±nda veya geÃ§ici veritabanÄ± kullanÄ±mÄ±nda yararlÄ±dÄ±r. Ã–rneÄŸin, uygulama kapandÄ±ÄŸÄ±nda tÃ¼m test verilerinin silinmesi isteniyorsa `create-drop` kullanÄ±labilir.

- **Ã–zellikleri:**
    - Uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda tablolarÄ± oluÅŸturur.
    - Uygulama kapatÄ±ldÄ±ÄŸÄ±nda oluÅŸturulan tablolarÄ± siler.

### 5. `validate`
- **AÃ§Ä±klama:**
  `validate` ayarÄ±, veritabanÄ±ndaki mevcut tablolarÄ±n uygulamadaki JPA varlÄ±klarÄ±na (entities) uygun olup olmadÄ±ÄŸÄ±nÄ± kontrol eder. Ancak, bu iÅŸlem sÄ±rasÄ±nda herhangi bir tablo oluÅŸturulmaz, deÄŸiÅŸtirilmez veya silinmez. Sadece var olan ÅŸemanÄ±n doÄŸruluÄŸu kontrol edilir. EÄŸer tablo yapÄ±sÄ± JPA varlÄ±klarÄ±na uygun deÄŸilse hata verir ve uygulama baÅŸlamaz.

- **KullanÄ±m Durumu:**
  CanlÄ± sistemlerde, ÅŸemanÄ±n doÄŸru yapÄ±landÄ±rÄ±ldÄ±ÄŸÄ±ndan emin olmak iÃ§in kullanÄ±labilir. VeritabanÄ±nda herhangi bir deÄŸiÅŸiklik yapmadÄ±ÄŸÄ± iÃ§in, mevcut yapÄ±yÄ± korur ve sadece doÄŸrulama yapar.

- **Ã–zellikleri:**
    - Tablo yapÄ±sÄ±nÄ±n JPA varlÄ±klarÄ±yla uyumlu olup olmadÄ±ÄŸÄ±nÄ± kontro
```sh 

```
---



## Spring Data (iliÅŸkiler  (relationships))
```sh 

```
---


Spring Bootâ€™ta **iliÅŸkiler** (relationships), veri modelleme aÃ§Ä±sÄ±ndan Ã¶nemli bir role sahiptir ve `@OneToOne`, `@OneToMany`, `@ManyToOne`, ve `@ManyToMany` gibi anotasyonlarla tanÄ±mlanÄ±r. Bu iliÅŸkiler, veritabanÄ±ndaki tablo yapÄ±larÄ± arasÄ±ndaki baÄŸlarÄ± temsil eder ve bir nesneyle diÄŸer nesneler arasÄ±ndaki baÄŸÄ± kurmamÄ±za olanak tanÄ±r. Her bir iliÅŸkinin kendine Ã¶zgÃ¼ bazÄ± Ã¶nemli **attributelarÄ±** vardÄ±r. AÅŸaÄŸÄ±da bu iliÅŸki tÃ¼rlerinin ve bu anotasyonlarla birlikte kullanÄ±lan en Ã¶nemli attributeâ€™larÄ±n detaylÄ± bir aÃ§Ä±klamasÄ±nÄ± bulabilirsiniz.

### 1. `@OneToOne` Ä°liÅŸkisi

`@OneToOne`, iki varlÄ±k arasÄ±nda birebir iliÅŸki kurmak iÃ§in kullanÄ±lÄ±r. Ã–rneÄŸin, bir **kullanÄ±cÄ±** ile onun **profil** bilgisi arasÄ±nda birebir bir iliÅŸki olabilir.

#### Ã–rnek KullanÄ±m
```java
@Entity
public class User {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id", referencedColumnName = "id")
    private Profile profile;
}
```

#### Ã–nemli Attributeâ€™lar

- **`mappedBy`**: Bir iliÅŸkinin ters tarafÄ±nda (`inverse side`) kullanÄ±lÄ±r. `mappedBy`, iliÅŸkiyi ters tarafla eÅŸleÅŸtirmek iÃ§in iliÅŸki sahibini (`owning side`) belirtir. Ã–rneÄŸin, `Profile` sÄ±nÄ±fÄ±nda `User`â€™Ä±n ters tarafÄ± olarak `mappedBy` kullanÄ±labilir.

    ```java
    @OneToOne(mappedBy = "profile")
    private User user;
    ```

- **`cascade`**: Ä°liÅŸkili varlÄ±k Ã¼zerinde yapÄ±lacak iÅŸlemleri (Ã¶rneÄŸin, kayÄ±t, gÃ¼ncelleme veya silme) belirler. Ã–rneÄŸin `CascadeType.ALL`, `User` kaydedildiÄŸinde otomatik olarak `Profile` kaydÄ±nÄ± da gÃ¼nceller.

- **`fetch`**: VarsayÄ±lan olarak `EAGER`â€™dÄ±r. `@OneToOne` iliÅŸkilerde iliÅŸki veri her zaman yÃ¼klenir. `LAZY` olarak ayarlandÄ±ÄŸÄ±nda, iliÅŸki veri sadece gerektiÄŸinde yÃ¼klenir.

- **`optional`**: `true` ise, iliÅŸki nullable olarak tanÄ±mlanÄ±r. Bu, iliÅŸkili varlÄ±ÄŸÄ±n `null` olabileceÄŸi anlamÄ±na gelir. `false` yapÄ±ldÄ±ÄŸÄ±nda, iliÅŸkili varlÄ±k `null` olamaz.

- **`@JoinColumn`**: VeritabanÄ±nda iliÅŸkiyi kuran anahtar sÃ¼tunu belirtir. `name` attributeâ€™u, iliÅŸki kurulacak sÃ¼tunun ismini tanÄ±mlar.

### 2. `@OneToMany` Ä°liÅŸkisi

`@OneToMany`, bir varlÄ±ÄŸÄ±n diÄŸer bir varlÄ±kla bire-Ã§ok iliÅŸkisini temsil eder. Ã–rneÄŸin, bir **yazar** ve onun **kitaplarÄ±** arasÄ±nda bire-Ã§ok iliÅŸkisi olabilir. Bu tÃ¼r bir iliÅŸkide, bir yazarÄ±n birden fazla kitabÄ± vardÄ±r.

#### Ã–rnek KullanÄ±m
```java
@Entity
public class Author {
    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL)
    private List<Book> books;
}
```

#### Ã–nemli Attributeâ€™lar

- **`mappedBy`**: `@OneToMany` iliÅŸkilerinde sÄ±kÃ§a kullanÄ±lÄ±r. Ä°liÅŸki sahibini belirleyerek, iliÅŸkiyi ters tarafla baÄŸlar. Burada `Book` sÄ±nÄ±fÄ±nda `author` iliÅŸki sahibidir.

- **`cascade`**: Bu attribute, iliÅŸki gÃ¼ncellemelerinde ne yapÄ±lmasÄ± gerektiÄŸini belirtir. Ã–rneÄŸin, `CascadeType.ALL` kullanÄ±ldÄ±ÄŸÄ±nda, `Author` gÃ¼ncellenirken iliÅŸkili tÃ¼m `Book` kayÄ±tlarÄ± da gÃ¼ncellenir.

- **`fetch`**: `@OneToMany` iliÅŸkilerde varsayÄ±lan olarak `LAZY`â€™dir. Veri gerektiÄŸinde yÃ¼klenir. `EAGER` olarak deÄŸiÅŸtirilirse iliÅŸki veri her zaman yÃ¼klenir.

- **`orphanRemoval`**: `true` olarak ayarlanÄ±rsa, iliÅŸki koparÄ±ldÄ±ÄŸÄ±nda `orphan` (yetim) olan `Book` kayÄ±tlarÄ± otomatik olarak silinir.

- **`@JoinColumn` veya `@JoinTable`**: Ä°liÅŸkiyi baÄŸlayacak anahtar sÃ¼tunu veya baÄŸlantÄ± tablosunu belirler. `@JoinColumn`, tek bir anahtar sÃ¼tunuyla iliÅŸki kurarken, `@JoinTable` iki tablo arasÄ±ndaki baÄŸlantÄ±yÄ± kurar.

### 3. `@ManyToOne` Ä°liÅŸkisi

`@ManyToOne`, birden fazla varlÄ±ÄŸÄ±n tek bir varlÄ±ÄŸa baÄŸlÄ± olduÄŸu iliÅŸki tÃ¼rÃ¼dÃ¼r. Ã–rneÄŸin, bir **kitap** ve onun **yazarÄ±** arasÄ±ndaki iliÅŸki gibi. BirÃ§ok kitap tek bir yazara ait olabilir.

#### Ã–rnek KullanÄ±m
```java
@Entity
public class Book {
    @ManyToOne
    @JoinColumn(name = "author_id")
    private Author author;
}
```

#### Ã–nemli Attributeâ€™lar

- **`fetch`**: `@ManyToOne` iliÅŸkilerde varsayÄ±lan olarak `EAGER`â€™dÄ±r. Ä°liÅŸki veri her zaman yÃ¼klenir. `LAZY` olarak ayarlanabilir.

- **`optional`**: EÄŸer `true` olarak ayarlanmÄ±ÅŸsa, iliÅŸkili varlÄ±k `null` olabilir. Ã–rneÄŸin, `optional = false` yapÄ±ldÄ±ÄŸÄ±nda `Book` kaydÄ±nÄ±n mutlaka bir `Author` ile iliÅŸkili olmasÄ± gerekir.

- **`cascade`**: AynÄ± diÄŸer iliÅŸki tÃ¼rlerinde olduÄŸu gibi, `cascade` tipi belirlenebilir. Ã–rneÄŸin, `CascadeType.PERSIST` sadece ana varlÄ±k kaydedildiÄŸinde iliÅŸkili varlÄ±k da kaydedilir.

- **`@JoinColumn`**: Bu iliÅŸkiyi kuran anahtar sÃ¼tunu tanÄ±mlar. `name` attributeâ€™u, iliÅŸkili sÃ¼tunun veritabanÄ±nda hangi isimle yer alacaÄŸÄ±nÄ± belirler.

### 4. `@ManyToMany` Ä°liÅŸkisi

`@ManyToMany`, iki varlÄ±k arasÄ±nda Ã§oktan Ã§oÄŸa iliÅŸkiyi tanÄ±mlar. Ã–rneÄŸin, bir **Ã¶ÄŸrenci** ve onun **dersleri** arasÄ±nda Ã§oktan Ã§oÄŸa iliÅŸki vardÄ±r; bir Ã¶ÄŸrenci birden fazla ders alabilir ve bir ders birden fazla Ã¶ÄŸrenciye sahip olabilir.

#### Ã–rnek KullanÄ±m
```java
@Entity
public class Student {
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}
```

#### Ã–nemli Attributeâ€™lar

- **`mappedBy`**: Ä°liÅŸkiyi ters tarafla baÄŸlar. Bir sÄ±nÄ±fta `@ManyToMany` iliÅŸki tanÄ±mlandÄ±ysa, diÄŸer sÄ±nÄ±fta `mappedBy` ile iliÅŸki sahibi belirtilmelidir.

- **`cascade`**: Ä°liÅŸki iÃ§in uygulanacak iÅŸlemleri belirtir. Ã–rneÄŸin, `CascadeType.MERGE` ile ana varlÄ±k gÃ¼ncellendiÄŸinde iliÅŸkili varlÄ±klar da gÃ¼ncellenir.

- **`fetch`**: `@ManyToMany` iliÅŸkilerde varsayÄ±lan olarak `LAZY`â€™dir. Veri gerektiÄŸinde yÃ¼klenir, ancak `EAGER` olarak ayarlanabilir.

- **`@JoinTable`**: Ã‡oktan Ã§oÄŸa iliÅŸkilerde baÄŸlantÄ±yÄ± saÄŸlayan Ã¼Ã§Ã¼ncÃ¼ bir tabloyu belirtir. `name` attributeâ€™u ile baÄŸlantÄ± tablosunun ismi verilir. `joinColumns` ana varlÄ±ÄŸÄ±n anahtar sÃ¼tununu, `inverseJoinColumns` ise iliÅŸkili varlÄ±ÄŸÄ±n anahtar sÃ¼tununu belirtir.

- **`@JoinColumn`**: BirÃ§ok `@JoinColumn` ile iliÅŸkili varlÄ±klar arasÄ±nda kÃ¶prÃ¼ kuran bir tablo tanÄ±mlanabilir. Bu, iliÅŸki iÃ§in baÄŸlantÄ± sÃ¼tunlarÄ±nÄ± belirler.

### Cascade Tipleri (CascadeType)

TÃ¼m iliÅŸki tÃ¼rlerinde kullanÄ±labilen `cascade` tipi, iliÅŸki iÅŸlemlerinin iliÅŸkili varlÄ±ÄŸa nasÄ±l yansÄ±yacaÄŸÄ±nÄ± belirler:

- **`CascadeType.ALL`**: TÃ¼m iÅŸlemler iliÅŸki Ã¼zerinde yapÄ±lÄ±r (persist, merge, remove, refresh, detach).
- **`CascadeType.PERSIST`**: Ana varlÄ±k kaydedildiÄŸinde, iliÅŸkili varlÄ±klar da kaydedilir.
- **`CascadeType.MERGE`**: Ana varlÄ±k gÃ¼ncellendiÄŸinde, iliÅŸkili varlÄ±klar da gÃ¼ncellenir.
- **`CascadeType.REMOVE`**: Ana varlÄ±k silindiÄŸinde, iliÅŸkili varlÄ±klar da silinir.
- **`CascadeType.REFRESH`**: Ana varlÄ±k yenilendiÄŸinde, iliÅŸkili varlÄ±klar da yenilenir.
- **`CascadeType.DETACH`**: Ana varlÄ±k oturumdan ayrÄ±ldÄ±ÄŸÄ±nda, iliÅŸkili varlÄ±klar da ayrÄ±lÄ±r.

### Fetch Tipleri (FetchType)

**FetchType** iki seÃ§enek sunar:

- **`FetchType.EAGER`**: Ä°liÅŸki veri her zaman yÃ¼klenir. Bu, veri her durumda belleÄŸe alÄ±nÄ±r.
- **`FetchType.LAZY`**: Ä°liÅŸki veri yalnÄ±zca gerektiÄŸinde yÃ¼klenir. Bu, bellek yÃ¶netimi aÃ§Ä±sÄ±ndan daha verimlidir.

### Ã–zet

Spring Boot iliÅŸkileri tanÄ±mlamak iÃ§in kullanÄ±lan `@anotasyonlar`, veritabanÄ± modellemelerinde veri iliÅŸkilerini aÃ§Ä±k bir ÅŸekilde ifade etmemizi saÄŸlar. Bu iliÅŸkiler, `@OneToOne`, `@OneToMany`, `@ManyToOne`, ve `@ManyToMany` anotasyonlarÄ± ile belirtilir. Her bir iliÅŸki tÃ¼rÃ¼, veritabanÄ± yapÄ±sÄ±nda anlamlÄ± baÄŸlantÄ±lar kurmayÄ± saÄŸlar ve verilerin yÃ¶netilmesi, gÃ¼ncellenmesi, veya silinmesi gibi iÅŸlemler sÄ±rasÄ±nda entegre bir yapÄ± sunar.

### Ä°liÅŸkilerde KullanÄ±lan BaÅŸlÄ±ca Attribute ve AnotasyonlarÄ±n Ã–zeti

1. **`@OneToOne`**:
    - Birebir iliÅŸkilerde kullanÄ±lÄ±r.
    - `mappedBy`, iliÅŸkiyi ters tarafla eÅŸleÅŸtirir.
    - `@JoinColumn`, iliÅŸkiyi kuran sÃ¼tunu belirtir.
    - `cascade`, iÅŸlemleri tÃ¼m varlÄ±klar arasÄ±nda paylaÅŸÄ±r.
    - `fetch`, veri yÃ¼kleme tÃ¼rÃ¼nÃ¼ belirler (`EAGER` varsayÄ±lan).

2. **`@OneToMany`**:
    - Bire-Ã§ok iliÅŸkilerde kullanÄ±lÄ±r.
    - `mappedBy`, iliÅŸki sahibini belirtir.
    - `cascade`, iÅŸlemleri yÃ¶netir (Ã¶rneÄŸin `CascadeType.ALL` ile tÃ¼m iÅŸlemler).
    - `orphanRemoval`, iliÅŸki sona erdiÄŸinde iliÅŸkisiz (orphan) Ã¶ÄŸeleri siler.
    - `fetch`, veri yÃ¼kleme tÃ¼rÃ¼nÃ¼ belirler (`LAZY` varsayÄ±lan).

3. **`@ManyToOne`**:
    - Ã‡oktan-bire iliÅŸkiyi ifade eder.
    - `cascade`, iÅŸlemleri iliÅŸkili varlÄ±k Ã¼zerinde uygular.
    - `optional`, iliÅŸkili varlÄ±ÄŸÄ±n zorunlu olup olmadÄ±ÄŸÄ±nÄ± belirtir.
    - `fetch`, veri yÃ¼kleme tÃ¼rÃ¼nÃ¼ belirler (`EAGER` varsayÄ±lan).
    - `@JoinColumn`, iliÅŸkiyi saÄŸlayan sÃ¼tunu belirtir.

4. **`@ManyToMany`**:
    - Ã‡oktan-Ã§oÄŸa iliÅŸkilerde kullanÄ±lÄ±r.
    - `mappedBy`, iliÅŸkiyi ters tarafla baÄŸlar.
    - `@JoinTable`, Ã¼Ã§Ã¼ncÃ¼ tablo ile iki varlÄ±k arasÄ±ndaki baÄŸlantÄ±yÄ± saÄŸlar.
    - `cascade`, iÅŸlemleri her iki taraf Ã¼zerinde de yÃ¼rÃ¼tÃ¼r.
    - `fetch`, veri yÃ¼kleme tÃ¼rÃ¼nÃ¼ belirler (`LAZY` varsayÄ±lan).

5. **`CascadeType`** SeÃ§enekleri:
    - `ALL`, `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, `DETACH` iÅŸlemlerini belirtir.
    - `CascadeType.ALL` tÃ¼m iÅŸlemleri iliÅŸki varlÄ±ÄŸÄ±na uygular.

6. **`FetchType`** SeÃ§enekleri:
    - `EAGER`: Veri her zaman yÃ¼klenir.
    - `LAZY`: Veri sadece gerektiÄŸinde yÃ¼klenir, performans avantajÄ± saÄŸlar.

### Ä°liÅŸki YÃ¶netiminde Dikkat Edilmesi Gerekenler

- **Bellek YÃ¶netimi**: `LAZY` yÃ¼kleme, bellek yÃ¶netimi aÃ§Ä±sÄ±ndan avantaj saÄŸlar. Ã–zellikle bÃ¼yÃ¼k veri setleriyle Ã§alÄ±ÅŸÄ±yorsanÄ±z `LAZY` olarak ayarlamak belleÄŸi daha verimli kullanmanÄ±za yardÄ±mcÄ± olur.
- **Orphan Removal**: `orphanRemoval = true` olarak ayarlanÄ±rsa, bir koleksiyondan silinen Ã¶ÄŸeler otomatik olarak veritabanÄ±ndan da silinir.
- **VeritabanÄ± Ä°ÅŸlemleri**: `cascade` ile, bir varlÄ±k Ã¼zerinde yapÄ±lan iÅŸlemlerin baÄŸlÄ± varlÄ±klarÄ± nasÄ±l etkilediÄŸini kontrol edebilirsiniz.
- **Veri TutarlÄ±lÄ±ÄŸÄ±**: `optional = false` gibi Ã¶zelliklerle, iliÅŸkilerin bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ koruyabilir ve `null` iliÅŸki oluÅŸmasÄ±nÄ± engelleyebilirsiniz.

Spring Bootâ€™ta veri modelleri arasÄ±nda anlamlÄ± baÄŸlantÄ±lar kurmak ve bu iliÅŸkileri doÄŸru bir ÅŸekilde yÃ¶netmek, uygulamanÄ±n saÄŸlam bir yapÄ±ya sahip olmasÄ±nÄ± saÄŸlar. Bu iliÅŸkileri ve `attribute`larÄ± doÄŸru kullanmak, veritabanÄ± iÅŸlemlerinin daha etkili ve sÃ¼rdÃ¼rÃ¼lebilir olmasÄ±nÄ± saÄŸlar.





## Spring API (@RequestParam) 
```sh 

```
---


`@RequestParam` ve `@PathVariable`, Spring Framework'de HTTP isteÄŸinden parametreleri almak iÃ§in kullanÄ±lan iki farklÄ± anotasyondur. Bu iki anotasyonun nasÄ±l Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ±, aralarÄ±ndaki farklarÄ± ve hangi durumlarda hangisini kullanmanÄ±z gerektiÄŸini ayrÄ±ntÄ±lÄ± olarak aÃ§Ä±klayalÄ±m.

### `@RequestParam` Nedir?

`@RequestParam`, genellikle **sorgu parametrelerini** almak iÃ§in kullanÄ±lÄ±r. Sorgu parametreleri, URLâ€™nin `?` iÅŸaretinden sonra gelen anahtar-deÄŸer Ã§iftleridir. `@RequestParam` ile bir URLâ€™nin sorgu kÄ±smÄ±ndan parametreleri alabiliriz.

**Ã–rnek KullanÄ±m**:
URL: `http://example.com/api/products?category=electronics&price=100`

```java
@GetMapping("/products")
public String getProducts(@RequestParam String category, @RequestParam int price) {
    // category = "electronics"
    // price = 100
    return "Category: " + category + ", Price: " + price;
}
```

YukarÄ±daki Ã¶rnekte:
- `@RequestParam` ile `category` ve `price` sorgu parametreleri URL'den alÄ±nÄ±r.
- `category` deÄŸeri `"electronics"` ve `price` deÄŸeri `100` olarak atanÄ±r.

**Ã–zellikleri**:
- **Ä°steÄŸe BaÄŸlÄ± YapÄ±landÄ±rma**: `@RequestParam` isteÄŸe baÄŸlÄ± olarak yapÄ±landÄ±rÄ±labilir. Parametre zorunlu deÄŸilse `required = false` olarak ayarlanabilir ve varsayÄ±lan bir deÄŸer belirtilebilir.
- **Sorgu Parametreleri Ä°Ã§in KullanÄ±lÄ±r**: `@RequestParam`, URL'nin sorgu kÄ±smÄ±ndan parametre almak iÃ§in idealdir.

### `@PathVariable` Nedir?

`@PathVariable`, **URL yolunun (path) bir parÃ§asÄ±nÄ±** parametre olarak almak iÃ§in kullanÄ±lÄ±r. Bu yÃ¶ntem, Ã¶zellikle RESTful APIâ€™lerde, belirli bir kaynaÄŸÄ± benzersiz bir kimlik veya Ã¶zellik ile almak iÃ§in tercih edilir.

**Ã–rnek KullanÄ±m**:
URL: `http://example.com/api/products/5`

```java
@GetMapping("/products/{id}")
public String getProduct(@PathVariable int id) {
    // id = 5
    return "Product ID: " + id;
}
```

YukarÄ±daki Ã¶rnekte:
- `@PathVariable` ile `id` parametresi URL'den alÄ±nÄ±r.
- `id` deÄŸeri `5` olarak atanÄ±r.

**Ã–zellikleri**:
- **Dinamik Yol Parametreleri Ä°Ã§in KullanÄ±lÄ±r**: `@PathVariable`, URLâ€™nin bir parÃ§asÄ± olan ve kaynaklarÄ± temsil eden parametreler iÃ§in kullanÄ±lÄ±r.
- **Daha OkunaklÄ± URL YapÄ±sÄ±**: `@PathVariable` ile dinamik yollar oluÅŸturulabilir; bu da RESTful API tasarÄ±mÄ±nda daha okunabilir ve anlamlÄ± URL yapÄ±larÄ± saÄŸlar.

### `@RequestParam` ile `@PathVariable` ArasÄ±ndaki Farklar

| Ã–zellik            | @RequestParam                                  | @PathVariable                               |
|--------------------|-----------------------------------------------|--------------------------------------------|
| **KullanÄ±m Yeri**  | Sorgu parametreleri (`?`)                     | URL yolundaki dinamik parametreler (`/{}`) |
| **AmaÃ§**           | Parametre deÄŸerleri sorgu parametrelerinden almak iÃ§in | URL yolunun bir parÃ§asÄ±nÄ± almak iÃ§in       |
| **Zorunluluk**     | `required` ile isteÄŸe baÄŸlÄ± yapÄ±labilir        | Zorunludur (yolun bir parÃ§asÄ± olarak)      |
| **Ã–rnek URL**      | `/products?category=electronics`              | `/products/electronics`                    |

### Hangi Durumda Hangisini KullanmalÄ±yÄ±m?

1. **Kimlik (ID) veya Kaynak BelirteÃ§leri Ä°Ã§in**: Belirli bir kaynaÄŸÄ± benzersiz bir kimlik ile alÄ±yorsanÄ±z (Ã¶rneÄŸin, `productId` veya `userId` gibi), `@PathVariable` kullanmak daha iyi bir yaklaÅŸÄ±mdÄ±r. Bu, daha temiz ve okunabilir bir URL saÄŸlar. Ã–rneÄŸin:
   ```java
   @GetMapping("/users/{id}")
   public User getUserById(@PathVariable Long id) {
       return userService.findUserById(id);
   }
   ```

2. **Filtreleme veya Arama Ä°Ã§in**: EÄŸer bir liste Ã¼zerinde filtreleme veya arama iÅŸlemi yapÄ±yorsanÄ±z, `@RequestParam` kullanmanÄ±z daha uygundur. Ã–rneÄŸin:
   ```java
   @GetMapping("/products")
   public List<Product> getProducts(@RequestParam(required = false) String category,
                                    @RequestParam(required = false, defaultValue = "0") int minPrice) {
       return productService.findProducts(category, minPrice);
   }
   ```

3. **URL YapÄ±sÄ± ve Okunabilirlik**: RESTful API tasarÄ±mÄ± iÃ§in `@PathVariable`, kaynak belirleme anlamÄ±nda daha okunabilir URL yapÄ±sÄ± saÄŸlar. Ã–rneÄŸin:
    - `@GetMapping("/orders/{orderId}")` â€“ Belirli bir sipariÅŸin ayrÄ±ntÄ±larÄ±na ulaÅŸmak iÃ§in.

4. **Parametrelerin ZorunluluÄŸu**: `@RequestParam`, isteÄŸe baÄŸlÄ± (`required=false`) olarak yapÄ±landÄ±rÄ±labilir ve varsayÄ±lan deÄŸer atanabilir. `@PathVariable` ise URL yolunun bir parÃ§asÄ± olduÄŸundan zorunludur.

### Ã–zet

- **KaynaklarÄ± belirlemek iÃ§in** `@PathVariable` kullanÄ±lÄ±r.
- **Sorgu veya filtre parametreleri iÃ§in** `@RequestParam` kullanÄ±lÄ±r.
- RESTful APIâ€™lerde kimlikleri `@PathVariable` ile, opsiyonel sorgu parametrelerini ise `@RequestParam` ile almak iyi bir pratiktir.

## Java 8 ile gelen Stream API
```sh 

```
---


Java 8 ile gelen **Stream API**, veri iÅŸlemlerini daha etkili, temiz ve okunabilir bir ÅŸekilde yapmayÄ± saÄŸlayan bir araÃ§tÄ±r. `Stream`ler, bir veri kaynaÄŸÄ± (koleksiyonlar, diziler veya dosyalar gibi) Ã¼zerinde iÅŸlem yapmamÄ±za olanak tanÄ±yan bir dizi metottan oluÅŸur. Stream API, Ã¶zellikle koleksiyonlar Ã¼zerindeki sÄ±ralama, filtreleme, dÃ¶nÃ¼ÅŸtÃ¼rme ve toplama iÅŸlemlerini Ã§ok daha kolay hale getirir. Java 8 ile gelen fonksiyonel programlama Ã¶zellikleri sayesinde `Stream`ler, geleneksel `for` dÃ¶ngÃ¼leri ve `iterator` iÅŸlemlerine daha modern bir alternatif sunar.

### Stream APIâ€™nin Temel Ã–zellikleri

1. **Fonksiyonel Programlama MantÄ±ÄŸÄ± ile Ã‡alÄ±ÅŸÄ±r**: Java 8 ile gelen lambda ifadeleri ile Stream iÅŸlemleri kolaylaÅŸÄ±r. Lambda ile ifade edilen kÄ±sa ve etkili iÅŸlemler sayesinde daha az kodla daha Ã§ok iÅŸ yapÄ±labilir.
2. **Ä°ÅŸlem Zinciri (Pipeline) MantÄ±ÄŸÄ±**: Streamâ€™ler, bir veri kaynaÄŸÄ±ndan veri alÄ±r ve bu veri Ã¼zerinde Ã§eÅŸitli iÅŸlemler uygular. Bu iÅŸlemler birbirine baÄŸlÄ±dÄ±r ve bir zincir (pipeline) olarak ifade edilir.
3. **Tek KullanÄ±mlÄ±k YapÄ±**: Bir `Stream`, yalnÄ±zca bir kez tÃ¼ketilebilir; yeniden kullanÄ±lamaz. Bu nedenle bir `Stream` ile bir kez iÅŸlem yapÄ±ldÄ±ÄŸÄ±nda, baÅŸka bir iÅŸlem iÃ§in yeni bir `Stream` oluÅŸturmak gerekir.
4. **DÃ¶nÃ¼ÅŸtÃ¼rÃ¼lebilirlik**: `Stream`ler, veri kaynaÄŸÄ±nÄ± deÄŸiÅŸtirmez, verileri iÅŸleyerek yeni `Stream` veya sonuÃ§lar Ã¼retir. `Stream` nesnesini koleksiyonlara veya diÄŸer veri yapÄ±larÄ±na dÃ¶nÃ¼ÅŸtÃ¼rebiliriz.
5. **Paralel Ä°ÅŸlem DesteÄŸi**: `Stream` API, paralel iÅŸlemler iÃ§in gÃ¼Ã§lÃ¼ bir destek saÄŸlar. Bu, bÃ¼yÃ¼k veri kÃ¼meleri Ã¼zerinde iÅŸlemleri hÄ±zlandÄ±rmak iÃ§in Ã¶nemlidir.

### Stream TÃ¼rleri

1. **SÄ±ralÄ± (Sequential) Stream**: Veriler sÄ±rayla iÅŸlenir. `Collection.stream()` metodu ile elde edilir. Bu tÃ¼rde iÅŸlemler, veri sÄ±rasÄ±na sadÄ±k kalarak tek bir iÅŸ parÃ§acÄ±ÄŸÄ± (thread) Ã¼zerinde Ã§alÄ±ÅŸÄ±r.
2. **Paralel (Parallel) Stream**: Veriler paralel olarak iÅŸlenir ve performansÄ± artÄ±rmak iÃ§in Ã§ok Ã§ekirdekli iÅŸlemcilerin gÃ¼cÃ¼nden yararlanÄ±r. `Collection.parallelStream()` metodu ile elde edilir.

### Streamâ€™in Ã‡alÄ±ÅŸma MantÄ±ÄŸÄ±: Ara ve Terminal Ä°ÅŸlemler

Stream iÅŸlemleri ikiye ayrÄ±lÄ±r: **ara (intermediate)** ve **terminal iÅŸlemler**.

#### 1. Ara Ä°ÅŸlemler (Intermediate Operations)
Ara iÅŸlemler, bir `Stream` Ã¼zerinde dÃ¶nÃ¼ÅŸÃ¼m veya filtreleme gibi iÅŸlemler yapar ve yeni bir `Stream` dÃ¶ner. Bu iÅŸlemler "lazy" (tembel) olarak deÄŸerlendirilir; yani, ara iÅŸlemler tek baÅŸlarÄ±na Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda iÅŸlem yapÄ±lmaz, ancak bir terminal iÅŸlem Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda zincirdeki tÃ¼m ara iÅŸlemler gerÃ§ekleÅŸtirilir.

BaÅŸlÄ±ca ara iÅŸlemler:
- **filter(Predicate)**: Veriyi belirli bir koÅŸula gÃ¶re filtreler.
- **map(Function)**: Her Ã¶ÄŸe Ã¼zerinde dÃ¶nÃ¼ÅŸÃ¼m yapar ve her bir Ã¶ÄŸeyi bir diÄŸerine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
- **sorted() veya sorted(Comparator)**: Veriyi doÄŸal sÄ±ralama veya Ã¶zel bir `Comparator` ile sÄ±ralar.
- **distinct()**: AynÄ± olan Ã¶ÄŸeleri kaldÄ±rÄ±r (tekrarlÄ± Ã¶ÄŸeleri kaldÄ±rÄ±r).
- **limit(long)**: Ä°lk belirtilen sayÄ±da elemanÄ± alÄ±r.
- **skip(long)**: Ä°lk belirtilen sayÄ±da elemanÄ± atlar.

Ã–rnek:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());
System.out.println(evenNumbers); // Ã‡Ä±ktÄ±: [2, 4, 6, 8, 10]
```

YukarÄ±daki Ã¶rnekte, `filter` ara iÅŸlemi ile yalnÄ±zca Ã§ift sayÄ±lar seÃ§ilmiÅŸ ve yeni bir `Stream` olarak iÅŸlenmiÅŸtir.

#### 2. Terminal Ä°ÅŸlemler (Terminal Operations)
Terminal iÅŸlemler, bir `Stream` Ã¼zerindeki iÅŸlemleri sonlandÄ±rÄ±r ve `Stream` iÅŸ akÄ±ÅŸÄ±nÄ±n sonuÃ§larÄ±nÄ± dÃ¶ner. Terminal iÅŸlemler Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, `Stream` Ã¼zerindeki ara iÅŸlemler gerÃ§ekleÅŸtirilir ve terminal iÅŸlemle birlikte sonlandÄ±rÄ±lÄ±r.

BaÅŸlÄ±ca terminal iÅŸlemler:
- **forEach(Consumer)**: Her bir Ã¶ÄŸeyi belirtilen iÅŸlem ile iÅŸler.
- **collect(Collector)**: `Stream` sonuÃ§larÄ±nÄ± bir koleksiyona veya diÄŸer veri yapÄ±larÄ±na toplar.
- **reduce(BinaryOperator)**: `Stream` Ã¶ÄŸelerini indirger ve tek bir sonuÃ§ dÃ¶ner.
- **count()**: `Stream` Ã¼zerindeki Ã¶ÄŸe sayÄ±sÄ±nÄ± dÃ¶ner.
- **anyMatch(Predicate), allMatch(Predicate), noneMatch(Predicate)**: Belirli koÅŸullara gÃ¶re `boolean` sonuÃ§ dÃ¶ner.

Ã–rnek:
```java
List<String> names = Arrays.asList("Ali", "Ahmet", "AyÅŸe", "Mehmet");
String concatenatedNames = names.stream()
                                .filter(name -> name.startsWith("A"))
                                .collect(Collectors.joining(", "));
System.out.println(concatenatedNames); // Ã‡Ä±ktÄ±: Ali, Ahmet, AyÅŸe
```

### Stream Ä°ÅŸlemlerinin Ã–zellikleri ve KullanÄ±m DurumlarÄ±

1. **Filtreleme**: `filter` ile belirli koÅŸullara gÃ¶re eleme yapÄ±lÄ±r.
2. **DÃ¶nÃ¼ÅŸtÃ¼rme**: `map` ile bir veri kaynaÄŸÄ±ndaki veriler baÅŸka bir veri tipine veya ÅŸekle dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r. Ã–rneÄŸin, `String` listesindeki her bir Ã¶ÄŸeyi bÃ¼yÃ¼k harfe Ã§evirmek iÃ§in `map` kullanÄ±labilir.
3. **Toplama Ä°ÅŸlemleri**: `collect` ile bir `Stream`, liste, kÃ¼me, harita gibi veri yapÄ±larÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lebilir.
4. **BirleÅŸtirme ve Ä°ndirgeme (Reduction)**: `reduce` ile `Stream` Ã¶ÄŸeleri tek bir deÄŸere indirgenebilir. Ã–rneÄŸin, bir sayÄ± listesindeki sayÄ±larÄ±n toplamÄ±nÄ± bulmak.
5. **SÄ±ralama ve SÄ±nÄ±rlama**: `sorted` ile sÄ±ralama, `limit` ile eleman sayÄ±sÄ±nÄ± sÄ±nÄ±rlandÄ±rma yapÄ±lÄ±r.

Ã–rnek:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                 .reduce(0, Integer::sum);
System.out.println(sum); // Ã‡Ä±ktÄ±: 15
```

### Parallel Stream ile Paralel Ä°ÅŸlemler

`Stream API`, Ã§ok Ã§ekirdekli sistemlerde iÅŸlemleri paralel hale getirmeyi destekler. `parallelStream()` kullanarak iÅŸlemleri paralel hale getirip performansÄ± artÄ±rabilirsiniz. Ancak, paralel iÅŸlemler her durumda verim saÄŸlamayabilir; bu yÃ¼zden dikkatli kullanÄ±lmalÄ±dÄ±r.

Ã–rnek:
```java
List<Integer> largeList = Arrays.asList(â€¦); // BÃ¼yÃ¼k bir liste
long count = largeList.parallelStream()
                      .filter(n -> n % 2 == 0)
                      .count();
System.out.println("Ã‡ift sayÄ± adedi: " + count);
```

### Stream APIâ€™nin SaÄŸladÄ±ÄŸÄ± Avantajlar

- **Kodun OkunabilirliÄŸi**: `Stream` ile yazÄ±lan kod daha kÄ±sa ve daha okunaklÄ±dÄ±r.
- **Performans ArtÄ±ÅŸÄ±**: Paralel `Stream` ile bÃ¼yÃ¼k veri setlerinde performans artÄ±ÅŸÄ± saÄŸlanabilir.
- **Fonksiyonel Programlama**: Lambda ifadeleri ile veri iÅŸleme daha basit hale gelir.
- **Ä°mmutability**: `Stream` iÅŸlemleri veriyi deÄŸiÅŸtirmez, yalnÄ±zca yeni bir `Stream` veya sonuÃ§ Ã¼retir.

### Stream API Ä°le Koleksiyon Ä°ÅŸlemleri

Koleksiyonlar Ã¼zerinde `Stream API` kullanÄ±mÄ±, verileri iÅŸlemek iÃ§in dÃ¶ngÃ¼ veya `iterator` kullanmaya gÃ¶re daha iÅŸlevseldir. Geleneksel yÃ¶ntemde bir liste Ã¼zerinde filtreleme yapmak iÃ§in `for` dÃ¶ngÃ¼sÃ¼ ile `if` kontrolleri yazmanÄ±z gerekirdi. `Stream` ile bu iÅŸlemler daha sade hale gelir.

Ã–rnek:
```java
List<Person> people = Arrays.asList(
    new Person("John", 25),
    new Person("Jane", 22),
    new Person("Jack", 30)
);

List<Person> filteredPeople = people.stream()
                                    .filter(person -> person.getAge() > 23)
                                    .collect(Collectors.toList());
System.out.println(filteredPeople);
```

Bu Ã¶rnekte, `Stream API`, bir `for` dÃ¶ngÃ¼sÃ¼ne kÄ±yasla daha sade ve anlaÅŸÄ±lÄ±rdÄ±r.

### SonuÃ§

Java 8 `Stream API`, veri iÅŸlemeyi daha kolay ve etkili hale getiren gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r. Fonksiyonel programlama yetenekleri, paralel iÅŸlem desteÄŸi ve veri kaynaÄŸÄ±nÄ± deÄŸiÅŸtirmeden iÅŸleme olanaklarÄ±yla modern Java geliÅŸtirmede vazgeÃ§ilmez hale gelmiÅŸtir. `Stream`ler, Ã¶zellikle bÃ¼yÃ¼k ve karmaÅŸÄ±k veri iÅŸleme gÃ¶revlerinde daha az kod yazarak daha



## Java 8 Stream API'nin saÄŸladÄ±ÄŸÄ± metotlar
```sh 

```
---

Java 8 Stream API'nin saÄŸladÄ±ÄŸÄ± metotlar, veri iÅŸleme akÄ±ÅŸÄ±nÄ± daha okunabilir ve etkili hale getiren birÃ§ok farklÄ± iÅŸlem sunar. Bu metotlar, genellikle iki ana kategoriye ayrÄ±lÄ±r: **Ara Ä°ÅŸlemler (Intermediate Operations)** ve **Terminal Ä°ÅŸlemler (Terminal Operations)**. Ä°ÅŸte en yaygÄ±n kullanÄ±lan Stream API metotlarÄ± ve aÃ§Ä±klamalarÄ±:

### Ara Ä°ÅŸlemler (Intermediate Operations)

Ara iÅŸlemler, bir `Stream` Ã¼zerinde dÃ¶nÃ¼ÅŸÃ¼m veya filtreleme gibi iÅŸlemler yapar ve yeni bir `Stream` dÃ¶ner. Bu iÅŸlemler, tembel (lazy) olarak deÄŸerlendirilir, yani yalnÄ±zca bir terminal iÅŸlem Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda etkin hale gelirler.

1. **`filter(Predicate<? super T> predicate)`**: Streamâ€™deki Ã¶ÄŸeleri belirtilen koÅŸula gÃ¶re filtreler. Predicate (koÅŸul) saÄŸlanÄ±r ve bu koÅŸulu saÄŸlayan Ã¶ÄŸeler yeni bir `Stream` olarak dÃ¶ner.

   ```java
   stream.filter(n -> n > 10);
   ```

2. **`map(Function<? super T, ? extends R> mapper)`**: Her bir Ã¶ÄŸe Ã¼zerinde dÃ¶nÃ¼ÅŸÃ¼m iÅŸlemi yapar ve yeni bir `Stream` dÃ¶ner. Ã–ÄŸeleri bir veri tipinden baÅŸka bir veri tipine dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lÄ±r.

   ```java
   stream.map(String::toUpperCase);
   ```

3. **`flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`**: Her bir Ã¶ÄŸeyi bir `Stream`'e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r ve bu `Stream`leri tek bir `Stream` olarak birleÅŸtirir. Bir koleksiyonun iÃ§indeki koleksiyonlarÄ± dÃ¼zleÅŸtirmek iÃ§in kullanÄ±lÄ±r.

   ```java
   stream.flatMap(list -> list.stream());
   ```

4. **`distinct()`**: Stream'deki tekrarlÄ± (aynÄ±) Ã¶ÄŸeleri kaldÄ±rÄ±r ve benzersiz Ã¶ÄŸelerden oluÅŸan bir `Stream` dÃ¶ner.

   ```java
   stream.distinct();
   ```

5. **`sorted()`**: Stream'deki Ã¶ÄŸeleri doÄŸal sÄ±raya gÃ¶re sÄ±ralar. EÄŸer Ã¶ÄŸeler `Comparable` deÄŸilse, `Comparator` parametresiyle sÄ±ralama yapÄ±labilir.

   ```java
   stream.sorted();
   ```

6. **`sorted(Comparator<? super T> comparator)`**: Verilen `Comparator`'a gÃ¶re Ã¶ÄŸeleri sÄ±ralar. Ã–zel sÄ±ralama iÅŸlemleri iÃ§in kullanÄ±lÄ±r.

   ```java
   stream.sorted(Comparator.reverseOrder());
   ```

7. **`limit(long maxSize)`**: Streamâ€™in ilk belirtilen sayÄ±da (`maxSize`) Ã¶ÄŸesini alÄ±r ve yeni bir `Stream` dÃ¶ner.

   ```java
   stream.limit(5);
   ```

8. **`skip(long n)`**: Streamâ€™in ilk `n` Ã¶ÄŸesini atlar ve geriye kalan Ã¶ÄŸelerle yeni bir `Stream` dÃ¶ner.

   ```java
   stream.skip(3);
   ```

9. **`peek(Consumer<? super T> action)`**: Stream Ã¼zerinde iÅŸlem yaparken, her bir Ã¶ÄŸeyi gÃ¶zlemlemek iÃ§in kullanÄ±lÄ±r. Veriyi deÄŸiÅŸtirmez; debug amaÃ§lÄ± veya yan etkiler eklemek iÃ§in kullanÄ±labilir.

   ```java
   stream.peek(System.out::println);
   ```

### Terminal Ä°ÅŸlemler (Terminal Operations)

Terminal iÅŸlemler, bir `Stream` Ã¼zerindeki iÅŸlemleri sonlandÄ±rÄ±r ve bir sonuÃ§ dÃ¶ner. Terminal iÅŸlem Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda, ara iÅŸlemler de iÅŸlenmiÅŸ olur.

1. **`forEach(Consumer<? super T> action)`**: Streamâ€™deki her bir Ã¶ÄŸe Ã¼zerinde belirtilen iÅŸlemi uygular. DÃ¶nen bir sonuÃ§ yoktur.

   ```java
   stream.forEach(System.out::println);
   ```

2. **`collect(Collector<? super T, A, R> collector)`**: Stream Ã¶ÄŸelerini toplayarak bir koleksiyona veya baÅŸka bir sonuÃ§ tipine dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r. Genellikle `Collectors` yardÄ±mcÄ± sÄ±nÄ±fÄ± ile kullanÄ±lÄ±r.

   ```java
   List<Integer> list = stream.collect(Collectors.toList());
   ```

3. **`reduce(BinaryOperator<T> accumulator)`**: Streamâ€™deki Ã¶ÄŸeleri indirger ve tek bir sonuÃ§ dÃ¶ner. Bu, Ã¶rneÄŸin tÃ¼m sayÄ±larÄ±n toplamÄ±nÄ± veya Ã§arpÄ±mÄ±nÄ± bulmak iÃ§in kullanÄ±labilir.

   ```java
   int sum = stream.reduce(0, Integer::sum);
   ```

4. **`reduce(T identity, BinaryOperator<T> accumulator)`**: Belirli bir baÅŸlangÄ±Ã§ deÄŸeri (`identity`) ile indirgeme iÅŸlemi yapar. BaÅŸlangÄ±Ã§ deÄŸeri, iÅŸlemin ilk girdisi olarak kullanÄ±lÄ±r.

   ```java
   int sum = stream.reduce(0, (a, b) -> a + b);
   ```

5. **`count()`**: Streamâ€™deki Ã¶ÄŸelerin sayÄ±sÄ±nÄ± dÃ¶ner. Ã–zellikle filtreleme gibi iÅŸlemler sonrasÄ± kaÃ§ Ã¶ÄŸe olduÄŸunu bulmak iÃ§in kullanÄ±ÅŸlÄ±dÄ±r.

   ```java
   long count = stream.count();
   ```

6. **`anyMatch(Predicate<? super T> predicate)`**: Streamâ€™de en az bir Ã¶ÄŸenin belirtilen koÅŸulu saÄŸladÄ±ÄŸÄ±nÄ± kontrol eder. `boolean` dÃ¶ner.

   ```java
   boolean hasEven = stream.anyMatch(n -> n % 2 == 0);
   ```

7. **`allMatch(Predicate<? super T> predicate)`**: Streamâ€™deki tÃ¼m Ã¶ÄŸelerin belirtilen koÅŸulu saÄŸladÄ±ÄŸÄ±nÄ± kontrol eder. `boolean` dÃ¶ner.

   ```java
   boolean allPositive = stream.allMatch(n -> n > 0);
   ```

8. **`noneMatch(Predicate<? super T> predicate)`**: Streamâ€™deki hiÃ§bir Ã¶ÄŸenin belirtilen koÅŸulu saÄŸlamadÄ±ÄŸÄ±nÄ± kontrol eder. `boolean` dÃ¶ner.

   ```java
   boolean noneNegative = stream.noneMatch(n -> n < 0);
   ```

9. **`findFirst()`**: Streamâ€™deki ilk Ã¶ÄŸeyi dÃ¶ner. Optional olarak sonuÃ§ dÃ¶ner; eÄŸer boÅŸ bir `Stream` varsa sonuÃ§ `Optional.empty()` olur.

   ```java
   Optional<Integer> first = stream.findFirst();
   ```

10. **`findAny()`**: Streamâ€™deki herhangi bir Ã¶ÄŸeyi dÃ¶ner. Paralel `Stream`lerde performans optimizasyonu saÄŸlar. SonuÃ§ `Optional` olarak dÃ¶ner.

    ```java
    Optional<Integer> any = stream.findAny();
    ```

### Stream API KullanÄ±mÄ±na Dair Ã–zet

Java 8 Stream APIâ€™nin saÄŸladÄ±ÄŸÄ± bu metotlar, veri Ã¼zerinde filtreleme, dÃ¶nÃ¼ÅŸtÃ¼rme, sÄ±ralama, toplama ve daha fazlasÄ±nÄ± gerÃ§ekleÅŸtirmek iÃ§in idealdir. Stream iÅŸlemleri, veri Ã¼zerinde iÅŸlem yapmayÄ± Ã§ok daha basit ve etkili hale getirir, bu da kodun okunabilirliÄŸini ve bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r. Bu metotlarÄ±n iÅŸlevlerini doÄŸru bir ÅŸekilde anlayarak, veri iÅŸleme ihtiyaÃ§larÄ±nÄ±za gÃ¶re uygun `Stream` iÅŸlemlerini seÃ§ebilirsiniz.

## Spring Boot (@PostConstruct Annotation)
```sh 

```
---

Spring'de `@PostConstruct` ile constructor (yapÄ±cÄ± metod) arasÄ±nda temel farklar, uygulama baÅŸlatÄ±lÄ±rken bileÅŸenlerin ne zaman ve nasÄ±l hazÄ±rlandÄ±ÄŸÄ±yla ilgilidir. Ä°ÅŸte bu iki yÃ¶ntem arasÄ±ndaki farklar:

### 1. @PostConstruct Annotation
- `@PostConstruct`, bir sÄ±nÄ±fta `@Bean` olarak tanÄ±mlanan bileÅŸenin tÃ¼m baÄŸÄ±mlÄ±lÄ±klarÄ± enjekte edildikten hemen sonra Ã§alÄ±ÅŸtÄ±rÄ±lan bir metodu belirtir.
- Bu metot, Spring Bean Lifecycle (Spring Bean YaÅŸam DÃ¶ngÃ¼sÃ¼) iÃ§erisinde yer alÄ±r ve Spring Container, bileÅŸen hazÄ±r olduktan sonra `@PostConstruct` ile iÅŸaretlenmiÅŸ metodu Ã§aÄŸÄ±rÄ±r.
- `@PostConstruct`, genellikle bir bileÅŸenin baÄŸÄ±mlÄ±lÄ±klarÄ± saÄŸlandÄ±ktan sonra yapÄ±lan baÅŸlatma iÅŸlemlerini tanÄ±mlamak iÃ§in kullanÄ±lÄ±r.
- Ã–rneÄŸin, bir bileÅŸen yÃ¼klenirken bazÄ± veritabanÄ± kontrolleri veya Ã¶n yÃ¼klemeler yapÄ±lmasÄ± gerekiyorsa, bu iÅŸlemler `@PostConstruct` ile yapÄ±labilir.

### 2. Constructor
- Constructor, bir sÄ±nÄ±fÄ±n Ã¶rneÄŸi oluÅŸturulduÄŸunda ilk Ã§aÄŸrÄ±lan yapÄ±dÄ±r.
- `new` anahtar kelimesi ile Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda veya Spring Container tarafÄ±ndan oluÅŸturulduÄŸunda, sÄ±nÄ±fÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ± enjekte edilmeden Ã¶nce Ã§aÄŸrÄ±lÄ±r.
- Constructor iÃ§inde bileÅŸenler henÃ¼z tamamen hazÄ±r olmadÄ±ÄŸÄ±ndan, baÄŸÄ±mlÄ±lÄ±klara eriÅŸmek mÃ¼mkÃ¼n olmayabilir.
- Constructor, genellikle nesnenin ilk durumunu ayarlamak veya zorunlu baÄŸÄ±mlÄ±lÄ±klarÄ± inject etmeden Ã¶nce bazÄ± baÅŸlatma iÅŸlemleri yapmak iÃ§in kullanÄ±lÄ±r.

### FarklarÄ± Ã–zetlersek:
| Ã–zellik                 | Constructor                                  | @PostConstruct                               |
|-------------------------|----------------------------------------------|----------------------------------------------|
| Ã‡alÄ±ÅŸma ZamanÄ±          | Nesne oluÅŸturulduÄŸunda                       | BaÄŸÄ±mlÄ±lÄ±klar enjekte edildikten sonra       |
| BaÄŸÄ±mlÄ±lÄ±klara EriÅŸim   | BaÄŸÄ±mlÄ±lÄ±klar henÃ¼z enjekte edilmemiÅŸtir     | TÃ¼m baÄŸÄ±mlÄ±lÄ±klar enjekte edilmiÅŸtir         |
| KullanÄ±m AlanÄ±          | Nesneyi baÅŸlatmak ve gerekli baÄŸÄ±mlÄ±lÄ±klarÄ± inject etmek | HazÄ±r hale gelen nesne ile baÅŸlatma yapmak |
| KullanÄ±m Yeri           | TÃ¼m Java sÄ±nÄ±flarÄ±                           | Spring Beanâ€™leri                            |

### Ã–rnek:
```java
@Component
public class ExampleService {

    private final DependencyService dependencyService;

    // Constructor injection
    public ExampleService(DependencyService dependencyService) {
        this.dependencyService = dependencyService;
        System.out.println("Constructor Ã§aÄŸrÄ±ldÄ±.");
    }

    @PostConstruct
    public void init() {
        System.out.println("PostConstruct Ã§aÄŸrÄ±ldÄ±. BaÄŸÄ±mlÄ±lÄ±klar enjekte edilmiÅŸ durumda.");
        // dependencyService burada kullanÄ±labilir
    }
}
```

Bu Ã¶rnekte:
- **Constructor** Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda baÄŸÄ±mlÄ±lÄ±k enjekte edilmiÅŸ olsa da, `@PostConstruct` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda tÃ¼m bileÅŸenler eksiksiz olarak yÃ¼klenmiÅŸ durumdadÄ±r.

## Spring Boot (Injection)
```sh 

```
---

Spring'de **instance** oluÅŸturmak ve **injection** (baÄŸÄ±mlÄ±lÄ±k enjeksiyonu) farklÄ± iki yÃ¶ntemdir ve uygulamanÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± yÃ¶netme ÅŸekli aÃ§Ä±sÄ±ndan Ã¶nemli farklara sahiptir. Bu farklarÄ± inceleyelim:

### 1. Instance OluÅŸturmak
- Javaâ€™da **instance** (Ã¶rnek) oluÅŸturmak, `new` anahtar kelimesi kullanÄ±larak doÄŸrudan bir nesne oluÅŸturmak anlamÄ±na gelir. Ã–rneÄŸin, `MyService myService = new MyService();` ifadesi ile `MyService` sÄ±nÄ±fÄ±nÄ±n bir Ã¶rneÄŸi oluÅŸturulur.
- Bu yÃ¶ntemle oluÅŸturulan nesne **manuel** olarak oluÅŸturulur ve Spring Container tarafÄ±ndan yÃ¶netilmez.
- EÄŸer bir nesne manuel olarak oluÅŸturulursa, Spring'in baÄŸÄ±mlÄ±lÄ±k yÃ¶netimi, yaÅŸam dÃ¶ngÃ¼sÃ¼ kontrolleri veya diÄŸer Ã¶zelliklerinden yararlanÄ±lamaz.
- Bu yÃ¶ntem daha basit projelerde kullanÄ±labilir, ancak baÄŸÄ±mlÄ±lÄ±klarÄ±n manuel olarak yÃ¶netilmesi gerekir ve kod karmaÅŸÄ±k hale gelebilir.

### 2. Injection (BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu)
- **Injection** (BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu), Springâ€™in baÄŸÄ±mlÄ±lÄ±k yÃ¶netimini saÄŸlayan bir Ã¶zelliktir. Spring, nesneleri **otomatik olarak enjekte ederek** baÄŸÄ±mlÄ±lÄ±klarÄ± saÄŸlar.
- Injection iÅŸlemi Springâ€™in kendi yÃ¶netiminde olup, Spring Container tarafÄ±ndan otomatik olarak yapÄ±lÄ±r.
- Spring Container, uygulama Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda belirli kurallara gÃ¶re baÄŸÄ±mlÄ±lÄ±klarÄ± enjekte eder. Bu, sÄ±nÄ±f yapÄ±cÄ±larÄ± (constructor injection) veya alanlar (field injection) kullanÄ±larak yapÄ±labilir.
- **Constructor Injection** veya **@Autowired** gibi anotasyonlarla baÄŸÄ±mlÄ±lÄ±klar enjekte edilir.
- Injection sayesinde baÄŸÄ±mlÄ±lÄ±klarÄ±n yÃ¶netimi Spring Container tarafÄ±ndan yapÄ±lÄ±r, bu da uygulamayÄ± daha modÃ¼ler ve test edilebilir hale getirir.

### FarklarÄ± Ã–zetlersek:

| Ã–zellik                    | Instance OluÅŸturmak (new)                        | Injection (BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu)                |
|----------------------------|-------------------------------------------------|---------------------------------------------------|
| Nesne OluÅŸturma YÃ¶ntemi    | `new` anahtar kelimesi ile manuel               | Spring tarafÄ±ndan otomatik                        |
| Spring Container YÃ¶netimi  | YÃ¶netilmez                                      | Spring Container tarafÄ±ndan yÃ¶netilir             |
| BaÄŸÄ±mlÄ±lÄ±k YÃ¶netimi        | Manuel olarak yÃ¶netilmesi gerekir               | Otomatik olarak Spring tarafÄ±ndan saÄŸlanÄ±r        |
| Kod BakÄ±mÄ± ve ModÃ¼lerlik   | Daha zor ve daha fazla kodlama gerektirir       | Daha dÃ¼zenli, modÃ¼ler ve test edilebilir          |
| YaÅŸam DÃ¶ngÃ¼sÃ¼ Kontrolleri  | Spring yaÅŸam dÃ¶ngÃ¼sÃ¼nden baÄŸÄ±msÄ±zdÄ±r            | Spring Bean yaÅŸam dÃ¶ngÃ¼sÃ¼ kurallarÄ±na tabidir     |
| KullanÄ±m AlanÄ±             | Basit baÄŸÄ±mlÄ±lÄ±klar iÃ§in veya baÄŸÄ±msÄ±z nesneler | KarmaÅŸÄ±k baÄŸÄ±mlÄ±lÄ±klarÄ±n yÃ¶netimi iÃ§in idealdir   |

### Ã–rnek Kod ile AÃ§Ä±klama:

```java
// Manuel Instance OluÅŸturma
public class Application {

    public static void main(String[] args) {
        // MyService baÄŸÄ±mlÄ±lÄ±ÄŸÄ± manuel olarak oluÅŸturulur
        MyService myService = new MyService();
        myService.doSomething();
    }
}
```

YukarÄ±daki kodda, `MyService` nesnesi manuel olarak oluÅŸturulmuÅŸtur ve baÄŸÄ±mlÄ±lÄ±klar yÃ¶netilmez.

```java
// Spring Injection ile
@Component
public class MyService {
    
    public void doSomething() {
        System.out.println("Hizmet Ã§alÄ±ÅŸÄ±yor.");
    }
}

@Component
public class Application {

    private final MyService myService;

    // Constructor Injection
    public Application(MyService myService) {
        this.myService = myService;
    }

    public void run() {
        myService.doSomething();
    }
}
```

Bu Ã¶rnekte:
- Spring Container, `Application` sÄ±nÄ±fÄ±nÄ± baÅŸlattÄ±ÄŸÄ±nda `MyService` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± otomatik olarak enjekte eder.
- `@Component` anotasyonu sayesinde `MyService`, Spring tarafÄ±ndan yÃ¶netilen bir bean haline gelir.
- **Injection**, kodun daha temiz ve modÃ¼ler olmasÄ±nÄ± saÄŸlar, Ã§Ã¼nkÃ¼ baÄŸÄ±mlÄ±lÄ±klar `new` ile manuel olarak oluÅŸturulmamÄ±ÅŸ, Spring tarafÄ±ndan saÄŸlanmÄ±ÅŸtÄ±r.

### SonuÃ§:
Injection, Spring'in baÄŸÄ±mlÄ±lÄ±k yÃ¶netimini saÄŸladÄ±ÄŸÄ± bir mekanizmadÄ±r ve projelerde daha dÃ¼zenli, modÃ¼ler ve test edilebilir bir yapÄ± saÄŸlar. DiÄŸer yandan, instance oluÅŸturma yÃ¶ntemi manuel bir yÃ¶ntem olup daha basit projelerde kullanÄ±labilir, ancak baÄŸÄ±mlÄ±lÄ±klarÄ±n yÃ¶netimi kullanÄ±cÄ±ya bÄ±rakÄ±ldÄ±ÄŸÄ±ndan kod karmaÅŸÄ±k hale gelebilir.

## Spring Boot (Manuel BaÄŸÄ±mlÄ±lÄ±k)
```sh 

```
---

**BaÄŸÄ±mlÄ±lÄ±klarÄ±n manuel olarak yÃ¶netilmesi**, bir sÄ±nÄ±fÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± elle oluÅŸturarak veya elle enjekte ederek, yani Spring gibi bir baÄŸÄ±mlÄ±lÄ±k enjeksiyonu Ã§erÃ§evesine baÅŸvurmadan yÃ¶netilmesi anlamÄ±na gelir. Bu yÃ¶ntem, baÄŸÄ±mlÄ±lÄ±k yÃ¶netimini tamamen geliÅŸtiricinin sorumluluÄŸuna bÄ±rakÄ±r.

### Manuel BaÄŸÄ±mlÄ±lÄ±k YÃ¶netimi Nedir?
BaÄŸÄ±mlÄ±lÄ±klarÄ±n manuel olarak yÃ¶netilmesi, baÄŸÄ±mlÄ± sÄ±nÄ±flarÄ±n ihtiyaÃ§ duyduÄŸu nesnelerin `new` anahtar kelimesi ile oluÅŸturulmasÄ± ve bu baÄŸÄ±mlÄ±lÄ±klarÄ±n ilgili sÄ±nÄ±fa doÄŸrudan verilmesidir. GeliÅŸtirici, hangi nesnelerin nerede ve nasÄ±l kullanÄ±lacaÄŸÄ±nÄ± kodda aÃ§Ä±kÃ§a belirler. Bu yaklaÅŸÄ±m, baÄŸÄ±mlÄ±lÄ±k enjeksiyonuna alternatif bir yÃ¶ntemdir ancak bazÄ± dezavantajlara sahiptir.

### Manuel BaÄŸÄ±mlÄ±lÄ±k YÃ¶netiminin DezavantajlarÄ±
1. **Kod TekrarÄ± ve DaÄŸÄ±nÄ±klÄ±ÄŸÄ±**: BaÄŸÄ±mlÄ±lÄ±klarÄ± manuel olarak yÃ¶netmek, kodda `new` anahtar kelimesi ile Ã§ok sayÄ±da nesne oluÅŸturulmasÄ±na ve aynÄ± nesnenin birÃ§ok yerde tekrar tekrar tanÄ±mlanmasÄ±na neden olabilir. Bu da kodun okunabilirliÄŸini azaltÄ±r ve bakÄ±mÄ±nÄ± zorlaÅŸtÄ±rÄ±r.

2. **GevÅŸek BaÄŸlÄ±lÄ±k EksikliÄŸi**: BaÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile baÄŸÄ±mlÄ±lÄ±klarÄ± otomatik olarak yÃ¶neten Ã§erÃ§eveler, sÄ±nÄ±flarÄ±n birbirine daha az baÄŸÄ±mlÄ± (gevÅŸek baÄŸlÄ±) olmasÄ±nÄ± saÄŸlar. Manuel yÃ¶ntemle nesneler sÄ±kÄ± sÄ±kÄ±ya birbirine baÄŸlÄ± olur, bu da bir sÄ±nÄ±fta yapÄ±lan bir deÄŸiÅŸikliÄŸin diÄŸer sÄ±nÄ±flarÄ± etkilemesine yol aÃ§abilir.

3. **Test Edilebilirlik**: Manuel baÄŸÄ±mlÄ±lÄ±k yÃ¶netimi, birim testlerini zorlaÅŸtÄ±rÄ±r. Bir sÄ±nÄ±fÄ±n baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± test sÄ±rasÄ±nda mock (sahte) nesneler ile deÄŸiÅŸtirmek zor olabilir Ã§Ã¼nkÃ¼ baÄŸÄ±mlÄ±lÄ±klar sÄ±nÄ±f iÃ§inde doÄŸrudan `new` anahtar kelimesi ile oluÅŸturulmuÅŸtur. Bu da test sÄ±rasÄ±nda sÄ±nÄ±flarÄ± izole etmeyi zorlaÅŸtÄ±rÄ±r.

4. **YaÅŸam DÃ¶ngÃ¼sÃ¼ YÃ¶netimi**: Spring gibi baÄŸÄ±mlÄ±lÄ±k enjeksiyonu Ã§erÃ§eveleri, nesnelerin yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netir ve nesneler yalnÄ±zca ihtiyaÃ§ duyulduÄŸunda oluÅŸturulur. Manuel baÄŸÄ±mlÄ±lÄ±k yÃ¶netiminde, geliÅŸtirici bu yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netmek zorundadÄ±r, ki bu da gereksiz bellek kullanÄ±mÄ± veya performans sorunlarÄ±na yol aÃ§abilir.

### Manuel BaÄŸÄ±mlÄ±lÄ±k YÃ¶netimine Ã–rnek

Ã–rneÄŸin, bir `DatabaseService` sÄ±nÄ±fÄ±nÄ±n bir `UserService` sÄ±nÄ±fÄ±nda manuel olarak yÃ¶netildiÄŸini dÃ¼ÅŸÃ¼nelim:

```java
public class DatabaseService {
    public void connect() {
        System.out.println("VeritabanÄ±na baÄŸlanÄ±ldÄ±.");
    }
}

public class UserService {
    private DatabaseService databaseService;

    public UserService() {
        // DatabaseService baÄŸÄ±mlÄ±lÄ±ÄŸÄ± manuel olarak oluÅŸturuluyor
        this.databaseService = new DatabaseService();
    }

    public void performDatabaseOperation() {
        databaseService.connect();
    }
}
```

YukarÄ±daki kodda:
- `UserService` sÄ±nÄ±fÄ±, `DatabaseService` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± kendisi yÃ¶netmektedir. Bu baÄŸÄ±mlÄ±lÄ±k `UserService` sÄ±nÄ±fÄ± iÃ§inde manuel olarak oluÅŸturulmuÅŸ, yani Spring gibi bir enjeksiyon Ã§erÃ§evesi kullanÄ±lmamÄ±ÅŸtÄ±r.
- `UserService` iÃ§inde `DatabaseService` nesnesi manuel olarak `new` anahtar kelimesi ile baÅŸlatÄ±lmÄ±ÅŸtÄ±r. Bu durum sÄ±nÄ±flar arasÄ±nda sÄ±kÄ± bir baÄŸ oluÅŸturur ve baÄŸÄ±mlÄ±lÄ±k enjeksiyonu yapÄ±lmadÄ±ÄŸÄ± iÃ§in kod daha az esnek hale gelir.

### Manuel BaÄŸÄ±mlÄ±lÄ±k YÃ¶netimine Alternatif: BaÄŸÄ±mlÄ±lÄ±k Enjeksiyonu
Spring ile aynÄ± Ã¶rnek baÄŸÄ±mlÄ±lÄ±k enjeksiyonu ile yÃ¶netildiÄŸinde kod daha temiz ve modÃ¼ler hale gelir:

```java
@Component
public class DatabaseService {
    public void connect() {
        System.out.println("VeritabanÄ±na baÄŸlanÄ±ldÄ±.");
    }
}

@Component
public class UserService {
    private final DatabaseService databaseService;

    // Constructor Injection
    @Autowired
    public UserService(DatabaseService databaseService) {
        this.databaseService = databaseService;
    }

    public void performDatabaseOperation() {
        databaseService.connect();
    }
}
```

YukarÄ±daki Ã¶rnekte:
- Spring Container, `DatabaseService` nesnesini `UserService` iÃ§ine otomatik olarak enjekte eder.
- `@Autowired` anotasyonu kullanÄ±larak `UserService` sÄ±nÄ±fÄ± baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± doÄŸrudan `new` ile yÃ¶netmek yerine Spring Containerâ€™a bÄ±rakÄ±r.
- Bu yaklaÅŸÄ±m, kodun daha modÃ¼ler, esnek ve test edilebilir olmasÄ±nÄ± saÄŸlar.

### SonuÃ§
Manuel baÄŸÄ±mlÄ±lÄ±k yÃ¶netimi, baÄŸÄ±mlÄ±lÄ±klarÄ±n doÄŸrudan kod iÃ§inde `new` ile oluÅŸturulmasÄ± ve yÃ¶netilmesi anlamÄ±na gelir. Ancak bu yÃ¶ntem, kodun karmaÅŸÄ±k hale gelmesine ve bakÄ±mÄ±nÄ±n zorlaÅŸmasÄ±na neden olabilir. Spring gibi baÄŸÄ±mlÄ±lÄ±k enjeksiyon araÃ§larÄ±, baÄŸÄ±mlÄ±lÄ±klarÄ± yÃ¶neterek kodu daha esnek, test edilebilir ve modÃ¼ler hale getirir.

## Spring Data (@EmbeddedId)
```sh 

```
---

Spring Boot ile Ã§alÄ±ÅŸÄ±rken bir entity iÃ§inde birden fazla IDâ€™ye sahip olmak istediÄŸimizde, genellikle **@EmbeddedId** veya **@IdClass** yaklaÅŸÄ±mlarÄ±nÄ± kullanarak bunu yÃ¶netiriz. Bu, Ã¶zellikle **birleÅŸtirilmiÅŸ anahtar** (composite key) veya **iÅŸlemsel olarak birden fazla kimlik alanÄ±** gerektiÄŸinde kullanÄ±lÄ±r. AÅŸaÄŸÄ±da bu yÃ¶ntemlerin her birini detaylÄ± olarak ele alacaÄŸÄ±m.

### 1. @EmbeddedId Kullanarak Birden Fazla ID YÃ¶netimi

**@EmbeddedId** anotasyonu, bir entity iÃ§inde birleÅŸtirilmiÅŸ bir anahtar oluÅŸturmak iÃ§in kullanÄ±lÄ±r. Burada, anahtar olarak kullanÄ±lacak tÃ¼m alanlarÄ± kapsayan bir sÄ±nÄ±f tanÄ±mlarÄ±z ve entity sÄ±nÄ±fÄ±nda bu sÄ±nÄ±fÄ± **@EmbeddedId** ile iÅŸaretleriz.

#### Ã–rnek:
VarsayalÄ±m ki bir **OrderItem** entity sÄ±nÄ±fÄ±mÄ±z var ve bu sÄ±nÄ±f **orderId** ve **productId** alanlarÄ± ile birleÅŸtirilmiÅŸ bir anahtara sahip olacak.

1. **Anahtar sÄ±nÄ±fÄ±nÄ± tanÄ±mla:**

   ```java
   @Embeddable
   public class OrderItemKey implements Serializable {
       private Long orderId;
       private Long productId;

       // Getter ve Setter'lar, hashCode() ve equals() metotlarÄ± ekleyin
   }
   ```

    - **@Embeddable**: Anahtar sÄ±nÄ±fÄ±nÄ± tanÄ±mlamak iÃ§in bu anotasyonu kullanÄ±yoruz.
    - **Serializable**: BirleÅŸtirilmiÅŸ anahtar sÄ±nÄ±fÄ± mutlaka `Serializable` olmalÄ±dÄ±r.
    - **equals() ve hashCode()**: Bu metotlar, birleÅŸtirilmiÅŸ anahtar sÄ±nÄ±fÄ±nÄ±n benzersizliÄŸini saÄŸlamak iÃ§in gereklidir.

2. **Entity iÃ§inde @EmbeddedId kullanÄ±mÄ±:**

   ```java
   @Entity
   public class OrderItem {
       @EmbeddedId
       private OrderItemKey id;

       private int quantity;
       private BigDecimal price;

       // DiÄŸer alanlar ve getter/setter metotlarÄ±
   }
   ```

   Burada **OrderItemKey** sÄ±nÄ±fÄ±, **OrderItem** entity sÄ±nÄ±fÄ± iÃ§inde **@EmbeddedId** ile tanÄ±mlanmÄ±ÅŸtÄ±r. Bu sayede birleÅŸtirilmiÅŸ anahtar, **orderId** ve **productId** alanlarÄ±nÄ± iÃ§erir.

#### AvantajlarÄ±:
- Anahtar sÄ±nÄ±fÄ±nÄ± bir **@Embeddable** nesne olarak ayrÄ± bir sÄ±nÄ±f halinde tanÄ±mladÄ±ÄŸÄ±mÄ±z iÃ§in kod dÃ¼zeni saÄŸlanÄ±r.
- BirleÅŸtirilmiÅŸ anahtar kolayca entityâ€™e gÃ¶mÃ¼lebilir.

#### DezavantajlarÄ±:
- **@EmbeddedId** yÃ¶ntemi daha Ã§ok birleÅŸtirilmiÅŸ anahtarlarÄ±n yÃ¶netimi iÃ§in uygundur, ve bu yÃ¶ntemde ID deÄŸerlerinin entity iÃ§inde tek bir nesne olarak yÃ¶netilmesi gerekmektedir.

### 2. @IdClass Kullanarak Birden Fazla ID YÃ¶netimi

**@IdClass** anotasyonu, entity iÃ§inde birden fazla ID alanÄ± tanÄ±mlamak iÃ§in kullanÄ±lÄ±r. Bu yÃ¶ntemde birleÅŸtirilmiÅŸ anahtar alanlarÄ± entityâ€™nin iÃ§inde baÄŸÄ±msÄ±z deÄŸiÅŸkenler olarak tanÄ±mlanÄ±r. **@IdClass** kullanÄ±rken, bir **primary key** sÄ±nÄ±fÄ± oluÅŸturur ve bu sÄ±nÄ±fÄ± entityâ€™nin Ã¼stÃ¼ne **@IdClass** ile iÅŸaretleriz.

#### Ã–rnek:
Yine bir **OrderItem** entity sÄ±nÄ±fÄ± olduÄŸunu varsayalÄ±m, fakat burada **@IdClass** kullanacaÄŸÄ±z.

1. **Primary key sÄ±nÄ±fÄ±nÄ± tanÄ±mla:**

   ```java
   public class OrderItemId implements Serializable {
       private Long orderId;
       private Long productId;

       // Getter ve Setter'lar, hashCode() ve equals() metotlarÄ± ekleyin
   }
   ```

2. **Entity iÃ§inde @IdClass kullanÄ±mÄ±:**

   ```java
   @Entity
   @IdClass(OrderItemId.class)
   public class OrderItem {
       @Id
       private Long orderId;

       @Id
       private Long productId;

       private int quantity;
       private BigDecimal price;

       // DiÄŸer alanlar ve getter/setter metotlarÄ±
   }
   ```

   Bu Ã¶rnekte, **OrderItem** entityâ€™si, **orderId** ve **productId** alanlarÄ±nÄ± **@Id** ile baÄŸÄ±msÄ±z olarak tanÄ±mlar. **OrderItemId** sÄ±nÄ±fÄ± ise **@IdClass** ile belirtilir.

#### AvantajlarÄ±:
- BirleÅŸtirilmiÅŸ anahtarÄ±n tÃ¼m alanlarÄ± entity iÃ§inde baÄŸÄ±msÄ±z olarak tanÄ±mlanabilir.
- KarmaÅŸÄ±k birleÅŸtirilmiÅŸ anahtar yapÄ±larÄ±nÄ± yÃ¶netmek iÃ§in uygundur.

#### DezavantajlarÄ±:
- **@IdClass** kullanÄ±mÄ± daha fazla kod gerektirir ve **@EmbeddedId** kadar pratik deÄŸildir.
- **equals() ve hashCode()** metotlarÄ±nÄ±n dÃ¼zgÃ¼n bir ÅŸekilde tanÄ±mlanmasÄ± gerekir.

### Hangi YÃ¶ntem Ne Zaman KullanÄ±lmalÄ±?

| Durum                             | Tercih Edilecek Anotasyon |
|-----------------------------------|---------------------------|
| Basit birleÅŸtirilmiÅŸ anahtar      | **@EmbeddedId**          |
| Birden fazla baÄŸÄ±msÄ±z ID alanÄ±    | **@IdClass**             |
| Legacy veritabanÄ± yapÄ±sÄ±          | **@IdClass**             |

### Ã–zet

Spring Boot ve JPA iÃ§inde bir entityâ€™de birden fazla IDâ€™yi yÃ¶netmek iÃ§in **@EmbeddedId** ve **@IdClass** kullanabiliriz. **@EmbeddedId** daha dÃ¼zenli ve basit bir yaklaÅŸÄ±mdÄ±r ve anahtar olarak kullanÄ±lan alanlarÄ± tek bir nesnede toplar. **@IdClass** ise daha karmaÅŸÄ±k veya legacy veritabanÄ± yapÄ±larÄ± iÃ§in uygundur, her bir ID alanÄ±nÄ± baÄŸÄ±msÄ±z olarak tanÄ±mlama esnekliÄŸi saÄŸlar.

Her iki yÃ¶ntemde de ID yÃ¶netiminde doÄŸru bir ÅŸekilde `equals()` ve `hashCode()` metotlarÄ±nÄ± tanÄ±mlamayÄ± unutmamak Ã¶nemlidir, aksi halde JPA entity iliÅŸkilerinde beklenmeyen sorunlarla karÅŸÄ±laÅŸabilirsiniz.



## Design Pattern (Creational) tasarÄ±m desenleri)
```sh 

```
---
oluÅŸturÄ±m (Creational) tasarÄ±m desenleri, nesne oluÅŸturma sÃ¼reÃ§lerini yÃ¶netmek ve optimize etmek amacÄ±yla kullanÄ±lÄ±r. Bu desenler, nesne oluÅŸturmanÄ±n doÄŸrudan yapÄ±lmasÄ±ndan ziyade bir yapÄ± Ã¼zerinden yapÄ±lmasÄ±nÄ± saÄŸlar ve bÃ¶ylece sistemin esnekliÄŸini artÄ±rÄ±r.

Ä°ÅŸte baÅŸlÄ±ca oluÅŸturÄ±m desenleri:

1. **Singleton**
   - SÄ±nÄ±fÄ±n yalnÄ±zca bir Ã¶rneÄŸinin olmasÄ±nÄ± saÄŸlar ve global bir eriÅŸim noktasÄ± sunar.

2. **Factory Method (Fabrika Metodu)**
   - Alt sÄ±nÄ±flarÄ±n hangi sÄ±nÄ±fÄ±n Ã¶rneÄŸinin oluÅŸturulacaÄŸÄ±na karar vermesini saÄŸlayan bir arayÃ¼z tanÄ±mlar.

3. **Abstract Factory (Soyut Fabrika)**
   - Birbiriyle iliÅŸkili veya baÄŸÄ±mlÄ± nesne ailesi oluÅŸturan arayÃ¼z saÄŸlar ve hangi sÄ±nÄ±fÄ±n Ã¶rneÄŸinin oluÅŸturulacaÄŸÄ±na alt sÄ±nÄ±flar karar verir.

4. **Builder (Kurucu)**
   - Kompleks nesneleri adÄ±m adÄ±m oluÅŸturmak iÃ§in kullanÄ±lÄ±r ve nesnelerin farklÄ± gÃ¶sterimlerinden baÄŸÄ±msÄ±z olarak oluÅŸturulmasÄ±nÄ± saÄŸlar.

5. **Prototype (Prototip)**
   - Bir nesnenin Ã¶rneÄŸini klonlayarak kopyalar. Yeni nesneler oluÅŸturmak yerine var olan nesnelerden kopyalama yapÄ±lÄ±r.

Bu desenler, nesne oluÅŸturma sÃ¼reÃ§lerini daha esnek hale getirir ve kodun bakÄ±mÄ±nÄ± kolaylaÅŸtÄ±rÄ±r.


## Singleton tasarÄ±m deseni
```sh 

```
---

Java'da Singleton tasarÄ±m deseni, bir sÄ±nÄ±fÄ±n yalnÄ±zca bir Ã¶rneÄŸinin oluÅŸturulmasÄ±nÄ± saÄŸlar ve bu Ã¶rneÄŸe kÃ¼resel bir eriÅŸim noktasÄ± sunar. Bu desen, sistem genelinde belirli iÅŸlemleri koordine etmek iÃ§in yalnÄ±zca bir nesneye ihtiyaÃ§ duyulduÄŸunda faydalÄ±dÄ±r.

### Singleton TasarÄ±m Deseninin Ã–zellikleri
1. **Tek Ã–rnek**: Bir sÄ±nÄ±fÄ±n yalnÄ±zca bir "tek" Ã¶rneÄŸinin oluÅŸturulmasÄ±nÄ± kÄ±sÄ±tlar.
2. **KÃ¼resel EriÅŸim NoktasÄ±**: Ã–rneÄŸe kÃ¼resel bir eriÅŸim noktasÄ± saÄŸlar.
3. **Thread-Safe (Ä°ÅŸ ParÃ§acÄ±ÄŸÄ± GÃ¼venliÄŸi)**: Bu desen gerektiÄŸinde iÅŸ parÃ§acÄ±ÄŸÄ± gÃ¼venli olacak ÅŸekilde tasarlanabilir.
4. **Lazy Initialization (Tembel BaÅŸlatma)**: Ã–rnek yalnÄ±zca gerektiÄŸinde oluÅŸturulabilir.

### Java'da Singleton Deseninin Uygulama YÃ¶ntemleri

#### 1. Eager Initialization (HÄ±zlÄ± BaÅŸlatma)
Bu yÃ¶ntemde, Ã¶rnek sÄ±nÄ±f yÃ¼klendiÄŸinde oluÅŸturulur.

```java
public class Singleton {
    private static final Singleton instance = new Singleton();

    // Ã–zel bir yapÄ±cÄ± (constructor) ile dÄ±ÅŸardan nesne oluÅŸturulmasÄ± engellenir
    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

- **Avantajlar**: Basit ve thread-safe.
- **Dezavantajlar**: SÄ±nÄ±f yÃ¼klendiÄŸinde hemen Ã¶rnek oluÅŸturulur. Bu, Ã¶rneÄŸe her zaman ihtiyaÃ§ duyulmayacaksa kaynak israfÄ±na neden olabilir.

#### 2. Lazy Initialization (Tembel BaÅŸlatma)
Bu yÃ¶ntemde, Ã¶rnek yalnÄ±zca `getInstance()` Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda oluÅŸturulur.

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- **Avantajlar**: Ã–rnek yalnÄ±zca gerektiÄŸinde oluÅŸturulur, bu da kaynak kullanÄ±mÄ±nÄ± optimize eder.
- **Dezavantajlar**: Bu yÃ¶ntem thread-safe deÄŸildir; Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ±nda sorun Ã§Ä±karabilir.

#### 3. Thread-Safe Singleton
Thread-safe hale getirmek iÃ§in `synchronized` anahtar kelimesi kullanÄ±labilir.

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

- **Avantajlar**: Thread-safe olduÄŸu iÃ§in Ã§oklu iÅŸ parÃ§acÄ±ÄŸÄ± ortamÄ±nda gÃ¼venlidir.
- **Dezavantajlar**: `synchronized` anahtar kelimesi performansÄ± etkileyebilir.

#### 4. Double-Checked Locking (Ã‡ift Kontrol Kilitleme)
Hem tembel baÅŸlatmayÄ± hem de thread-safe yapÄ±yÄ± birleÅŸtirmek iÃ§in Ã§ift kontrol kilitleme uygulanabilir.

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

- **Avantajlar**: Hem thread-safe hem de tembel baÅŸlatma Ã¶zelliklerini saÄŸlar.
- **Dezavantajlar**: Kod biraz karmaÅŸÄ±ktÄ±r.

#### 5. Bill Pugh Singleton YÃ¶ntemi
Bu yÃ¶ntemde, iÃ§ sÄ±nÄ±f kullanarak tembel baÅŸlatma ve thread-safe Ã¶zelliklerini basit bir ÅŸekilde saÄŸlar.

```java
public class Singleton {
    private Singleton() {}

    private static class SingletonHelper {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

- **Avantajlar**: Hem thread-safe hem de tembel baÅŸlatma Ã¶zelliklerine sahip, ayrÄ±ca diÄŸer yÃ¶ntemlere gÃ¶re daha verimli.
- **Dezavantajlar**: Kodun anlaÅŸÄ±lmasÄ± biraz daha zor olabilir.

### Singleton Deseninin KullanÄ±m AlanlarÄ±
- **BaÄŸlantÄ± Havuzu (Connection Pool)**
- **YapÄ±landÄ±rma YÃ¶neticileri (Configuration Managers)**
- **Cache (Ã–nbellek)**
- **Loglama (Logging)**

Her bir yÃ¶ntem, farklÄ± kullanÄ±m senaryolarÄ± iÃ§in uygundur ve uygulamanÄ±n ihtiyaÃ§larÄ±na gÃ¶re seÃ§ilmelidir.


## IntelliJ IDEA'da sÄ±klÄ±kla kullanÄ±lan kÄ±sayollar
```sh 

```
---


Ä°ÅŸte IntelliJ IDEA'da sÄ±klÄ±kla kullanÄ±lan kÄ±sayollar ve aÃ§Ä±klamalarÄ±:

### 1. Kod Navigasyonu ve Arama
- **Class Bulma**:
   - **Windows/Linux**: `Ctrl + N`
   - **Mac**: `Command + O`
   - AÃ§Ä±klama: Projedeki herhangi bir sÄ±nÄ±fÄ± ada gÃ¶re arar.

- **Dosya Bulma**:
   - **Windows/Linux**: `Ctrl + Shift + N`
   - **Mac**: `Command + Shift + O`
   - AÃ§Ä±klama: Projedeki herhangi bir dosyayÄ± ada gÃ¶re arar.

- **Semboller ArasÄ±nda Arama**:
   - **Windows/Linux**: `Ctrl + Alt + Shift + N`
   - **Mac**: `Command + Option + O`
   - AÃ§Ä±klama: Projedeki herhangi bir sembolÃ¼ (deÄŸiÅŸken, metod, sÄ±nÄ±f vb.) arar.

- **Son DÃ¼zenlenen DosyalarÄ± GÃ¶ster**:
   - **Windows/Linux**: `Ctrl + E`
   - **Mac**: `Command + E`
   - AÃ§Ä±klama: En son aÃ§Ä±lan veya dÃ¼zenlenen dosyalarÄ± listeler.

### 2. Kod DÃ¼zenleme
- **Kod Tamamlama**:
   - **Windows/Linux**: `Ctrl + Space`
   - **Mac**: `Control + Space`
   - AÃ§Ä±klama: Kod tamamlama iÃ§in Ã¶neriler sunar.

- **Kod Formatlama**:
   - **Windows/Linux**: `Ctrl + Alt + L`
   - **Mac**: `Command + Option + L`
   - AÃ§Ä±klama: SeÃ§ili kodu veya dosyayÄ± IntelliJ IDEA'nÄ±n dÃ¼zenleme kurallarÄ±na gÃ¶re otomatik olarak biÃ§imlendirir.

- **KullanÄ±lmayan ImportlarÄ± Temizleme**:
   - **Windows/Linux**: `Ctrl + Alt + O`
   - **Mac**: `Command + Option + O`
   - AÃ§Ä±klama: KullanÄ±lmayan tÃ¼m importlarÄ± siler.

- **Ä°fadenin TamamÄ±nÄ± veya SatÄ±rÄ±n Geri KalanÄ±nÄ± Silme**:
   - **Windows/Linux**: `Ctrl + Y`
   - **Mac**: `Command + Delete`
   - AÃ§Ä±klama: SatÄ±rÄ±n geri kalanÄ±nÄ± veya seÃ§ili ifadeyi siler.

### 3. Refactoring
- **Refactor This**:
   - **Windows/Linux**: `Ctrl + Alt + Shift + T`
   - **Mac**: `Control + T`
   - AÃ§Ä±klama: Kodunuzu yeniden dÃ¼zenlemenizi saÄŸlayan refactoring seÃ§enekleri sunar.

- **DeÄŸiÅŸken, Metod vb. Yeniden AdlandÄ±rma**:
   - **Windows/Linux**: `Shift + F6`
   - **Mac**: `Shift + F6`
   - AÃ§Ä±klama: SeÃ§ilen Ã¶ÄŸeyi yeniden adlandÄ±rÄ±r; tÃ¼m kullanÄ±mlarÄ± gÃ¼nceller.

### 4. Kod Ä°nceleme ve Ã‡alÄ±ÅŸtÄ±rma
- **Hata Bulma (Debugging) BaÅŸlat**:
   - **Windows/Linux**: `Shift + F9`
   - **Mac**: `Control + D`
   - AÃ§Ä±klama: UygulamayÄ± hata ayÄ±klama modunda baÅŸlatÄ±r.

- **Ã‡alÄ±ÅŸtÄ±rma (Run)**:
   - **Windows/Linux**: `Shift + F10`
   - **Mac**: `Control + R`
   - AÃ§Ä±klama: UygulamayÄ± Ã§alÄ±ÅŸtÄ±rÄ±r.

- **Hata Ã‡Ä±karma (Step Into)**:
   - **Windows/Linux**: `F7`
   - **Mac**: `F7`
   - AÃ§Ä±klama: Kodda adÄ±m adÄ±m hata ayÄ±klamaya girer.

- **Sonraki AdÄ±ma GeÃ§me (Step Over)**:
   - **Windows/Linux**: `F8`
   - **Mac**: `F8`
   - AÃ§Ä±klama: Mevcut adÄ±mdan bir sonraki adÄ±ma geÃ§er.

### 5. Genel KÄ±sayollar
- **Arama (Search Everywhere)**:
   - **Windows/Linux**: `Shift` tuÅŸuna iki kere basÄ±n
   - **Mac**: `Shift` tuÅŸuna iki kere basÄ±n
   - AÃ§Ä±klama: Dosya, sÄ±nÄ±f, sembol veya herhangi bir ÅŸeyi genel olarak arar.

- **Proje Gezginini AÃ§ma/Kapatma (Project View)**:
   - **Windows/Linux**: `Alt + 1`
   - **Mac**: `Command + 1`
   - AÃ§Ä±klama: Proje dosya gezgini penceresini aÃ§ar veya kapatÄ±r.

- **Terminal AÃ§ma**:
   - **Windows/Linux**: `Alt + F12`
   - **Mac**: `Option + F12`
   - AÃ§Ä±klama: IntelliJ IDEA iÃ§indeki terminali aÃ§ar.

Bu kÄ±sayollar, IntelliJ IDEA'da hÄ±zlÄ± bir ÅŸekilde Ã§alÄ±ÅŸmanÄ±zÄ± saÄŸlar ve projelerdeki Ã¼retkenliÄŸinizi artÄ±rÄ±r.


## Application Server (Wildfly)
```sh 

```
---

JBoss'Ä±n yeni ismi WildFly olarak deÄŸiÅŸtirildi. Red Hat tarafÄ±ndan geliÅŸtirilen JBoss Application Server, 2013 yÄ±lÄ±nda yapÄ±lan bir deÄŸiÅŸiklikle WildFly olarak yeniden adlandÄ±rÄ±ldÄ±. Bu deÄŸiÅŸiklikle, JBoss topluluÄŸunun Ã¼cretsiz ve aÃ§Ä±k kaynaklÄ± uygulama sunucusu sÃ¼rÃ¼mÃ¼nÃ¼ ifade etmek iÃ§in "WildFly" ismi kullanÄ±lÄ±rken, ticari sÃ¼rÃ¼m iÃ§in Red Hat JBoss Enterprise Application Platform (EAP) ismi kullanÄ±lmaktadÄ±r.

WildFly, Java EE ve Jakarta EE uyumlu, yÃ¼ksek performanslÄ± bir uygulama sunucusu olarak geliÅŸtirilmiÅŸ olup, bulut tabanlÄ± mikroservis mimarileriyle uyumludur.

Ä°htiyacÄ±nÄ±za gÃ¶re en uygun WildFly daÄŸÄ±tÄ±mÄ±nÄ± seÃ§erken dikkate almanÄ±z gereken bazÄ± ayrÄ±ntÄ±lar ÅŸunlardÄ±r:

1. **WildFly DaÄŸÄ±tÄ±mÄ±**:
   - **KullanÄ±m AmacÄ±**: Bu, Ã¼retim ve geliÅŸtirme ortamlarÄ±nda kullanÄ±labilen standart WildFly uygulama sunucusudur. EÄŸer doÄŸrudan WildFly'Ä±n kararlÄ± sÃ¼rÃ¼mÃ¼nÃ¼ kullanarak bir uygulama daÄŸÄ±tmak ya da geliÅŸtirme yapmak istiyorsanÄ±z, bu seÃ§enek idealdir.
   - **Ä°ndirme FormatlarÄ±**:
      - **zip**: Windows gibi dosya sÄ±kÄ±ÅŸtÄ±rma araÃ§larÄ±nÄ±n yaygÄ±n olarak desteklediÄŸi bir formattÄ±r. Ã–zellikle Windows iÅŸletim sisteminde WildFly kurulumunu kolaylaÅŸtÄ±rÄ±r.
      - **tgz**: Linux/Unix tabanlÄ± sistemlerde tercih edilen bir sÄ±kÄ±ÅŸtÄ±rma formatÄ±dÄ±r. EÄŸer Linux tabanlÄ± bir sunucuda Ã§alÄ±ÅŸÄ±yorsanÄ±z `tgz` formatÄ±nÄ± tercih edebilirsiniz.
   - **SHA-1 Karma DeÄŸeri**: DosyanÄ±n bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ doÄŸrulamak iÃ§in kullanÄ±labilir. Ä°ndirilen dosyanÄ±n bozulmamÄ±ÅŸ olduÄŸundan emin olmak iÃ§in SHA-1 deÄŸerini kontrol edebilirsiniz.

2. **WildFly Ã–nizleme DaÄŸÄ±tÄ±mÄ±**:
   - **KullanÄ±m AmacÄ±**: Bu, henÃ¼z tam kararlÄ± hale getirilmemiÅŸ Ã¶zellikleri iÃ§erir. Yeni Ã¶zellikleri test etmek ya da geliÅŸtirme sÄ±rasÄ±nda en son yenilikleri denemek istiyorsanÄ±z bu seÃ§eneÄŸi indirebilirsiniz. Ancak Ã¼retim ortamlarÄ±nda kullanÄ±lmasÄ± Ã¶nerilmez, Ã§Ã¼nkÃ¼ tam olarak kararlÄ± deÄŸildir.
   - **Ä°ndirme FormatlarÄ±**: Yine `zip` ve `tgz` formatlarÄ±nda sunulmaktadÄ±r. Ã‡alÄ±ÅŸtÄ±ÄŸÄ±nÄ±z iÅŸletim sistemine gÃ¶re uygun formatÄ± seÃ§ebilirsiniz.
   - **SHA-1 Karma DeÄŸeri**: Dosya doÄŸrulamasÄ± iÃ§in saÄŸlanmÄ±ÅŸtÄ±r.

3. **Uygulama Sunucusu Kaynak Kodu**:
   - **KullanÄ±m AmacÄ±**: EÄŸer WildFly'Ä±n kaynak kodunu incelemek, modifiye etmek ya da WildFly Ã¼zerinde Ã¶zelleÅŸtirilmiÅŸ geliÅŸtirmeler yapmak istiyorsanÄ±z bu seÃ§eneÄŸi tercih edebilirsiniz. Kaynak kodu, projeye daha derinlemesine bir inceleme yapma imkanÄ± sunar.
   - **Ä°ndirme FormatlarÄ±**: `zip` ve `tgz` olarak sunulur, yukarÄ±da bahsedildiÄŸi gibi iÅŸletim sistemine gÃ¶re seÃ§ebilirsiniz.
   - **SHA-1 Karma DeÄŸeri**: Ä°ndirilen dosyanÄ±n orijinal olduÄŸundan emin olmak iÃ§in SHA-1 doÄŸrulamasÄ± yapabilirsiniz.

4. **HÄ±zlÄ± BaÅŸlangÄ±Ã§ Kaynak Kodu**:
   - **KullanÄ±m AmacÄ±**: WildFly Ã¼zerinde Ã¶rnek projeler ya da eÄŸitim materyalleri ile hÄ±zlÄ± bir baÅŸlangÄ±Ã§ yapmak istiyorsanÄ±z bu kaynak kodunu indirmeniz faydalÄ± olabilir. Ã–rnek uygulamalar ve kullanÄ±m senaryolarÄ±nÄ± iÃ§erir.
   - **Git Tag**: Git Ã¼zerinden doÄŸrudan eriÅŸim imkanÄ± sunar. Git kullanarak kaynak kodunu daha kolay yÃ¶netebilir ve sÃ¼rÃ¼m kontrolÃ¼ yapabilirsiniz.
   - **zip ve SHA-1**: Zip formatÄ±nda indirmek ve doÄŸrulamak iÃ§in seÃ§enekler mevcut.

5. **SÃ¼rÃ¼m NotlarÄ±**:
   - **KullanÄ±m AmacÄ±**: WildFly'Ä±n bu sÃ¼rÃ¼mÃ¼nde yapÄ±lan deÄŸiÅŸiklikler, yeni Ã¶zellikler, dÃ¼zeltmeler ve bilinen sorunlar hakkÄ±nda bilgi almak iÃ§in sÃ¼rÃ¼m notlarÄ±nÄ± inceleyebilirsiniz. Bu notlar, hangi Ã¶zelliklerin eklendiÄŸi veya deÄŸiÅŸtiÄŸi hakkÄ±nda detaylÄ± bilgi saÄŸlar.

**Ã–zetle**:
- **GeliÅŸtirme veya Ãœretim Ä°Ã§in**: Standart **WildFly DaÄŸÄ±tÄ±mÄ±** Ã¶nerilir.
- **Yeni Ã–zellikleri Test Etmek Ä°Ã§in**: **WildFly Ã–nizleme DaÄŸÄ±tÄ±mÄ±** uygun olabilir.
- **Kaynak Kod Ä°ncelemesi veya Ã–zelleÅŸtirme Ä°Ã§in**: **Uygulama Sunucusu Kaynak Kodu** tercih edilebilir.
- **Ã–rnek Uygulama ve HÄ±zlÄ± BaÅŸlangÄ±Ã§ Ä°Ã§in**: **HÄ±zlÄ± BaÅŸlangÄ±Ã§ Kaynak Kodu** yararlÄ± olabilir.

Sizin gereksinimlerinize gÃ¶re en uygun seÃ§eneÄŸi yukarÄ±daki aÃ§Ä±klamalara gÃ¶re seÃ§ebilirsiniz.


## Spring Data (JdbcTemplate)
```sh 

```
---

`JdbcTemplate`, Spring Framework'Ã¼n bir parÃ§asÄ± olarak veri tabanÄ±yla etkileÅŸimde bulunmak iÃ§in geliÅŸtirilmiÅŸ bir sÄ±nÄ±ftÄ±r ve Ã¶zellikle Spring Boot uygulamalarÄ±nda yaygÄ±n olarak kullanÄ±lÄ±r. `JdbcTemplate`, SQL sorgularÄ±nÄ± Ã§alÄ±ÅŸtÄ±rmak, veri tabanÄ±ndan veri Ã§ekmek, gÃ¼ncelleme iÅŸlemleri yapmak ve veritabanÄ± baÄŸlantÄ±larÄ±nÄ± yÃ¶netmek iÃ§in gÃ¼Ã§lÃ¼ ve basit bir yol saÄŸlar. Spring Boot, `JdbcTemplate` sÄ±nÄ±fÄ±nÄ±n kullanÄ±lmasÄ±nÄ± daha da kolaylaÅŸtÄ±rarak, veri tabanÄ± iÅŸlemleri iÃ§in hem esneklik hem de gÃ¼venilirlik sunar.

### JdbcTemplate'in AmacÄ±
`JdbcTemplate`, JDBC (Java Database Connectivity) API'sini basitleÅŸtirmeyi amaÃ§lar. Geleneksel JDBC kodu yazarken, kaynaklarÄ± aÃ§ma ve kapatma, hata iÅŸleme, veritabanÄ± baÄŸlantÄ±larÄ±nÄ±n yÃ¶netimi gibi Ã§eÅŸitli iÅŸlemler manuel olarak yapÄ±lÄ±r ve bu da hata riskini artÄ±rÄ±r. `JdbcTemplate`, bu tÃ¼r gÃ¶revleri otomatikleÅŸtirerek, JDBC iÅŸlemlerini basitleÅŸtirir. Bu sayede, geliÅŸtiriciler odaklarÄ±nÄ± SQL sorgularÄ±na ve iÅŸ mantÄ±ÄŸÄ±na verebilirler.

### JdbcTemplate'in SaÄŸladÄ±ÄŸÄ± Faydalar
- **Kaynak YÃ¶netimi**: `JdbcTemplate`, veritabanÄ± baÄŸlantÄ±larÄ±nÄ± otomatik olarak yÃ¶netir ve kapatÄ±r, bÃ¶ylece baÄŸlantÄ± sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.
- **Hata Ä°ÅŸleme**: `SQLException` gibi veritabanÄ± hatalarÄ±nÄ± otomatik olarak iÅŸler ve bunlarÄ± daha anlamlÄ± `DataAccessException` sÄ±nÄ±flarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r.
- **Basit KullanÄ±m**: CRUD (Create, Read, Update, Delete) iÅŸlemlerini gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±mÄ± kolay metodlar sunar.
- **GÃ¼venli Parametre KullanÄ±mÄ±**: SQL enjeksiyonu gibi gÃ¼venlik aÃ§Ä±klarÄ±nÄ± Ã¶nlemek iÃ§in parametreli sorgularÄ± destekler.
- **Esneklik**: VeritabanÄ±na Ã¶zel SQL sorgularÄ± yazma esnekliÄŸi saÄŸlar ve ORM kullanÄ±mÄ± zorunluluÄŸu yoktur.

### JdbcTemplate KullanÄ±m AdÄ±mlarÄ±
Spring Boot uygulamasÄ±nda `JdbcTemplate` kullanmak iÃ§in temel adÄ±mlar ÅŸunlardÄ±r:

#### 1. BaÄŸÄ±mlÄ±lÄ±klarÄ± Ekleme
Spring Boot projesinde `JdbcTemplate` kullanmak iÃ§in `spring-boot-starter-jdbc` baÄŸÄ±mlÄ±lÄ±ÄŸÄ±na ihtiyacÄ±nÄ±z vardÄ±r. `pom.xml` dosyasÄ±na aÅŸaÄŸÄ±daki baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ekleyin:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

#### 2. Veri TabanÄ± YapÄ±landÄ±rmasÄ±
UygulamanÄ±zÄ±n `application.properties` veya `application.yml` dosyasÄ±na veri tabanÄ± yapÄ±landÄ±rmalarÄ±nÄ± ekleyin:

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/yourdatabase
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

#### 3. JdbcTemplate Bean TanÄ±mlama
Spring Boot, otomatik yapÄ±landÄ±rma sayesinde `JdbcTemplate` bean'ini otomatik olarak yaratÄ±r. Bu yÃ¼zden `JdbcTemplate` nesnesini doÄŸrudan kullanabiliriz:

```java
@Autowired
private JdbcTemplate jdbcTemplate;
```

### JdbcTemplate ile CRUD Ä°ÅŸlemleri

#### Veri Ekleme (Insert)
`JdbcTemplate` ile veri eklemek iÃ§in `update` metodu kullanÄ±lÄ±r:

```java
String sql = "INSERT INTO customers (name, age, city) VALUES (?, ?, ?)";
jdbcTemplate.update(sql, "Ali", 30, "Ankara");
```

#### Veri Okuma (Select)
Veri tabanÄ±ndan veri Ã§ekmek iÃ§in `queryForObject` veya `query` metotlarÄ± kullanÄ±lÄ±r.

- **Tek Bir DeÄŸer DÃ¶ndÃ¼rme**:

```java
String sql = "SELECT COUNT(*) FROM customers";
Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
```

- **Liste DÃ¶ndÃ¼rme**:

```java
String sql = "SELECT * FROM customers";
List<Customer> customers = jdbcTemplate.query(sql, new BeanPropertyRowMapper<>(Customer.class));
```

#### Veri GÃ¼ncelleme (Update)
Var olan veriyi gÃ¼ncellemek iÃ§in `update` metodu kullanÄ±lÄ±r:

```java
String sql = "UPDATE customers SET city = ? WHERE name = ?";
jdbcTemplate.update(sql, "Istanbul", "Ali");
```

#### Veri Silme (Delete)
Veriyi silmek iÃ§in yine `update` metodunu kullanabiliriz:

```java
String sql = "DELETE FROM customers WHERE name = ?";
jdbcTemplate.update(sql, "Ali");
```

### JdbcTemplate RowMapper KullanÄ±mÄ±
`RowMapper`, veritabanÄ± kayÄ±tlarÄ±nÄ± Java nesnelerine dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in kullanÄ±lan bir arayÃ¼zdÃ¼r. `BeanPropertyRowMapper` sÄ±nÄ±fÄ±, SQL sorgusundan dÃ¶nen verileri otomatik olarak belirttiÄŸimiz nesneye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼r:

```java
String sql = "SELECT * FROM customers WHERE id = ?";
Customer customer = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<>(Customer.class), 1);
```

#### Ã–zel RowMapper KullanÄ±mÄ±
Kendi `RowMapper` sÄ±nÄ±fÄ±nÄ±zÄ± oluÅŸturmak isterseniz, `RowMapper` arayÃ¼zÃ¼nÃ¼ uygulayabilirsiniz:

```java
public class CustomerRowMapper implements RowMapper<Customer> {
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
        Customer customer = new Customer();
        customer.setId(rs.getInt("id"));
        customer.setName(rs.getString("name"));
        customer.setCity(rs.getString("city"));
        return customer;
    }
}

// KullanÄ±m
String sql = "SELECT * FROM customers WHERE id = ?";
Customer customer = jdbcTemplate.queryForObject(sql, new CustomerRowMapper(), 1);
```

### JdbcTemplate BatchUpdate
`BatchUpdate` metodu, Ã§ok sayÄ±da veri iÅŸlemi yapmanÄ±z gerektiÄŸinde birden fazla SQL sorgusunu tek seferde Ã§alÄ±ÅŸtÄ±rarak performansÄ± artÄ±rÄ±r:

```java
String sql = "INSERT INTO customers (name, age, city) VALUES (?, ?, ?)";
List<Object[]> batchArgs = Arrays.asList(
    new Object[]{"Ali", 30, "Ankara"},
    new Object[]{"AyÅŸe", 25, "Ä°stanbul"},
    new Object[]{"Mehmet", 35, "Ä°zmir"}
);

jdbcTemplate.batchUpdate(sql, batchArgs);
```

### JdbcTemplate ile Transaction YÃ¶netimi
`JdbcTemplate`, `@Transactional` anotasyonu ile iÅŸlemleri bir bÃ¼tÃ¼n olarak ele alÄ±r. EÄŸer bir iÅŸlem sÄ±rasÄ±nda hata oluÅŸursa, yapÄ±lan deÄŸiÅŸiklikler geri alÄ±nÄ±r:

```java
@Service
public class CustomerService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Transactional
    public void transferFunds(int senderId, int receiverId, double amount) {
        jdbcTemplate.update("UPDATE accounts SET balance = balance - ? WHERE id = ?", amount, senderId);
        jdbcTemplate.update("UPDATE accounts SET balance = balance + ? WHERE id = ?", amount, receiverId);
    }
}
```

### JdbcTemplate ve Spring Boot'ta Exception Management
`JdbcTemplate`, `SQLException` gibi veritabanÄ± hatalarÄ±nÄ± `DataAccessException` isimli bir Ã¼st sÄ±nÄ±f ile kapsar. Bu sayede istisnalarÄ± kolayca yÃ¶netebilirsiniz:

```java
try {
    jdbcTemplate.update("UPDATE customers SET city = ? WHERE id = ?", "Izmir", 1);
} catch (DataAccessException e) {
    // Hata yÃ¶netimi
    System.out.println("Veri tabanÄ± hatasÄ±: " + e.getMessage());
}
```

### JdbcTemplate'in Alternatifleri
Spring Boot ve Spring Framework, veritabanÄ± iÅŸlemleri iÃ§in `JdbcTemplate` dÄ±ÅŸÄ±nda baÅŸka araÃ§lar da sunar:
- **Spring Data JPA**: ORM (Object Relational Mapping) kullanmak isteyenler iÃ§in idealdir.
- **NamedParameterJdbcTemplate**: Parametreli SQL sorgularÄ± iÃ§in daha esnek bir yapÄ± sunar.
- **Spring Data JDBC**: `JdbcTemplate`'in daha modern bir alternatifi olarak basit veri tabanÄ± iÅŸlemleri iÃ§in kullanÄ±lÄ±r.

### SonuÃ§
`JdbcTemplate`, SQL sorgularÄ±nÄ± manuel yazmak isteyen veya ORM kullanmadan doÄŸrudan veritabanÄ±yla etkileÅŸim kurmak isteyen Spring Boot geliÅŸtiricileri iÃ§in gÃ¼Ã§lÃ¼ ve kullanÄ±ÅŸlÄ± bir araÃ§tÄ±r. JDBC iÅŸlemlerini kolaylaÅŸtÄ±rarak, kaynak yÃ¶netimi, hata iÅŸleme ve parametre gÃ¼venliÄŸi gibi konularda standart Ã§Ã¶zÃ¼mler sunar.


## Spring Data (JdbcTemplate)
```sh 

```
---

Spring Frameworkâ€™Ã¼n bir bileÅŸeni olan `JdbcTemplate`, veri tabanÄ±yla etkileÅŸimi kolaylaÅŸtÄ±rmak iÃ§in geliÅŸtirilmiÅŸ bir araÃ§tÄ±r. JDBC (Java Database Connectivity) API'sini basitleÅŸtirir ve veri tabanÄ± baÄŸlantÄ±larÄ±, hata yÃ¶netimi, veri Ã§ekme ve gÃ¼ncelleme iÅŸlemleri gibi temel iÅŸlevleri daha rahat ve gÃ¼venli hale getirir. `JdbcTemplate` kullanmanÄ±n avantajlarÄ± kadar bazÄ± dezavantajlarÄ± da bulunmaktadÄ±r. Ä°ÅŸte detaylÄ± bir ÅŸekilde avantaj ve dezavantajlarÄ±:

---

### JdbcTemplateâ€™in AvantajlarÄ±

1. **Kaynak YÃ¶netiminin KolaylÄ±ÄŸÄ±**:
   - JDBC ile Ã§alÄ±ÅŸÄ±rken baÄŸlantÄ±, `Statement` ve `ResultSet` gibi kaynaklarÄ± manuel olarak aÃ§mak ve kapatmak gerekir. `JdbcTemplate`, bu kaynaklarÄ± otomatik olarak yÃ¶netir ve baÄŸlantÄ± sÄ±zÄ±ntÄ±larÄ±nÄ± Ã¶nler.
   - Ã–zellikle uzun sÃ¼reli uygulamalarda kaynak yÃ¶netiminin doÄŸru yapÄ±lmasÄ± performansÄ± artÄ±rÄ±r.

2. **Daha Basit Hata YÃ¶netimi**:
   - `JdbcTemplate`, JDBC'nin `SQLException` sÄ±nÄ±fÄ± yerine `DataAccessException` adlÄ± daha genel ve Springâ€™e Ã¶zgÃ¼ bir istisna yÃ¶netimi saÄŸlar.
   - Bu sayede, SQL hatalarÄ±nÄ± uygulama dÃ¼zeyinde daha iyi yakalamak ve yÃ¶netmek mÃ¼mkÃ¼ndÃ¼r.

3. **GÃ¼venli Parametreli Sorgu DesteÄŸi**:
   - `JdbcTemplate`, SQL enjeksiyonuna karÅŸÄ± koruma saÄŸlayan parametreli sorgularÄ± destekler. Parametreli sorgular ile deÄŸiÅŸkenler gÃ¼venli bir ÅŸekilde SQL cÃ¼mlelerine yerleÅŸtirilir.
   - SQL enjeksiyonu gibi gÃ¼venlik aÃ§Ä±klarÄ±na karÅŸÄ± Ã¶nlem alÄ±nmasÄ± gÃ¼venilir bir veri tabanÄ± eriÅŸimi saÄŸlar.

4. **CRUD Ä°ÅŸlemlerini KolaylaÅŸtÄ±rma**:
   - Veri ekleme, gÃ¼ncelleme, silme ve okuma gibi iÅŸlemler `JdbcTemplate` ile Ã§ok daha basit hale gelir. `update()`, `query()`, `queryForObject()` gibi metodlar sayesinde temel SQL iÅŸlemleri hÄ±zlÄ±ca yapÄ±labilir.
   - Bu da veri tabanÄ± ile sÄ±k etkileÅŸimde bulunan uygulamalarda geliÅŸtirme sÃ¼recini hÄ±zlandÄ±rÄ±r.

5. **Esnek SQL Yazma Ä°mkanÄ±**:
   - ORM (Object-Relational Mapping) araÃ§larÄ±na kÄ±yasla `JdbcTemplate` ile tamamen SQL tabanlÄ± Ã§alÄ±ÅŸÄ±labilir. KarmaÅŸÄ±k SQL sorgularÄ±nÄ± `JdbcTemplate` Ã¼zerinden doÄŸrudan yazabilirsiniz.
   - Bu esneklik, Ã¶zellikle karmaÅŸÄ±k sorgu ihtiyaÃ§larÄ± olan projelerde Ã¶nemli bir avantajdÄ±r.

6. **Transaction YÃ¶netimi**:
   - Spring Framework ile uyumlu olan `JdbcTemplate`, `@Transactional` anotasyonu ile iÅŸlemleri yÃ¶netir. Bu sayede veri tabanÄ±ndaki iÅŸlemler bir bÃ¼tÃ¼n olarak ele alÄ±nÄ±r ve bir hata durumunda tÃ¼m deÄŸiÅŸiklikler geri alÄ±nÄ±r.
   - Transaction yÃ¶netiminin saÄŸladÄ±ÄŸÄ± bu bÃ¼tÃ¼nlÃ¼k, veri gÃ¼venliÄŸini artÄ±rÄ±r.

7. **Performans**:
   - ORM araÃ§larÄ±na kÄ±yasla daha hÄ±zlÄ± bir veri tabanÄ± etkileÅŸimi saÄŸlar Ã§Ã¼nkÃ¼ `JdbcTemplate`, doÄŸrudan SQL sorgularÄ± ile Ã§alÄ±ÅŸÄ±r ve veri tabanÄ± iÅŸlemlerinde bir katman daha azdÄ±r.

---

### JdbcTemplateâ€™in DezavantajlarÄ±

1. **SQL BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±**:
   - `JdbcTemplate`, SQL sorgularÄ±nÄ±n elle yazÄ±lmasÄ±nÄ± gerektirir. Bu, uygulamanÄ±n veritabanÄ± baÄŸÄ±mlÄ±lÄ±ÄŸÄ±nÄ± artÄ±rÄ±r. Ã–rneÄŸin, veritabanÄ± tÃ¼rÃ¼ deÄŸiÅŸtiÄŸinde (MySQL'den PostgreSQL'e geÃ§iÅŸ gibi) SQL ifadelerinde deÄŸiÅŸiklik yapmak gerekebilir.
   - ORM Ã§Ã¶zÃ¼mlerinde olduÄŸu gibi soyutlama seviyesi dÃ¼ÅŸÃ¼k olduÄŸu iÃ§in veritabanÄ± deÄŸiÅŸtirme sÃ¼reÃ§lerinde fazladan iÅŸ yÃ¼kÃ¼ getirir.

2. **Kod TekrarÄ±**:
   - SQL sorgularÄ±nÄ± elle yazmak, kod tekrarÄ±na yol aÃ§abilir. Ã–zellikle bÃ¼yÃ¼k projelerde benzer SQL ifadelerinin tekrar tekrar yazÄ±lmasÄ± gerekebilir.
   - ORM Ã§Ã¶zÃ¼mleri ile genellikle bu tekrarlar model katmanÄ±nda tek bir tanÄ±mla yÃ¶netilebilirken, `JdbcTemplate` ile her SQL ifadesi iÃ§in ayrÄ± bir sorgu yazmak gerekebilir.

3. **Nesne-Ä°liÅŸkisel EÅŸleme (ORM) EksikliÄŸi**:
   - `JdbcTemplate`, veri tabanÄ± kayÄ±tlarÄ±nÄ± doÄŸrudan Java nesnelerine otomatik olarak eÅŸleÅŸtirmez. Elde edilen sonuÃ§larÄ± nesnelere manuel olarak dÃ¶nÃ¼ÅŸtÃ¼rmek iÃ§in `RowMapper` kullanmak gerekebilir.
   - ORM araÃ§larÄ± (Hibernate, JPA gibi) otomatik nesne eÅŸleme desteÄŸi sunarken, `JdbcTemplate` ile bu iÅŸlemi kendiniz yapmanÄ±z gerekir.

4. **BakÄ±m ZorluÄŸu**:
   - Ã‡ok sayÄ±da SQL sorgusu iÃ§eren projelerde bakÄ±m zorluÄŸu artabilir. SQL sorgularÄ±ndaki deÄŸiÅŸiklikler doÄŸrudan kod iÃ§erisine yazÄ±ldÄ±ÄŸÄ± iÃ§in bu sorgular Ã¼zerinde yapÄ±lacak deÄŸiÅŸiklikler uygulamanÄ±n her yerinde gÃ¼ncellenmelidir.
   - Ã–zellikle bÃ¼yÃ¼k projelerde bu durum, bakÄ±m sÃ¼recinde fazladan iÅŸ yÃ¼kÃ¼ oluÅŸturur.

5. **SÄ±nÄ±rlÄ± Ã‡oklu Veri KaynaÄŸÄ± DesteÄŸi**:
   - `JdbcTemplate` varsayÄ±lan olarak tek bir veri kaynaÄŸÄ± ile Ã§alÄ±ÅŸÄ±r. Birden fazla veri kaynaÄŸÄ± ile Ã§alÄ±ÅŸmak istediÄŸinizde ekstra yapÄ±landÄ±rmalar gerekebilir.
   - ORM araÃ§larÄ± Ã§oklu veri kaynaklarÄ±nÄ± daha kolay yÃ¶netme imkanÄ±na sahipken, `JdbcTemplate`'de bu iÅŸlemler daha karmaÅŸÄ±k hale gelebilir.

6. **YÃ¼ksek Seviye Veri YÃ¶netimi Ã–zelliklerinin EksikliÄŸi**:
   - ORM araÃ§larÄ±, nesneler arasÄ± iliÅŸkiler (birlikte yÃ¼kleme, geÃ§ yÃ¼kleme) gibi geliÅŸmiÅŸ Ã¶zellikleri desteklerken `JdbcTemplate` bu Ã¶zelliklere sahip deÄŸildir.
   - Ã–rneÄŸin, iliÅŸkili nesnelerin otomatik olarak yÃ¼klenmesi gibi Ã¶zellikler `JdbcTemplate`'de bulunmaz, dolayÄ±sÄ±yla bu iliÅŸkileri yÃ¶netmek iÃ§in daha fazla manuel kod yazmak gerekebilir.

---

### JdbcTemplateâ€™in Avantaj ve DezavantajlarÄ±nÄ±n Ã–zet Tablosu

| Avantajlar                               | Dezavantajlar                                    |
|------------------------------------------|--------------------------------------------------|
| Kaynak YÃ¶netimi KolaylÄ±ÄŸÄ±                | SQL BaÄŸÄ±mlÄ±lÄ±ÄŸÄ±                                  |
| Hata YÃ¶netimi                            | Kod TekrarÄ±                                      |
| GÃ¼venli Parametreli Sorgu                | ORM EÅŸleme EksikliÄŸi                             |
| CRUD Ä°ÅŸlemlerinde KolaylÄ±k               | BakÄ±m ZorluÄŸu                                    |
| Esnek SQL Yazma Ä°mkanÄ±                   | Ã‡oklu Veri KaynaÄŸÄ± DesteÄŸi ZorluÄŸu               |
| Transaction YÃ¶netimi                      | YÃ¼ksek Seviye Veri YÃ¶netim Ã–zelliklerinin EksikliÄŸi|
| Performans                               | -                                                |

---

### SonuÃ§
Spring `JdbcTemplate`, veri tabanÄ± iÅŸlemlerini daha hÄ±zlÄ± ve basit hale getirirken, SQL baÄŸÄ±mlÄ±lÄ±ÄŸÄ± ve bakÄ±m zorluÄŸu gibi dezavantajlara da sahiptir. KÃ¼Ã§Ã¼k ve orta Ã¶lÃ§ekli projeler iÃ§in hÄ±zlÄ± bir Ã§Ã¶zÃ¼m sunar ancak bÃ¼yÃ¼k projelerde veya karmaÅŸÄ±k nesne iliÅŸkilerinin bulunduÄŸu durumlarda ORM Ã§Ã¶zÃ¼mleri (Spring Data JPA, Hibernate vb.) ile birlikte kullanÄ±lmasÄ± daha mantÄ±klÄ± olabilir. `JdbcTemplate`, SQL tabanlÄ± veri eriÅŸimi gerektiren ve ORMâ€™nin fazla soyutlama saÄŸladÄ±ÄŸÄ± projelerde ideal bir seÃ§imdir.


## Spring Boot Delivered Query, Named Query, JPQL, Native Query Ã–rnekleri
```sh 

```
---

Spring Data JPA, Java uygulamalarÄ±nda veri tabanÄ± iÅŸlemlerini kolaylaÅŸtÄ±rmak iÃ§in Ã§eÅŸitli sorgulama yÃ¶ntemleri sunar. Bu yÃ¶ntemler arasÄ±nda Delivered Query, Named Query, JPQL ve Native Query bulunur. Her birinin kendi kullanÄ±m amacÄ± ve avantajlarÄ± vardÄ±r. AÅŸaÄŸÄ±da her birinin detaylÄ± aÃ§Ä±klamalarÄ± yer almaktadÄ±r:

---

### 1. Delivered Query (Derived Query)
Delivered Query, metod isimlerinden otomatik olarak SQL sorgularÄ± Ã¼reten bir Ã¶zelliktir. Bu Ã¶zellik sayesinde, belirli kurallara uygun metod isimleri yazarak Spring Data JPAâ€™nÄ±n bu metodlar iÃ§in otomatik olarak SQL sorgusu oluÅŸturmasÄ±nÄ± saÄŸlarÄ±z. Delivered Query kullanÄ±mÄ± Ã¶zellikle basit CRUD iÅŸlemlerinde yaygÄ±n olarak tercih edilir.

#### Ã–zellikler
- **Kolay KullanÄ±m**: Metod ismine gÃ¶re Spring Data JPA, SQL sorgusunu otomatik olarak oluÅŸturur.
- **YaygÄ±n Kapsam**: Tek bir kolon Ã¼zerinde eÅŸleÅŸtirme, aralÄ±klar, sÄ±ralama ve benzeri birÃ§ok koÅŸul desteklenir.
- **Parametre Uyarlama**: Delivered Query metotlarÄ±, metod isminde belirtilen parametreleri alÄ±r ve uygun SQL sorgusunu oluÅŸturur.

#### KullanÄ±m Ã–rnekleri
Ã–rneÄŸin, bir `CustomerEntity` sÄ±nÄ±fÄ± Ã¼zerinde `firstName` ve `age` gibi alanlara gÃ¶re sorgu yapÄ±yorsak, aÅŸaÄŸÄ±daki gibi `ICustomerRepository` Ã¼zerinde Delivered Query tanÄ±mlayabiliriz:

```java
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // Belirli bir isme sahip mÃ¼ÅŸterileri bulma
    List<CustomerEntity> findByFirstName(String firstName);

    // YaÅŸÄ± belirli bir deÄŸerden bÃ¼yÃ¼k olan mÃ¼ÅŸterileri bulma
    List<CustomerEntity> findByAgeGreaterThan(int age);

    // Ä°sim sÄ±ralamasÄ±na gÃ¶re mÃ¼ÅŸterileri bulma
    List<CustomerEntity> findAllByOrderByFirstNameAsc();
}
```

Bu Ã¶rneklerde Spring Data JPA, `findByFirstName`, `findByAgeGreaterThan` ve `findAllByOrderByFirstNameAsc` metodlarÄ± iÃ§in SQL sorgularÄ±nÄ± otomatik olarak oluÅŸturur.

#### AvantajlarÄ±
- HÄ±zlÄ± ve pratik bir ÅŸekilde basit sorgularÄ± yazma imkanÄ± sunar.
- Kolay anlaÅŸÄ±lÄ±r, bakÄ±mÄ± kolaydÄ±r ve Ã§oÄŸu CRUD iÅŸlemi iÃ§in yeterlidir.

#### DezavantajlarÄ±
- KarmaÅŸÄ±k sorgular veya birden fazla tabloya eriÅŸim gerektiren durumlarda sÄ±nÄ±rlÄ±dÄ±r.
- Metod isimleri bÃ¼yÃ¼dÃ¼kÃ§e okunabilirlik azalabilir.

---

### 2. Named Query
Named Query, `@NamedQuery` anotasyonu ile `Entity` sÄ±nÄ±fÄ± Ã¼zerinde tanÄ±mlanÄ±r ve bu sorgular uygulama Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda Ã¶nceden derlenir. Named Query kullanarak sÄ±k kullanÄ±lan veya karmaÅŸÄ±k sorgularÄ± bir defa tanÄ±mlar ve bunlarÄ± repository iÃ§erisinde tekrar tekrar Ã§aÄŸÄ±rabiliriz.

#### Ã–zellikler
- **Ã–nceden TanÄ±mlÄ± ve DerlenmiÅŸ**: Uygulama baÅŸlatÄ±ldÄ±ÄŸÄ±nda, tanÄ±mlanan sorgular derlenir ve kullanÄ±lmaya hazÄ±r hale gelir.
- **TekrarlÄ± KullanÄ±m**: AynÄ± sorguyu tekrar kullanmanÄ±z gereken durumlarda uygun bir yÃ¶ntemdir.
- **Kolay BakÄ±m**: TÃ¼m Named Query'ler `Entity` sÄ±nÄ±fÄ±nda toplandÄ±ÄŸÄ±ndan, sorgularda yapÄ±lacak deÄŸiÅŸiklikler merkezi olarak yÃ¶netilebilir.

#### KullanÄ±m Ã–rnekleri
Ã–rneÄŸin, `CustomerEntity` Ã¼zerinde bir `Named Query` tanÄ±mlayalÄ±m:

```java
@Entity
@NamedQueries({
    @NamedQuery(name = "Customer.findByLastName", query = "SELECT c FROM CustomerEntity c WHERE c.lastName = :lastName"),
    @NamedQuery(name = "Customer.findByCity", query = "SELECT c FROM CustomerEntity c WHERE c.city = :city"),
    @NamedQuery(name = "Customer.findByAgeGreaterThan", query = "SELECT c FROM CustomerEntity c WHERE c.age > :age")
})
public class CustomerEntity {
    // SÄ±nÄ±f tanÄ±mÄ± burada
}

// ICustomerRepository sÄ±nÄ±fÄ±nda kullanÄ±mÄ±
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {
    
    @Query(name = "Customer.findByLastName")
    List<CustomerEntity> findByLastName(@Param("lastName") String lastName);
}
```

#### AvantajlarÄ±
- SÄ±k kullanÄ±lan sorgularÄ± merkezi bir yerde tanÄ±mlamak mÃ¼mkÃ¼ndÃ¼r.
- DerlenmiÅŸ sorgular performansÄ± artÄ±rÄ±r ve bakÄ±m aÃ§Ä±sÄ±ndan kolaylÄ±k saÄŸlar.
- KarmaÅŸÄ±k sorgularda hata ayÄ±klama ve dÃ¼zenleme kolaylÄ±ÄŸÄ± sunar.

#### DezavantajlarÄ±
- Sorgular `Entity` sÄ±nÄ±fÄ±nda toplandÄ±ÄŸÄ±ndan, `Entity` sÄ±nÄ±fÄ± karmaÅŸÄ±k hale gelebilir.
- Genellikle statik sorgular iÃ§indir, dinamik sorgular iÃ§in sÄ±nÄ±rlÄ±dÄ±r.

---

### 3. JPQL (Java Persistence Query Language)
JPQL, Java EE uygulamalarÄ±nda veri tabanÄ± sorgularÄ± yazmak iÃ§in kullanÄ±lan bir dildir ve SQL'e benzer bir yapÄ±ya sahiptir. Ancak, SQL'in aksine JPQL, doÄŸrudan veri tabanÄ± tablolarÄ±nÄ± deÄŸil, Java sÄ±nÄ±flarÄ±nÄ± ve alanlarÄ±nÄ± kullanÄ±r. JPQL sorgularÄ±, veri tabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ± saÄŸlar ve ORM tabanlÄ± uygulamalarda tercih edilir.

#### Ã–zellikler
- **Nesne TabanlÄ±**: SQLâ€™den farklÄ± olarak, doÄŸrudan tablolar yerine Java nesneleri (Entity) Ã¼zerinden Ã§alÄ±ÅŸÄ±r.
- **Veri TabanÄ± BaÄŸÄ±msÄ±zlÄ±ÄŸÄ±**: JPQL sorgularÄ± genellikle veri tabanÄ± baÄŸÄ±msÄ±zdÄ±r ve farklÄ± veri tabanlarÄ± Ã¼zerinde sorunsuz Ã§alÄ±ÅŸÄ±r.
- **Esnek**: KarmaÅŸÄ±k ve dinamik sorgular yazmak iÃ§in uygundur.

#### KullanÄ±m Ã–rnekleri
JPQL kullanarak Ã¶rnek bir sorgu yazalÄ±m:

```java
// ICustomerRepository sÄ±nÄ±fÄ±nda JPQL sorgu Ã¶rnekleri
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // Ad ve Soyada gÃ¶re mÃ¼ÅŸteri bulma
    @Query("SELECT c FROM CustomerEntity c WHERE c.firstName = :firstName AND c.lastName = :lastName")
    List<CustomerEntity> findByFullName(@Param("firstName") String firstName, @Param("lastName") String lastName);

    // YaÅŸ kriterine gÃ¶re mÃ¼ÅŸteri listeleme
    @Query("SELECT c FROM CustomerEntity c WHERE c.age > :age")
    List<CustomerEntity> findCustomersOlderThan(@Param("age") int age);
}
```

#### AvantajlarÄ±
- ORM yapÄ±sÄ±na uyumludur ve veri tabanÄ± baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r.
- KarmaÅŸÄ±k sorgular yazmayÄ± kolaylaÅŸtÄ±rÄ±r.
- Java nesneleri ile doÄŸrudan Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in daha anlaÅŸÄ±lÄ±rdÄ±r.

#### DezavantajlarÄ±
- BazÄ± Ã¶zel veri tabanÄ± iÅŸlevlerini desteklemez.
- KarmaÅŸÄ±k ve Ã§ok performans gerektiren sorgularda daha dÃ¼ÅŸÃ¼k performans gÃ¶sterebilir.

---

### 4. Native Query
Native Query, doÄŸrudan SQL sorgularÄ± kullanarak veri tabanÄ±yla etkileÅŸime girmenizi saÄŸlar. JPQL ve diÄŸer ORM tabanlÄ± sorgularÄ±n aksine, Native Query veri tabanÄ± baÄŸÄ±mlÄ± SQL sorgularÄ±nÄ± destekler. Bu nedenle, belirli bir veri tabanÄ±na Ã¶zel SQL komutlarÄ± kullanÄ±labilir.

#### Ã–zellikler
- **DoÄŸrudan SQL KullanÄ±mÄ±**: SQL dilinin tÃ¼m Ã¶zelliklerini kullanabilirsiniz (JOIN'ler, `GROUP BY` iÅŸlemleri, alt sorgular vb.)
- **Veri TabanÄ±na Ã–zel Ä°ÅŸlemler**: Veri tabanÄ± baÄŸÄ±mlÄ± sorgular yazmak mÃ¼mkÃ¼ndÃ¼r.
- **Performans**: KarmaÅŸÄ±k sorgular iÃ§in daha performanslÄ±dÄ±r Ã§Ã¼nkÃ¼ SQL'in tÃ¼m gÃ¼cÃ¼nden yararlanÄ±lÄ±r.

#### KullanÄ±m Ã–rnekleri
Ã–rneÄŸin, `ICustomerRepository` iÃ§inde Native Query ile yazÄ±lmÄ±ÅŸ SQL sorgularÄ±nÄ± gÃ¶relim:

```java
// ICustomerRepository sÄ±nÄ±fÄ±nda Native Query Ã¶rnekleri
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // Åehir ve yaÅŸ kriterine gÃ¶re mÃ¼ÅŸteri bulma
    @Query(value = "SELECT * FROM customers WHERE city = :city AND age > :age", nativeQuery = true)
    List<CustomerEntity> findCustomersInCityOlderThan(@Param("city") String city, @Param("age") int age);

    // Belirli bir soyada sahip mÃ¼ÅŸterileri listeleme
    @Query(value = "SELECT * FROM customers WHERE last_name = :lastName", nativeQuery = true)
    List<CustomerEntity> findByLastNameNative(@Param("lastName") String lastName);
}
```

#### AvantajlarÄ±
- SQLâ€™in sunduÄŸu tÃ¼m Ã¶zellikleri kullanarak veri tabanÄ±na doÄŸrudan eriÅŸim saÄŸlar.
- KarmaÅŸÄ±k ve optimize edilmesi gereken sorgular iÃ§in yÃ¼ksek performans sunar.
- Belirli veri tabanÄ± iÅŸlevlerini kullanarak daha detaylÄ± iÅŸlemler yapma imkanÄ± saÄŸlar.

#### DezavantajlarÄ±
- Veri tabanÄ± baÄŸÄ±mlÄ±dÄ±r, bu da taÅŸÄ±nabilirliÄŸi zorlaÅŸtÄ±rÄ±r.
- SQL enjeksiyonuna karÅŸÄ± dikkatli olunmasÄ± gerekir.
- ORM soyutlama katmanÄ±ndan yararlanmaz, dolayÄ±sÄ±yla nesneler arasÄ± iliÅŸkilerde manuel iÅŸlemler gerekebilir.

---

### SonuÃ§
Delivered Query, Named Query, JPQL ve Native Query her biri farklÄ± ihtiyaÃ§lara cevap veren gÃ¼Ã§lÃ¼ sorgulama yÃ¶ntemleridir.
- **Delivered Query** basit iÅŸlemler iÃ§in hÄ±zlÄ±

Ã§Ã¶zÃ¼mler sunarken,
- **Named Query** tekrarlÄ± ve Ã¶nceden tanÄ±mlanmÄ±ÅŸ sorgular iÃ§in idealdir.
- **JPQL**, veri tabanÄ± baÄŸÄ±msÄ±zlÄ±ÄŸÄ± gerektiren, nesne odaklÄ± sorgular iÃ§in tercih edilirken,
- **Native Query**, doÄŸrudan SQL sorgularÄ±yla en yÃ¼ksek performansÄ± gerektiren iÅŸlemler iÃ§in uygundur.

Her yÃ¶ntemi, uygulamanÄ±n ihtiyaÃ§larÄ±na ve veri tabanÄ± eriÅŸim gereksinimlerine gÃ¶re seÃ§erek etkili bir veri eriÅŸim stratejisi oluÅŸturabilirsiniz.


## Spring Boot Delivered Query, Named Query, JPQL, Native Query Ã–rnekleri
```sh 

```
---

DosyalarÄ±nÄ±za ve istediÄŸiniz konu baÅŸlÄ±klarÄ±na uygun olarak, `Delivered Query`, `Named Query`, `JPQL`, ve `Native Query` iÃ§in Ã¼Ã§er Ã¶rnek hazÄ±rlÄ±yorum. Bu Ã¶rnekleri, veritabanÄ± iÅŸlemleri Ã¼zerinde nasÄ±l Ã§alÄ±ÅŸacaklarÄ±na dair aÃ§Ä±klamalarla birlikte paylaÅŸacaÄŸÄ±m.

### 1. Delivered Query
Delivered Query, Spring Data JPA'nÄ±n metod adlarÄ±na gÃ¶re otomatik olarak SQL sorgularÄ±nÄ± oluÅŸturmasÄ±na dayalÄ±dÄ±r.

```java
// CustomerEntity.java dosyasÄ±nda tanÄ±mlÄ± CustomerEntity ile ICustomerRepository kullanÄ±larak Delivered Query Ã¶rnekleri
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // 1. Ad ile mÃ¼ÅŸteri bulma
    List<CustomerEntity> findByFirstName(String firstName);

    // 2. Åehir ile mÃ¼ÅŸteri listeleme
    List<CustomerEntity> findByCity(String city);

    // 3. YaÅŸ aralÄ±ÄŸÄ±ndaki mÃ¼ÅŸterileri bulma
    List<CustomerEntity> findByAgeBetween(int minAge, int maxAge);
}
```

### 2. Named Query
Named Query, genellikle `@NamedQuery` anotasyonu ile belirtilir ve sorgular `Entity` sÄ±nÄ±fÄ±nda tanÄ±mlanÄ±r. Daha sonra bu sorgular repository iÃ§inde Ã§aÄŸrÄ±lÄ±r.

```java
// CustomerEntity.java dosyasÄ±nda Named Query tanÄ±mlarÄ±
@Entity
@NamedQueries({
    @NamedQuery(name = "Customer.findByLastName", query = "SELECT c FROM CustomerEntity c WHERE c.lastName = :lastName"),
    @NamedQuery(name = "Customer.findByCity", query = "SELECT c FROM CustomerEntity c WHERE c.city = :city"),
    @NamedQuery(name = "Customer.findByAgeGreaterThan", query = "SELECT c FROM CustomerEntity c WHERE c.age > :age")
})
public class CustomerEntity {
    // CustomerEntity sÄ±nÄ±fÄ±nÄ±n diÄŸer alanlarÄ± ve metodlarÄ±
}

// ICustomerRepository.java dosyasÄ±nda Named Query Ã§aÄŸrÄ±larÄ±
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // 1. Soyad ile mÃ¼ÅŸteri bulma
    @Query(name = "Customer.findByLastName")
    List<CustomerEntity> findByLastName(@Param("lastName") String lastName);

    // 2. Åehir ile mÃ¼ÅŸteri bulma
    @Query(name = "Customer.findByCity")
    List<CustomerEntity> findByCity(@Param("city") String city);

    // 3. Belirli bir yaÅŸÄ±n Ã¼stÃ¼ndeki mÃ¼ÅŸterileri bulma
    @Query(name = "Customer.findByAgeGreaterThan")
    List<CustomerEntity> findByAgeGreaterThan(@Param("age") int age);
}
```

### 3. JPQL (Java Persistence Query Language)
JPQL, Java varlÄ±klarÄ±na dayalÄ± olarak SQL benzeri sorgular yazmamÄ±zÄ± saÄŸlar. JPQL, `@Query` anotasyonu ile kullanÄ±lÄ±r.

```java
// ICustomerRepository.java dosyasÄ±nda JPQL Ã¶rnekleri
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // 1. Ad ve Soyada gÃ¶re mÃ¼ÅŸteri bulma
    @Query("SELECT c FROM CustomerEntity c WHERE c.firstName = :firstName AND c.lastName = :lastName")
    List<CustomerEntity> findByFullName(@Param("firstName") String firstName, @Param("lastName") String lastName);

    // 2. YaÅŸ kriterine gÃ¶re mÃ¼ÅŸteri listeleme
    @Query("SELECT c FROM CustomerEntity c WHERE c.age > :age")
    List<CustomerEntity> findCustomersOlderThan(@Param("age") int age);

    // 3. Åehirde bulunan mÃ¼ÅŸterileri listeleme
    @Query("SELECT c FROM CustomerEntity c WHERE c.city = :city")
    List<CustomerEntity> findByCity(@Param("city") String city);
}
```

### 4. Native Query
Native Query, doÄŸrudan SQL komutlarÄ±nÄ± kullanmamÄ±za olanak tanÄ±r ve `@Query` anotasyonu ile belirtilir. JPQLâ€™in aksine, SQL sorgularÄ± veri tabanÄ± baÄŸÄ±mlÄ± hale gelir.

```java
// ICustomerRepository.java dosyasÄ±nda Native Query Ã¶rnekleri
public interface ICustomerRepository extends JpaRepository<CustomerEntity, Long> {

    // 1. Åehir ve yaÅŸ kriterine gÃ¶re mÃ¼ÅŸteri bulma
    @Query(value = "SELECT * FROM customers WHERE city = :city AND age > :age", nativeQuery = true)
    List<CustomerEntity> findCustomersInCityOlderThan(@Param("city") String city, @Param("age") int age);

    // 2. Belirli bir soyada sahip mÃ¼ÅŸterileri listeleme
    @Query(value = "SELECT * FROM customers WHERE last_name = :lastName", nativeQuery = true)
    List<CustomerEntity> findByLastNameNative(@Param("lastName") String lastName);

    // 3. TÃ¼m mÃ¼ÅŸterileri alfabetik sÄ±rayla listeleme
    @Query(value = "SELECT * FROM customers ORDER BY first_name ASC", nativeQuery = true)
    List<CustomerEntity> findAllOrderedByFirstName();
}
```

Bu Ã¶rnekler, veri tabanÄ± sorgularÄ±nÄ± Ã§eÅŸitli ÅŸekillerde kullanmanÄ±za olanak saÄŸlar:
- Delivered Query, otomatik sorgu oluÅŸturma ile daha kÄ±sa kodlama saÄŸlarken
- Named Query, Entity sÄ±nÄ±fÄ±nda Ã¶nceden tanÄ±mlanmÄ±ÅŸ sorgularÄ± kullanÄ±r,
- JPQL, Java varlÄ±klarÄ±na dayalÄ± SQL benzeri sorgular oluÅŸturur,
- Native Query ise doÄŸrudan SQL kullanÄ±larak daha karmaÅŸÄ±k veya veri tabanÄ±na Ã¶zel sorgularÄ±n gerÃ§ekleÅŸtirilmesine olanak tanÄ±r.



## Spring Boot
```sh 

```
---